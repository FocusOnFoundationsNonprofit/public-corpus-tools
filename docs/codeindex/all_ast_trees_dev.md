Module(body=[Import(names=[alias(name='os')]), Import(names=[alias(name='glob')]), Import(names=[alias(name='csv')]), Import(names=[alias(name='re')]), Import(names=[alias(name='inspect')]), ImportFrom(module='datetime', names=[alias(name='datetime')], level=0), Import(names=[alias(name='pytz')]), Import(names=[alias(name='time')]), Import(names=[alias(name='shutil')]), Import(names=[alias(name='json')]), Import(names=[alias(name='inspect')]), ImportFrom(module='termcolor', names=[alias(name='colored')], level=0), Import(names=[alias(name='warnings')]), FunctionDef(name='custom_formatwarning', args=arguments(posonlyargs=[], args=[arg(arg='msg'), arg(arg='category'), arg(arg='filename'), arg(arg='lineno'), arg(arg='line')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n    DO NOT CALL - only used to define the custom format\n    ')), Return(value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='category', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='msg', ctx=Load()), conversion=-1), Constant(value='\n')]))], decorator_list=[]), Assign(targets=[Attribute(value=Name(id='warnings', ctx=Load()), attr='formatwarning', ctx=Store())], value=Name(id='custom_formatwarning', ctx=Load())), FunctionDef(name='verbose_print', args=arguments(posonlyargs=[], args=[arg(arg='verbose')], vararg=arg(arg='messages'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Helper function to pass on bool verbose and make verbose printing cleaner\n    \n    :param verbose: boolean for whether to print the messages.\n    :param messages: tuple of variable-length argument list.\n    :return: None\n    ')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='verbose', ctx=Load()), Name(id='bool', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value="The first parameter 'verbose' must be of type bool.")], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='messages', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='At least one message must be provided.')], keywords=[]))], orelse=[]), If(test=Name(id='verbose', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Starred(value=Name(id='messages', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='check_file_exists', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='operation_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Checks file existence and raises a ValueError if not found, which stops execution.\n\n    :param file_path: string of file path which can be absolute or relative.\n    :param operation_name: string of the message that the ValueError will print, typically the function name - optional message.\n    :return: bool, True if file exists, False otherwise.\n    ')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='VALUE ERROR in '), FormattedValue(value=Name(id='operation_name', ctx=Load()), conversion=-1), Constant(value=': input file does not exist for '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), Return(value=Constant(value=True))], decorator_list=[]), FunctionDef(name='warn_file_overwrite', args=arguments(posonlyargs=[], args=[arg(arg='file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Checks if a file already exists and issues a warning if it does.\n\n    :param file_path: string representing the path of the file to be checked.\n    :return: bool, True if file exists, False otherwise.\n    ')), Assign(targets=[Name(id='func_name', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='currentframe', ctx=Load()), args=[], keywords=[]), attr='f_back', ctx=Load()), attr='f_code', ctx=Load()), attr='co_name', ctx=Load())), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value='The function: '), FormattedValue(value=Name(id='func_name', ctx=Load()), conversion=-1), Constant(value=" is overwriting a file that already exists, file: '"), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value="'")])], keywords=[])), Return(value=Constant(value=True))], orelse=[]), Return(value=Constant(value=False))], decorator_list=[]), FunctionDef(name='get_suffix', args=arguments(posonlyargs=[], args=[arg(arg='file_str'), arg(arg='delimiter')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='_')]), body=[Expr(value=Constant(value='\n    Extracts the suffix from a given file string based on a specified delimiter.\n\n    :param file_str: string of the file name from which to extract the suffix.\n    :param delimiter: string representing the delimiter used to separate the suffix from the rest of the file string. Default is "_".\n    :return: string of the extracted suffix or None if no valid suffix is found.\n    ')), Assign(targets=[Name(id='file_base', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='file_str', ctx=Load())], keywords=[])), Assign(targets=[Name(id='period_count', ctx=Store())], value=Call(func=Attribute(value=Name(id='file_base', ctx=Load()), attr='count', ctx=Load()), args=[Constant(value='.')], keywords=[])), If(test=Compare(left=Name(id='period_count', ctx=Load()), ops=[Gt()], comparators=[Constant(value=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='in get_suffix: More than one period found in the input file string.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='delimiter_index', ctx=Store())], value=Call(func=Attribute(value=Name(id='file_base', ctx=Load()), attr='rfind', ctx=Load()), args=[Name(id='delimiter', ctx=Load())], keywords=[])), Assign(targets=[Name(id='extension_index', ctx=Store())], value=Call(func=Attribute(value=Name(id='file_base', ctx=Load()), attr='rfind', ctx=Load()), args=[Constant(value='.')], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='delimiter_index', ctx=Load()), ops=[NotEq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), BoolOp(op=Or(), values=[Compare(left=Name(id='extension_index', ctx=Load()), ops=[Eq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), Compare(left=Name(id='delimiter_index', ctx=Load()), ops=[Lt()], comparators=[Name(id='extension_index', ctx=Load())])])]), body=[Assign(targets=[Name(id='preceding_str', ctx=Store())], value=Subscript(value=Name(id='file_base', ctx=Load()), slice=Slice(upper=Name(id='delimiter_index', ctx=Load())), ctx=Load())), If(test=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='match', ctx=Load()), args=[Constant(value='\\d{4}-\\d{2}-\\d{2}$'), Name(id='preceding_str', ctx=Load())], keywords=[]), body=[Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='suffix_end_index', ctx=Store())], value=IfExp(test=Compare(left=Name(id='extension_index', ctx=Load()), ops=[NotEq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=Name(id='extension_index', ctx=Load()), orelse=Call(func=Name(id='len', ctx=Load()), args=[Name(id='file_base', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='suffix', ctx=Store())], value=Subscript(value=Name(id='file_base', ctx=Load()), slice=Slice(lower=Name(id='delimiter_index', ctx=Load()), upper=Name(id='suffix_end_index', ctx=Load())), ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='char', ctx=Load()), attr='isalnum', ctx=Load()), args=[], keywords=[]), Compare(left=Name(id='char', ctx=Load()), ops=[Eq()], comparators=[Constant(value='-')])]), generators=[comprehension(target=Name(id='char', ctx=Store()), iter=Call(func=Attribute(value=Name(id='suffix', ctx=Load()), attr='strip', ctx=Load()), args=[Name(id='delimiter', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[])), body=[If(test=Compare(left=Constant(value=' '), ops=[In()], comparators=[Name(id='suffix', ctx=Load())]), body=[Return(value=Constant(value=None))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='in get_suffix: The extracted suffix contains invalid characters.')], keywords=[]))])], orelse=[]), Return(value=Name(id='suffix', ctx=Load()))], orelse=[Return(value=Constant(value=None))])], decorator_list=[]), FunctionDef(name='add_suffix_in_str', args=arguments(posonlyargs=[], args=[arg(arg='file_str'), arg(arg='suffix_add')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Adds a suffix to a given file string.\n\n    :param file_str: string of the file name to which the suffix will be added.\n    :param suffix_add: string of the suffix to be added to the file string.\n    :return: string of the file name with the added suffix.\n    ')), Assign(targets=[Name(id='extension_index', ctx=Store())], value=Call(func=Attribute(value=Name(id='file_str', ctx=Load()), attr='rfind', ctx=Load()), args=[Constant(value='.')], keywords=[])), If(test=Compare(left=Name(id='extension_index', ctx=Load()), ops=[Eq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=[Return(value=BinOp(left=Name(id='file_str', ctx=Load()), op=Add(), right=Name(id='suffix_add', ctx=Load())))], orelse=[]), Return(value=BinOp(left=BinOp(left=Subscript(value=Name(id='file_str', ctx=Load()), slice=Slice(upper=Name(id='extension_index', ctx=Load())), ctx=Load()), op=Add(), right=Name(id='suffix_add', ctx=Load())), op=Add(), right=Subscript(value=Name(id='file_str', ctx=Load()), slice=Slice(lower=Name(id='extension_index', ctx=Load())), ctx=Load())))], decorator_list=[]), FunctionDef(name='sub_suffix_in_str', args=arguments(posonlyargs=[], args=[arg(arg='file_str'), arg(arg='suffix_sub'), arg(arg='delimiter')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='_')]), body=[Expr(value=Constant(value='\n    Replaces the existing suffix in a file string with a new suffix.\n\n    :param file_str: string of the file name from which to replace the suffix.\n    :param suffix_sub: string of the new suffix to replace the existing one.\n    :param delimiter: string representing the delimiter used to separate the suffix from the rest of the file string. Default is "_".\n    :return: string of the file name with the replaced suffix or the original file string if no valid suffix is found.\n    ')), Assign(targets=[Name(id='existing_suffix', ctx=Store())], value=Call(func=Name(id='get_suffix', ctx=Load()), args=[Name(id='file_str', ctx=Load()), Name(id='delimiter', ctx=Load())], keywords=[])), Assign(targets=[Name(id='extension_index', ctx=Store())], value=Call(func=Attribute(value=Name(id='file_str', ctx=Load()), attr='rfind', ctx=Load()), args=[Constant(value='.')], keywords=[])), If(test=Compare(left=Name(id='existing_suffix', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='suffix_start_index', ctx=Store())], value=Call(func=Attribute(value=Name(id='file_str', ctx=Load()), attr='rfind', ctx=Load()), args=[Name(id='existing_suffix', ctx=Load())], keywords=[])), Return(value=BinOp(left=BinOp(left=Subscript(value=Name(id='file_str', ctx=Load()), slice=Slice(upper=Name(id='suffix_start_index', ctx=Load())), ctx=Load()), op=Add(), right=Name(id='suffix_sub', ctx=Load())), op=Add(), right=Subscript(value=Name(id='file_str', ctx=Load()), slice=Slice(lower=Name(id='extension_index', ctx=Load())), ctx=Load())))], orelse=[If(test=Compare(left=Name(id='extension_index', ctx=Load()), ops=[NotEq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=[Return(value=BinOp(left=BinOp(left=Subscript(value=Name(id='file_str', ctx=Load()), slice=Slice(upper=Name(id='extension_index', ctx=Load())), ctx=Load()), op=Add(), right=Name(id='suffix_sub', ctx=Load())), op=Add(), right=Subscript(value=Name(id='file_str', ctx=Load()), slice=Slice(lower=Name(id='extension_index', ctx=Load())), ctx=Load())))], orelse=[Return(value=BinOp(left=Name(id='file_str', ctx=Load()), op=Add(), right=Name(id='suffix_sub', ctx=Load())))])])], decorator_list=[]), FunctionDef(name='remove_all_suffixes_in_str', args=arguments(posonlyargs=[], args=[arg(arg='file_str'), arg(arg='delimiter')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='_')]), body=[Expr(value=Constant(value='\n    Removes all suffixes from a given file string based on a specified delimiter while retaining the original file extension.\n\n    :param file_str: string of the file name from which to remove all suffixes.\n    :param delimiter: string representing the delimiter used to separate the suffixes from the rest of the file string. Default is "_".\n    :return: string of the file name with all suffixes removed but with the original extension preserved.\n    ')), Assign(targets=[Name(id='extension_index', ctx=Store())], value=Call(func=Attribute(value=Name(id='file_str', ctx=Load()), attr='rfind', ctx=Load()), args=[Constant(value='.')], keywords=[])), Assign(targets=[Name(id='extension', ctx=Store())], value=IfExp(test=Compare(left=Name(id='extension_index', ctx=Load()), ops=[NotEq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=Subscript(value=Name(id='file_str', ctx=Load()), slice=Slice(lower=Name(id='extension_index', ctx=Load())), ctx=Load()), orelse=Constant(value=''))), Assign(targets=[Name(id='file_str_without_extension', ctx=Store())], value=IfExp(test=Compare(left=Name(id='extension_index', ctx=Load()), ops=[NotEq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=Subscript(value=Name(id='file_str', ctx=Load()), slice=Slice(upper=Name(id='extension_index', ctx=Load())), ctx=Load()), orelse=Name(id='file_str', ctx=Load()))), While(test=Constant(value=True), body=[Assign(targets=[Name(id='current_suffix', ctx=Store())], value=Call(func=Name(id='get_suffix', ctx=Load()), args=[Name(id='file_str_without_extension', ctx=Load()), Name(id='delimiter', ctx=Load())], keywords=[])), If(test=Name(id='current_suffix', ctx=Load()), body=[Assign(targets=[Name(id='suffix_index', ctx=Store())], value=Call(func=Attribute(value=Name(id='file_str_without_extension', ctx=Load()), attr='rfind', ctx=Load()), args=[Name(id='current_suffix', ctx=Load())], keywords=[])), Assign(targets=[Name(id='file_str_without_extension', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='file_str_without_extension', ctx=Load()), slice=Slice(upper=Name(id='suffix_index', ctx=Load())), ctx=Load()), attr='rstrip', ctx=Load()), args=[Name(id='delimiter', ctx=Load())], keywords=[]))], orelse=[Break()])], orelse=[]), Return(value=BinOp(left=Name(id='file_str_without_extension', ctx=Load()), op=Add(), right=Name(id='extension', ctx=Load())))], decorator_list=[]), FunctionDef(name='copy_file_and_append_suffix', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='suffix_new')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Copies the file with a new suffix added before the file extension.\n\n    :param file_path: string of the path to the original file.\n    :param suffix_new: string of the suffix to be appended to the original filename before the file extension.\n    :return: string of the path to the newly created file with the new suffix.\n    ')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='The file path does not exist or is invalid for '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value='.')])], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='file_dir', ctx=Store()), Name(id='file_base', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='file_name', ctx=Store()), Name(id='file_ext', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Name(id='file_base', ctx=Load())], keywords=[])), Assign(targets=[Name(id='new_file_base', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='file_name', ctx=Load()), conversion=-1), FormattedValue(value=Name(id='suffix_new', ctx=Load()), conversion=-1), FormattedValue(value=Name(id='file_ext', ctx=Load()), conversion=-1)])), Assign(targets=[Name(id='new_file_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='file_dir', ctx=Load()), Name(id='new_file_base', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='shutil', ctx=Load()), attr='copy', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='new_file_path', ctx=Load())], keywords=[])), Return(value=Name(id='new_file_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='sub_suffix_in_file', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='suffix_new')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Substitutes the suffix in the file name of the given file path with a new suffix.\n    If new_suffix is empty '' then it will remove the last suffix of the file.\n\n    :param file_path: string, the path to the original file.\n    :param suffix_new: string, the new suffix to replace the existing one in the file name.\n    :return: string, the path to the newly created file with the substituted suffix.\n    ")), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='The file path does not exist or is invalid for '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value='.')])], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='file_dir', ctx=Store()), Name(id='file_base', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='file_name', ctx=Store()), Name(id='file_ext', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Name(id='file_base', ctx=Load())], keywords=[])), Assign(targets=[Name(id='new_file_base', ctx=Store())], value=Call(func=Name(id='sub_suffix_in_str', ctx=Load()), args=[BinOp(left=Name(id='file_name', ctx=Load()), op=Add(), right=Name(id='file_ext', ctx=Load())), Name(id='suffix_new', ctx=Load())], keywords=[])), Assign(targets=[Name(id='new_file_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='file_dir', ctx=Load()), Name(id='new_file_base', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='rename', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='new_file_path', ctx=Load())], keywords=[])), Return(value=Name(id='new_file_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='count_suffixes_in_folder', args=arguments(posonlyargs=[], args=[arg(arg='folder_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Analyzes all the files in the specified folder and prints the number of files for each unique suffix, alphabetized.\n\n    :param folder_path: string of the folder path to search for files and analyze suffixes.\n    :return: None. The function prints the suffixes and their counts.\n    ')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isdir', ctx=Load()), args=[Name(id='folder_path', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='The directory does not exist: '), FormattedValue(value=Name(id='folder_path', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='suffix_counts', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='file_name', ctx=Store()), iter=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='listdir', ctx=Load()), args=[Name(id='folder_path', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='file_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='folder_path', ctx=Load()), Name(id='file_name', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='suffix', ctx=Store())], value=Call(func=Name(id='get_suffix', ctx=Load()), args=[Name(id='file_name', ctx=Load())], keywords=[])), If(test=Name(id='suffix', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='suffix_counts', ctx=Load()), slice=Name(id='suffix', ctx=Load()), ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='suffix_counts', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='suffix', ctx=Load()), Constant(value=0)], keywords=[]), op=Add(), right=Constant(value=1)))], orelse=[])], orelse=[])], orelse=[]), For(target=Name(id='suffix', ctx=Store()), iter=Call(func=Name(id='sorted', ctx=Load()), args=[Name(id='suffix_counts', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='SUFFIX COUNT for '), FormattedValue(value=Name(id='suffix', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Subscript(value=Name(id='suffix_counts', ctx=Load()), slice=Name(id='suffix', ctx=Load()), ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='get_files_in_folder', args=arguments(posonlyargs=[], args=[arg(arg='folder_path'), arg(arg='suffixpat_include'), arg(arg='suffixpat_exclude'), arg(arg='include_subfolders')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value='\n    Retrieves a list of file paths from the specified folder, sorted in alphabetical order.\n    Optionally filters by suffix pattern and includes subfolders.\n\n    :param folder_path: string of the path to the folder from which to retrieve files.\n    :param suffixpat_include: string of the suffix pattern that included files must have.\n    :param suffixpat_exclude: string of the suffix pattern that files must not have to be included.\n    :param include_subfolders: boolean indicating whether to include files from subfolders.\n    :return: list of strings of the file paths that meet the specified criteria.\n    ')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isdir', ctx=Load()), args=[Name(id='folder_path', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='VALUE ERROR in get_files_in_folder: folder does not exist.')])], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='suffixpat_include', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='suffixpat_exclude', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Both suffixpat_include and suffixpat_exclude are provided.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='all_file_paths', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Name(id='include_subfolders', ctx=Load()), body=[For(target=Tuple(elts=[Name(id='root', ctx=Store()), Name(id='dirs', ctx=Store()), Name(id='files', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='walk', ctx=Load()), args=[Name(id='folder_path', ctx=Load())], keywords=[]), body=[For(target=Name(id='file', ctx=Store()), iter=Name(id='files', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='all_file_paths', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='root', ctx=Load()), Name(id='file', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], orelse=[])], orelse=[Assign(targets=[Name(id='all_file_paths', ctx=Store())], value=Call(func=Attribute(value=Name(id='glob', ctx=Load()), attr='glob', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='folder_path', ctx=Load()), Constant(value='*')], keywords=[])], keywords=[]))]), Assign(targets=[Name(id='filtered_file_paths', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='file_path', ctx=Store()), iter=Name(id='all_file_paths', ctx=Load()), body=[If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[]), body=[If(test=Name(id='suffixpat_include', ctx=Load()), body=[If(test=Compare(left=Constant(value='.'), ops=[In()], comparators=[Name(id='suffixpat_include', ctx=Load())]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='file_path', ctx=Load()), attr='endswith', ctx=Load()), args=[Name(id='suffixpat_include', ctx=Load())], keywords=[])), body=[Continue()], orelse=[])], orelse=[Assign(targets=[Name(id='file_suffix', ctx=Store())], value=Call(func=Name(id='get_suffix', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='file_suffix', ctx=Load()), ops=[NotEq()], comparators=[Name(id='suffixpat_include', ctx=Load())]), body=[Continue()], orelse=[])])], orelse=[]), If(test=Name(id='suffixpat_exclude', ctx=Load()), body=[If(test=Compare(left=Constant(value='.'), ops=[In()], comparators=[Name(id='suffixpat_exclude', ctx=Load())]), body=[If(test=Call(func=Attribute(value=Name(id='file_path', ctx=Load()), attr='endswith', ctx=Load()), args=[Name(id='suffixpat_exclude', ctx=Load())], keywords=[]), body=[Continue()], orelse=[])], orelse=[Assign(targets=[Name(id='file_suffix', ctx=Store())], value=Call(func=Name(id='get_suffix', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='file_suffix', ctx=Load()), ops=[Eq()], comparators=[Name(id='suffixpat_exclude', ctx=Load())]), body=[Continue()], orelse=[])])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='filtered_file_paths', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='filtered_file_paths', ctx=Load()), attr='sort', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='filtered_file_paths', ctx=Load()))], decorator_list=[]), FunctionDef(name='apply_to_folder', args=arguments(posonlyargs=[], args=[arg(arg='worker_function'), arg(arg='folder_path')], vararg=arg(arg='args'), kwonlyargs=[arg(arg='suffixpat_include'), arg(arg='suffixpat_exclude'), arg(arg='include_subfolders'), arg(arg='verbose')], kw_defaults=[Constant(value=None), Constant(value=None), Constant(value=False), Constant(value=False)], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value="\n    Controller function that applies a specified worker function to each file in a folder.\n    The worker function must operate on a single file.\n    If it needs the folder name, that can be extracted from the file path.\n    If it's creating or writing to another file, that filename or path can be given as another argument.\n\n    :param worker_function: worker function name to apply to each file, not a string so do not use quotes.\n    :param folder_path: string of the path to the folder from which to retrieve files.\n    :param args: additional arguments to pass to the function.\n    :param suffixpat_include: string of the suffix pattern that included files must have.\n    :param suffixpat_exclude: string of the suffix pattern that files must not have to be included.\n    :param include_subfolders: boolean of whether to include files from subfolders.\n    :param verbose: boolean for printing verbose messages. Defaults to True.\n    :param kwargs: additional keyword arguments to pass to the function.\n    :return: a dictionary with file paths as keys and function return values as values.\n    ")), Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='\nRUNNING apply_to_folder with '), FormattedValue(value=Name(id='worker_function', ctx=Load()), conversion=-1)]), JoinedStr(values=[Constant(value='FOLDER: '), FormattedValue(value=Name(id='folder_path', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='file_paths', ctx=Store())], value=Call(func=Name(id='get_files_in_folder', ctx=Load()), args=[Name(id='folder_path', ctx=Load())], keywords=[keyword(arg='suffixpat_include', value=Name(id='suffixpat_include', ctx=Load())), keyword(arg='suffixpat_exclude', value=Name(id='suffixpat_exclude', ctx=Load())), keyword(arg='include_subfolders', value=Name(id='include_subfolders', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='file_paths', ctx=Load()), attr='sort', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='NUMBER OF FILES RUN with apply_to_folder: '), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='file_paths', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='results', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='file_path', ctx=Store()), iter=Name(id='file_paths', ctx=Load()), body=[Try(body=[Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='worker_function', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(arg='verbose', value=Name(id='verbose', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='TypeError', ctx=Load()), body=[Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='worker_function', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))])], orelse=[], finalbody=[]), Assign(targets=[Subscript(value=Name(id='results', ctx=Load()), slice=Name(id='file_path', ctx=Load()), ctx=Store())], value=Name(id='result', ctx=Load()))], orelse=[]), Return(value=Name(id='results', ctx=Load()))], decorator_list=[]), FunctionDef(name='read_complete_text', args=arguments(posonlyargs=[], args=[arg(arg='file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Reads the entire text from a file.\n\n    :param file_path: string of the file path which can be absolute or relative.\n    :return: string of the complete text read from the file.\n    ')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='The file path does not exist or is invalid for '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value='.')])], keywords=[]))], orelse=[]), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='complete_text', ctx=Store())], value=Call(func=Attribute(value=Name(id='file', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))]), Return(value=Name(id='complete_text', ctx=Load()))], decorator_list=[]), FunctionDef(name='read_metadata_and_content', args=arguments(posonlyargs=[], args=[arg(arg='file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Reads the text from a file and splits it into the metadata and content sections.\n    Gives a ValueError if both metadata and content are not present in one of the 2 formats.\n    Format 1: ## metadata and ## content\n    Format 2: METADATA and CONTENT\n    Strips all leading and trailing newlines from the metadata string.\n    The content string starts with the content delimiter.\n\n    :param file_path: string of the file path which can be absolute or relative.\n    :return: tuple, the metadata and content as two separate strings.\n    ')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='The file path does not exist or is invalid for '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value='.')])], keywords=[]))], orelse=[]), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='complete_text', ctx=Store())], value=Call(func=Attribute(value=Name(id='file', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))]), Assign(targets=[Name(id='metadata_start', ctx=Store())], value=Call(func=Attribute(value=Name(id='complete_text', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value='## metadata')], keywords=[])), Assign(targets=[Name(id='content_start', ctx=Store())], value=Call(func=Attribute(value=Name(id='complete_text', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value='## content')], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='metadata_start', ctx=Load()), ops=[NotEq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), Compare(left=Name(id='content_start', ctx=Load()), ops=[NotEq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))])]), body=[Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='complete_text', ctx=Load()), slice=Slice(lower=Name(id='metadata_start', ctx=Load()), upper=Name(id='content_start', ctx=Load())), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='content', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='complete_text', ctx=Load()), slice=Slice(lower=Name(id='content_start', ctx=Load())), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='metadata_start', ctx=Store())], value=Call(func=Attribute(value=Name(id='complete_text', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value='METADATA')], keywords=[])), Assign(targets=[Name(id='content_start', ctx=Store())], value=Call(func=Attribute(value=Name(id='complete_text', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value='CONTENT')], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='metadata_start', ctx=Load()), ops=[NotEq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), Compare(left=Name(id='content_start', ctx=Load()), ops=[NotEq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))])]), body=[Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='complete_text', ctx=Load()), slice=Slice(lower=BinOp(left=Name(id='metadata_start', ctx=Load()), op=Add(), right=Call(func=Name(id='len', ctx=Load()), args=[Constant(value='METADATA')], keywords=[])), upper=Name(id='content_start', ctx=Load())), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='content', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='complete_text', ctx=Load()), slice=Slice(lower=Name(id='content_start', ctx=Load())), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='File does not contain both metadata and content sections in the required format.\n'), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1)])], keywords=[]))])]), Return(value=Tuple(elts=[Call(func=Attribute(value=Name(id='metadata', ctx=Load()), attr='rstrip', ctx=Load()), args=[Constant(value='\n')], keywords=[]), Name(id='content', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='read_file_flex', args=arguments(posonlyargs=[], args=[arg(arg='file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Reads the text from a file and splits it into the metadata and content sections if present.\n    If no metadata is found, returns (None, complete_text).\n\n    :param file_path: string of the file path which can be absolute or relative.\n    :return: tuple, the metadata and content as two separate strings. If no metadata, returns (None, complete_text).\n    ')), Assign(targets=[Name(id='complete_text', ctx=Store())], value=Call(func=Name(id='read_complete_text', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Try(body=[Assign(targets=[Tuple(elts=[Name(id='metadata', ctx=Store()), Name(id='content', ctx=Store())], ctx=Store())], value=Call(func=Name(id='read_metadata_and_content', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='metadata', ctx=Load()), Name(id='content', ctx=Load())], ctx=Load()))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Return(value=Tuple(elts=[Constant(value=None), Call(func=Attribute(value=Name(id='complete_text', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])], ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), Expr(value=Constant(value=' Overwrite Logic Table:\nOverwrite   Prompt\nArgument    Response    Output Files\t    Case Description\nno          NA\t        _orig + _orig_new\tKeep both\nno-sub\t    NA\t        _orig + _new\t    Keep both and substitute suffix in new file\nreplace\t    NA\t        _orig_new\t        Replace orig file\nreplace-sub\tNA\t        _new\t            Replace orig file with new and substitute suffix in new file\nyes\t        NA\t        _orig\t            Overwrite without prompt\nprompt      y/yes       _orig\t            Prompt=Y to overwrite\nprompt      n/no        _orig + _orig_new\tPrompt= N to keep both\nprompt\t    s/sub\t    _orig + _new\t    Prompt=S to keep both and substitute suffix in new file\nprompt\t    x/anyother  re-prompt\nx/anyother  ValueError\n')), FunctionDef(name='handle_overwrite_prompt', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='file_path_opfunc'), arg(arg='verbose')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='\n    Handles user prompt for overwriting a file.\n\n    :param file_path: string of the original file path.\n    :param file_path_opfunc: string of the new file path.\n    :param verbose: boolean for whether to print verbose messages. Default is True.\n    :return: string of the path to the file that was kept.\n    ')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='The file path does not exist or is invalid for '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value='.')])], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='file_path_opfunc', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='The file path does not exist or is invalid for '), FormattedValue(value=Name(id='file_path_opfunc', ctx=Load()), conversion=-1), Constant(value='.')])], keywords=[]))], orelse=[]), While(test=Constant(value=True), body=[Assign(targets=[Name(id='user_input', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='input', ctx=Load()), args=[JoinedStr(values=[Constant(value='Do you want to overwrite? [Y/yes, N/no, S/sub (substitute suffix)]: ')])], keywords=[]), attr='strip', ctx=Load()), args=[], keywords=[]), attr='lower', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Attribute(value=Name(id='user_input', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='y')], keywords=[]), body=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), Constant(value='File operation with overwrite=prompt+yes - overwrite original file.')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='rename', ctx=Load()), args=[Name(id='file_path_opfunc', ctx=Load()), Name(id='file_path', ctx=Load())], keywords=[])), Return(value=Name(id='file_path', ctx=Load()))], orelse=[If(test=Call(func=Attribute(value=Name(id='user_input', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='n')], keywords=[]), body=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='File operation with overwrite=prompt+no - keep original file and new file.')])], keywords=[])), Return(value=Name(id='file_path_opfunc', ctx=Load()))], orelse=[If(test=Call(func=Attribute(value=Name(id='user_input', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='s')], keywords=[]), body=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='File operation with overwrite=prompt+sub - keep original file and new file with substituted suffix.')])], keywords=[])), Assign(targets=[Name(id='file_path_sub', ctx=Store())], value=Call(func=Name(id='sub_suffix_in_str', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Call(func=Name(id='get_suffix', ctx=Load()), args=[Name(id='file_path_opfunc', ctx=Load()), Constant(value='_')], keywords=[])], keywords=[keyword(arg='delimiter', value=Constant(value='_'))])), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='rename', ctx=Load()), args=[Name(id='file_path_opfunc', ctx=Load()), Name(id='file_path_sub', ctx=Load())], keywords=[])), Return(value=Name(id='file_path_sub', ctx=Load()))], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value="Invalid input. Please enter 'Y' for yes, 'N' for no, or 'S' to substitute suffix.")], keywords=[]))])])])], orelse=[])], decorator_list=[]), FunctionDef(name='manage_file_overwrite', args=arguments(posonlyargs=[], args=[arg(arg='original_path'), arg(arg='suffix_new'), arg(arg='overwrite'), arg(arg='verbose')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value="\n    Handle file overwriting based on the specified mode.\n    \n    :param original_path: string, the path to the original file.\n    :param suffix_new: string, the suffix to be appended to the original filename for the new file.\n    :param overwrite: string, the overwrite mode ('no', 'no-sub', 'replace', 'replace-sub', 'yes', 'prompt').\n    :param verbose: boolean, whether to print verbose messages.\n    :return: string, the final path of the file after applying overwrite logic.\n    ")), Assign(targets=[Name(id='new_path', ctx=Store())], value=Call(func=Name(id='add_suffix_in_str', ctx=Load()), args=[Name(id='original_path', ctx=Load()), Name(id='suffix_new', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='overwrite', ctx=Load()), ops=[Eq()], comparators=[Constant(value='no')]), body=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value="manage_file_overwrite in mode: '"), FormattedValue(value=Name(id='overwrite', ctx=Load()), conversion=-1), Constant(value="' - Keeping both original and new files.")])], keywords=[])), Return(value=Name(id='new_path', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='overwrite', ctx=Load()), ops=[Eq()], comparators=[Constant(value='no-sub')]), body=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value="manage_file_overwrite in mode: '"), FormattedValue(value=Name(id='overwrite', ctx=Load()), conversion=-1), Constant(value="' - Keeping both files and substituting suffix in new file.")])], keywords=[])), Assign(targets=[Name(id='final_path', ctx=Store())], value=Call(func=Name(id='sub_suffix_in_str', ctx=Load()), args=[Name(id='original_path', ctx=Load()), Name(id='suffix_new', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='rename', ctx=Load()), args=[Name(id='new_path', ctx=Load()), Name(id='final_path', ctx=Load())], keywords=[])), Return(value=Name(id='final_path', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='overwrite', ctx=Load()), ops=[Eq()], comparators=[Constant(value='replace')]), body=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value="manage_file_overwrite in mode: '"), FormattedValue(value=Name(id='overwrite', ctx=Load()), conversion=-1), Constant(value="' - Replacing original file with new file.")])], keywords=[])), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='original_path', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='original_path', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='rename', ctx=Load()), args=[Name(id='new_path', ctx=Load()), Name(id='original_path', ctx=Load())], keywords=[])), Return(value=Name(id='original_path', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='overwrite', ctx=Load()), ops=[Eq()], comparators=[Constant(value='replace-sub')]), body=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value="manage_file_overwrite in mode: '"), FormattedValue(value=Name(id='overwrite', ctx=Load()), conversion=-1), Constant(value="' - Replacing original file with new file and substituting suffix.")])], keywords=[])), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='original_path', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='original_path', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='final_path', ctx=Store())], value=Call(func=Name(id='sub_suffix_in_str', ctx=Load()), args=[Name(id='original_path', ctx=Load()), Name(id='suffix_new', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='rename', ctx=Load()), args=[Name(id='new_path', ctx=Load()), Name(id='final_path', ctx=Load())], keywords=[])), Return(value=Name(id='final_path', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='overwrite', ctx=Load()), ops=[Eq()], comparators=[Constant(value='yes')]), body=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value="manage_file_overwrite in mode: '"), FormattedValue(value=Name(id='overwrite', ctx=Load()), conversion=-1), Constant(value="' - Overwriting original file.")])], keywords=[])), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='original_path', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='original_path', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='rename', ctx=Load()), args=[Name(id='new_path', ctx=Load()), Name(id='original_path', ctx=Load())], keywords=[])), Return(value=Name(id='original_path', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='overwrite', ctx=Load()), ops=[Eq()], comparators=[Constant(value='prompt')]), body=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value="manage_file_overwrite in mode: '"), FormattedValue(value=Name(id='overwrite', ctx=Load()), conversion=-1), Constant(value="' - Prompting user.")])], keywords=[])), Return(value=Call(func=Name(id='handle_overwrite_prompt', ctx=Load()), args=[Name(id='original_path', ctx=Load()), Name(id='new_path', ctx=Load()), Name(id='verbose', ctx=Load())], keywords=[]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Invalid overwrite mode: '), FormattedValue(value=Name(id='overwrite', ctx=Load()), conversion=-1)])], keywords=[]))])])])])])])], decorator_list=[]), FunctionDef(name='write_complete_text', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='complete_text'), arg(arg='suffix_new'), arg(arg='overwrite'), arg(arg='verbose')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='_temp'), Constant(value='no'), Constant(value=False)]), body=[Expr(value=Constant(value='\n    Writes the complete text to a new file with a specified suffix and handles overwrite logic.\n\n    :param file_path: string, the path to the original file.\n    :param complete_text: string, the complete text to be written to the new file.\n    :param suffix_new: string, the suffix to be appended to the original filename for the new file.\n    :param overwrite: string, the overwrite mode. Default is "no".\n    :param verbose: boolean, whether to print verbose messages. Default is False.\n    :return: string, the path to the final file after applying overwrite logic.\n    ')), Assign(targets=[Name(id='new_file_path', ctx=Store())], value=Call(func=Name(id='add_suffix_in_str', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='suffix_new', ctx=Load())], keywords=[])), If(test=Name(id='verbose', ctx=Load()), body=[If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='new_file_path', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='BEFORE OVERWRITE write_complete_text new_file_path does exist.')])], keywords=[])), Expr(value=Call(func=Name(id='warn_file_overwrite', ctx=Load()), args=[Name(id='new_file_path', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='BEFORE OVERWRITE write_complete_text new_file_path does NOT exist (note this file may be an intermediate file that is deleted or renamed by manage_file_overwrite).')])], keywords=[]))])], orelse=[]), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='new_file_path', ctx=Load()), Constant(value='w')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Expr(value=Call(func=Attribute(value=Name(id='file', ctx=Load()), attr='write', ctx=Load()), args=[Name(id='complete_text', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='final_file_path', ctx=Store())], value=Call(func=Name(id='manage_file_overwrite', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='suffix_new', ctx=Load()), Name(id='overwrite', ctx=Load()), Name(id='verbose', ctx=Load())], keywords=[])), Return(value=Name(id='final_file_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='write_metadata_and_content', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='metadata'), arg(arg='content'), arg(arg='suffix_new'), arg(arg='overwrite'), arg(arg='verbose')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='_temp'), Constant(value='no'), Constant(value=False)]), body=[Expr(value=Constant(value='\n    Writes the metadata and content text to a new file with a specified suffix and handles overwrite logic.\n    Insert 2 blank lines between the metadata and content sections if metadata is present or empty string.\n\n    :param file_path: string, the path to the original file.\n    :param metadata: string or None, the metadata section to be written to the new file, inclusive of \'## metadata\' or \'METADATA\'.\n    :param content: string, the content section to be written to the new file, inclusive of \'## content\' or \'CONTENT\'.\n    :param suffix_new: string, the suffix to be appended to the original filename for the new file.\n    :param overwrite: string, the overwrite mode. Default is "no".\n    :param verbose: boolean, whether to print verbose messages. Default is False.\n    :return: string, the path to the final file after applying overwrite logic.\n    ')), If(test=Compare(left=Name(id='metadata', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='complete_text', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='metadata', ctx=Load()), attr='rstrip', ctx=Load()), args=[Constant(value='\n')], keywords=[]), op=Add(), right=Constant(value='\n\n\n')), op=Add(), right=Call(func=Attribute(value=Name(id='content', ctx=Load()), attr='rstrip', ctx=Load()), args=[Constant(value='\n')], keywords=[])), op=Add(), right=Constant(value='\n')))], orelse=[Assign(targets=[Name(id='complete_text', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='content', ctx=Load()), attr='rstrip', ctx=Load()), args=[Constant(value='\n')], keywords=[]), op=Add(), right=Constant(value='\n')))]), Return(value=Call(func=Name(id='write_complete_text', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='complete_text', ctx=Load()), Name(id='suffix_new', ctx=Load()), Name(id='overwrite', ctx=Load()), Name(id='verbose', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='pretty_print_json_structure', args=arguments(posonlyargs=[], args=[arg(arg='json_file_path'), arg(arg='level_limit'), arg(arg='save_to_file')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value="\n    Prints the structure of a JSON file and optionally saves it to a file with a '.pretty' extension.\n\n    :param json_file_path: string of the path to the json file.\n    :param level_limit: integer of the maximum level of nesting to print. None means no limit.\n    :param save_to_file: boolean indicating whether to save the output to a file. defaults to true.\n    :return: None.\n    ")), Assign(targets=[Name(id='colors', ctx=Store())], value=List(elts=[Constant(value='green'), Constant(value='blue'), Constant(value='red'), Constant(value='magenta'), Constant(value='yellow'), Constant(value='white'), Constant(value='grey')], ctx=Load())), Assign(targets=[Name(id='output_lines', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='json_file_path', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value='File '), FormattedValue(value=Name(id='json_file_path', ctx=Load()), conversion=-1), Constant(value=' does not exist.')])], keywords=[])), Return()], orelse=[]), FunctionDef(name='print_json_structure', args=arguments(posonlyargs=[], args=[arg(arg='data'), arg(arg='indent'), arg(arg='parent_key'), arg(arg='level')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0), Constant(value=''), Constant(value=0)]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='level_limit', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='level', ctx=Load()), ops=[Gt()], comparators=[Name(id='level_limit', ctx=Load())])]), body=[Return()], orelse=[]), Assign(targets=[Name(id='color', ctx=Store())], value=Subscript(value=Name(id='colors', ctx=Load()), slice=BinOp(left=Name(id='level', ctx=Load()), op=Mod(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='colors', ctx=Load())], keywords=[])), ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[For(target=Name(id='key', ctx=Store()), iter=Name(id='data', ctx=Load()), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Subscript(value=Name(id='data', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='line', ctx=Store())], value=BinOp(left=BinOp(left=Constant(value=' '), op=Mult(), right=Name(id='indent', ctx=Load())), op=Add(), right=JoinedStr(values=[FormattedValue(value=Name(id='key', ctx=Load()), conversion=-1), Constant(value=' (list of '), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='data', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load())], keywords=[]), conversion=-1), Constant(value=' items)')]))), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Name(id='colored', ctx=Load()), args=[Name(id='line', ctx=Load()), Name(id='color', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='output_lines', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])), If(test=Subscript(value=Name(id='data', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load()), body=[Expr(value=Call(func=Name(id='print_json_structure', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id='data', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load()), slice=Constant(value=0), ctx=Load()), BinOp(left=Name(id='indent', ctx=Load()), op=Add(), right=Constant(value=4)), Name(id='key', ctx=Load()), BinOp(left=Name(id='level', ctx=Load()), op=Add(), right=Constant(value=1))], keywords=[]))], orelse=[])], orelse=[Assign(targets=[Name(id='line', ctx=Store())], value=BinOp(left=BinOp(left=Constant(value=' '), op=Mult(), right=Name(id='indent', ctx=Load())), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='key', ctx=Load())], keywords=[]))), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Name(id='colored', ctx=Load()), args=[Name(id='line', ctx=Load()), Name(id='color', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='output_lines', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print_json_structure', ctx=Load()), args=[Subscript(value=Name(id='data', ctx=Load()), slice=Name(id='key', ctx=Load()), ctx=Load()), BinOp(left=Name(id='indent', ctx=Load()), op=Add(), right=Constant(value=4)), Name(id='key', ctx=Load()), BinOp(left=Name(id='level', ctx=Load()), op=Add(), right=Constant(value=1))], keywords=[]))])], orelse=[])], orelse=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), Compare(left=Name(id='parent_key', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='')])]), body=[If(test=Name(id='data', ctx=Load()), body=[Expr(value=Call(func=Name(id='print_json_structure', ctx=Load()), args=[Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value=0), ctx=Load()), Name(id='indent', ctx=Load()), Name(id='parent_key', ctx=Load()), Name(id='level', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])])], decorator_list=[]), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='json_file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='data', ctx=Store())], value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='load', ctx=Load()), args=[Name(id='file', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print_json_structure', ctx=Load()), args=[Name(id='data', ctx=Load())], keywords=[]))]), If(test=Name(id='save_to_file', ctx=Load()), body=[Assign(targets=[Name(id='output_file_path', ctx=Store())], value=BinOp(left=Name(id='json_file_path', ctx=Load()), op=Add(), right=Constant(value='.pretty'))), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='output_file_path', ctx=Load()), Constant(value='w')], keywords=[]), optional_vars=Name(id='output_file', ctx=Store()))], body=[For(target=Name(id='line', ctx=Store()), iter=Name(id='output_lines', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='output_file', ctx=Load()), attr='write', ctx=Load()), args=[BinOp(left=Name(id='line', ctx=Load()), op=Add(), right=Constant(value='\n'))], keywords=[]))], orelse=[])]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Saved pretty printed JSON structure to '), FormattedValue(value=Name(id='output_file_path', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='write_json_file_from_object', args=arguments(posonlyargs=[], args=[arg(arg='json_object'), arg(arg='file_path'), arg(arg='overwrite')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='no')]), body=[Expr(value=Constant(value=' \n    Writes a JSON object to a file at the specified path.\n\n    :param json_object: dictionary or list to be written as JSON.\n    :param file_path: string of the path where the JSON file will be written.\n    :param overwrite: string of either "yes" or "no" to determine if existing files should be overwritten. default is "no".\n    :return: None.\n    ')), If(test=Compare(left=Name(id='overwrite', ctx=Load()), ops=[NotIn()], comparators=[List(elts=[Constant(value='yes'), Constant(value='no')], ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value="The 'overwrite' parameter must be 'yes' or 'no'.")], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='overwrite', ctx=Load()), ops=[Eq()], comparators=[Constant(value='no')]), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])]), body=[Raise(exc=Call(func=Name(id='FileExistsError', ctx=Load()), args=[JoinedStr(values=[Constant(value='The file '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value=' already exists and will not be overwritten.')])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='makedirs', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])], keywords=[keyword(arg='exist_ok', value=Constant(value=True))])), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='w')], keywords=[]), optional_vars=Name(id='json_file', ctx=Store()))], body=[Expr(value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='dump', ctx=Load()), args=[Name(id='json_object', ctx=Load()), Name(id='json_file', ctx=Load())], keywords=[keyword(arg='indent', value=Constant(value=4))]))])], decorator_list=[]), FunctionDef(name='read_json_object_from_file', args=arguments(posonlyargs=[], args=[arg(arg='file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=' \n    Reads a JSON object from a file at the specified path.\n\n    :param file_path: string of the path to the JSON file to be read.\n    :return: dictionary or list representing the JSON object read from the file.\n    ')), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='json_file', ctx=Store()))], body=[Assign(targets=[Name(id='json_object', ctx=Store())], value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='load', ctx=Load()), args=[Name(id='json_file', ctx=Load())], keywords=[]))]), Return(value=Name(id='json_object', ctx=Load()))], decorator_list=[]), FunctionDef(name='rename_file', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='new_filebase')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Renames the file base portion for the file given at the argument file path.\n\n    :param file_path: string, the path to the file to be renamed.\n    :param new_filebase: string, the new base name for the file without the extension.\n    :return: string, the new file path after renaming, or an error if the operation fails.\n    ')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='The file path does not exist or is invalid for '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value='.')])], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='file_dir', ctx=Store()), Name(id='file_base', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='file_ext', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Name(id='file_base', ctx=Load())], keywords=[]), slice=Constant(value=1), ctx=Load())), Assign(targets=[Name(id='new_file_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='file_dir', ctx=Load()), BinOp(left=Name(id='new_filebase', ctx=Load()), op=Add(), right=Name(id='file_ext', ctx=Load()))], keywords=[])), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='rename', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='new_file_path', ctx=Load())], keywords=[])), Return(value=Name(id='new_file_path', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='OSError', ctx=Load()), name='e', body=[Return(value=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='rename_file_extension', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='new_extension')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Renames the file extension for the file given at the argument file path.\n\n    :param file_path: string, the path to the file to be renamed.\n    :param new_extension: string, the new extension for the file (including the dot).\n    :return: string, the new file path after renaming, or an error if the operation fails.\n    ')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='The file path does not exist or is invalid for '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value='.')])], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='file_dir', ctx=Store()), Name(id='file_base', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='file_name', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Name(id='file_base', ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='new_file_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='file_dir', ctx=Load()), BinOp(left=Name(id='file_name', ctx=Load()), op=Add(), right=Name(id='new_extension', ctx=Load()))], keywords=[])), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='rename', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='new_file_path', ctx=Load())], keywords=[])), Return(value=Name(id='new_file_path', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='OSError', ctx=Load()), name='e', body=[Return(value=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='delete_file', args=arguments(posonlyargs=[], args=[arg(arg='file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Deletes a file at the specified file path.\n\n    :param file_path: string, the path to the file to be deleted.\n    :return: None. The function does not return any value.\n    ')), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Return(value=Constant(value=True))], handlers=[ExceptHandler(type=Name(id='OSError', ctx=Load()), name='e', body=[Return(value=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='delete_files_with_suffix', args=arguments(posonlyargs=[], args=[arg(arg='folder'), arg(arg='suffixpat_include'), arg(arg='verbose')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='\n    Deletes all files in a given folder that end with a specified suffix.\n\n    :param folder_path: string, the path to the folder where files are to be deleted.\n    :param suffixpat_include: string, the suffix pattern of the files to be deleted.\n    :param verbose: boolean, if True, the function will print verbose messages. Default is False.\n    :return: None. The function does not return any value.\n    ')), Return(value=Call(func=Name(id='apply_to_folder', ctx=Load()), args=[Name(id='delete_file', ctx=Load()), Name(id='folder', ctx=Load())], keywords=[keyword(arg='suffixpat_include', value=Name(id='suffixpat_include', ctx=Load())), keyword(arg='include_subfolders', value=Constant(value=False)), keyword(arg='verbose', value=Name(id='verbose', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='move_file', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='destination_folder')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Moves a file to the specified destination folder.\n\n    :param file_path: string, the path to the file to be moved.\n    :param destination_folder: string, the path to the destination folder.\n    :return: string, the new file path after moving, or an error if the operation fails.\n    ')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='The file path does not exist or is invalid for '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value='.')])], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isdir', ctx=Load()), args=[Name(id='destination_folder', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='makedirs', ctx=Load()), args=[Name(id='destination_folder', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='file_name', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='new_file_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='destination_folder', ctx=Load()), Name(id='file_name', ctx=Load())], keywords=[])), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='shutil', ctx=Load()), attr='move', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='new_file_path', ctx=Load())], keywords=[])), Return(value=Name(id='new_file_path', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='OSError', ctx=Load()), name='e', body=[Return(value=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='move_files_with_suffix', args=arguments(posonlyargs=[], args=[arg(arg='source_folder'), arg(arg='destination_folder'), arg(arg='suffixpat_include'), arg(arg='verbose')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='\n    Moves all files in a given folder that end with a specified suffix to the destination folder.\n\n    :param source_folder: string, the path to the source folder where files are to be moved from.\n    :param destination_folder: string, the path to the destination folder where files are to be moved to.\n    :param suffixpat_include: string, the suffix pattern of the files to be moved.\n    :param verbose: boolean, if True, the function will print verbose messages. Default is False.\n    :return: list, the new file paths after moving, or an error if the operation fails.\n    ')), Return(value=Call(func=Name(id='apply_to_folder', ctx=Load()), args=[Name(id='move_file', ctx=Load()), Name(id='source_folder', ctx=Load()), Name(id='destination_folder', ctx=Load())], keywords=[keyword(arg='suffixpat_include', value=Name(id='suffixpat_include', ctx=Load())), keyword(arg='include_subfolders', value=Constant(value=False)), keyword(arg='verbose', value=Name(id='verbose', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='tune_title', args=arguments(posonlyargs=[], args=[arg(arg='title')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Removes any special characters from the given title.\n\n    :param title: string, the title from which special characters are to be removed.\n    :return: string, the updated title with special characters removed.\n    ')), Return(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[Constant(value='[^\\w\\s\\-\\(\\)\\.]'), Constant(value=''), Name(id='title', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='create_full_path', args=arguments(posonlyargs=[], args=[arg(arg='title_or_path'), arg(arg='new_suffix_ext'), arg(arg='default_folder')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n    Creates a full file path from a given title or path, a new suffix extension, and an optional default folder.\n\n    :param title_or_path: string, the title or path of the file.\n    :param new_suffix_ext: string, the new suffix extension to be added to the file.\n    :param default_folder: string, the default folder to be used if no folder is specified in title_or_path. Default is None.\n    :return: string, the newly created full file path.\n    ')), Assign(targets=[Tuple(elts=[Name(id='file_stem', ctx=Store()), Name(id='file_ext', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='title_or_path', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='folder_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Name(id='title_or_path', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='folder_path', ctx=Load()), ops=[Eq()], comparators=[Constant(value='')]), body=[If(test=Compare(left=Name(id='default_folder', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='folder_path', ctx=Store())], value=Name(id='default_folder', ctx=Load()))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='in create_full_path: no folder in title_or_path and default_folder is None.')], keywords=[]))])], orelse=[]), Assign(targets=[Name(id='file_stem', ctx=Store())], value=Call(func=Name(id='tune_title', ctx=Load()), args=[Name(id='file_stem', ctx=Load())], keywords=[])), Assign(targets=[Name(id='cur_suffix', ctx=Store())], value=Call(func=Name(id='get_suffix', ctx=Load()), args=[Name(id='file_stem', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='cur_suffix', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=BinOp(left=Name(id='cur_suffix', ctx=Load()), op=Add(), right=Name(id='file_ext', ctx=Load())), ops=[Eq()], comparators=[Name(id='new_suffix_ext', ctx=Load())])]), body=[Assign(targets=[Name(id='new_file_base', ctx=Store())], value=BinOp(left=Name(id='file_stem', ctx=Load()), op=Add(), right=Name(id='file_ext', ctx=Load())))], orelse=[Assign(targets=[Name(id='new_file_base', ctx=Store())], value=BinOp(left=Name(id='file_stem', ctx=Load()), op=Add(), right=Name(id='new_suffix_ext', ctx=Load())))]), Assign(targets=[Name(id='new_file_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='folder_path', ctx=Load()), Name(id='new_file_base', ctx=Load())], keywords=[])), Return(value=Name(id='new_file_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='find_file_in_folders', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='folder_paths')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Searches for a file within a list of folder paths and returns the first match.\n\n    :param file_path: string of the file name to search for.\n    :param folder_paths: list of strings of folder paths where the file will be searched.\n    :return: string of the full path to the file if found, otherwise None.\n    ')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), body=[For(target=Name(id='folder', ctx=Store()), iter=Name(id='folder_paths', ctx=Load()), body=[Assign(targets=[Name(id='potential_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='folder', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])], keywords=[])), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='potential_path', ctx=Load())], keywords=[]), body=[Return(value=Name(id='potential_path', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Constant(value=None))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value='file_paths exists at this path - find_file_in_folders erroneously called')])], keywords=[])), Return(value=Name(id='file_path', ctx=Load()))])], decorator_list=[]), FunctionDef(name='zip_files_in_folders', args=arguments(posonlyargs=[], args=[arg(arg='folder_paths'), arg(arg='suffixpat_include'), arg(arg='zip_file_path'), arg(arg='include_subfolders')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='\n    Zips files in the specified folders that match the given suffix into a single zip file.\n\n    :param folder_paths: list of strings, the paths to the folders where files will be zipped.\n    :param suffixpat_include: string, the suffix pattern that included files must have.\n    :param zip_file_path: string, the path where the single zip file will be created.\n    :param include_subfolders: boolean, indicates whether to include files from subfolders.\n    :return: None\n    ')), Import(names=[alias(name='zipfile')]), Import(names=[alias(name='os')]), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='makedirs', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Name(id='zip_file_path', ctx=Load())], keywords=[])], keywords=[keyword(arg='exist_ok', value=Constant(value=True))])), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='zipfile', ctx=Load()), attr='ZipFile', ctx=Load()), args=[Name(id='zip_file_path', ctx=Load()), Constant(value='w')], keywords=[]), optional_vars=Name(id='zipf', ctx=Store()))], body=[For(target=Name(id='folder_path', ctx=Store()), iter=Name(id='folder_paths', ctx=Load()), body=[If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isdir', ctx=Load()), args=[Name(id='folder_path', ctx=Load())], keywords=[]), body=[If(test=Name(id='include_subfolders', ctx=Load()), body=[For(target=Tuple(elts=[Name(id='root', ctx=Store()), Name(id='dirs', ctx=Store()), Name(id='files', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='walk', ctx=Load()), args=[Name(id='folder_path', ctx=Load())], keywords=[]), body=[For(target=Name(id='file', ctx=Store()), iter=Name(id='files', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='file_name', ctx=Store()), Name(id='file_extension', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Name(id='file', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Name(id='file_name', ctx=Load()), attr='endswith', ctx=Load()), args=[Name(id='suffixpat_include', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='file_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='root', ctx=Load()), Name(id='file', ctx=Load())], keywords=[])), Assign(targets=[Name(id='arcname', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='relpath', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[keyword(arg='start', value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Name(id='folder_path', ctx=Load())], keywords=[]))])), Expr(value=Call(func=Attribute(value=Name(id='zipf', ctx=Load()), attr='write', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='arcname', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[])], orelse=[For(target=Name(id='file', ctx=Store()), iter=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='listdir', ctx=Load()), args=[Name(id='folder_path', ctx=Load())], keywords=[]), body=[If(test=BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='file', ctx=Load()), attr='endswith', ctx=Load()), args=[Name(id='suffixpat_include', ctx=Load())], keywords=[]), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='folder_path', ctx=Load()), Name(id='file', ctx=Load())], keywords=[])], keywords=[])]), body=[Assign(targets=[Name(id='file_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='folder_path', ctx=Load()), Name(id='file', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='zipf', ctx=Load()), attr='write', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='file', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])])], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Folder does not exist: '), FormattedValue(value=Name(id='folder_path', ctx=Load()), conversion=-1)])], keywords=[]))])], orelse=[])]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Created zip at '), FormattedValue(value=Name(id='zip_file_path', ctx=Load()), conversion=-1), Constant(value=' containing files from folders: '), FormattedValue(value=Name(id='folder_paths', ctx=Load()), conversion=-1)])], keywords=[]))], decorator_list=[]), FunctionDef(name='compare_files_text', args=arguments(posonlyargs=[], args=[arg(arg='file1_path'), arg(arg='file2_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Compares the content of two files.\n\n    :param file1_path: string, the path to the first file to be compared.\n    :param file2_path: string, the path to the second file to be compared.\n    :return: boolean, True if the content of the files is exactly the same, False otherwise.\n    ')), Assign(targets=[Name(id='text1', ctx=Store())], value=Call(func=Name(id='read_complete_text', ctx=Load()), args=[Name(id='file1_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='text2', ctx=Store())], value=Call(func=Name(id='read_complete_text', ctx=Load()), args=[Name(id='file2_path', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='text1', ctx=Load()), ops=[Eq()], comparators=[Name(id='text2', ctx=Load())]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='TRUE for compare_file_text - the content of the files is exactly the same.')], keywords=[])), Return(value=Constant(value=True))], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='FALSE for compare_file_text - the content of the files is different.')], keywords=[])), Return(value=Constant(value=False))])], decorator_list=[]), FunctionDef(name='get_text_between_delimiters', args=arguments(posonlyargs=[], args=[arg(arg='full_text'), arg(arg='delimiter_start'), arg(arg='delimiter_end')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n    Extracts a substring from the given text between specified start and end delimiters.\n\n    :param full_text: string of the text from which to extract the substring.\n    :param delimiter_start: string of the delimiter indicating the start of the substring.\n    :param delimiter_end: string of the delimiter indicating the end of the substring. If None, the end of the text is used. Default is None.\n    :return: string of the extracted substring (inclusive of delimiter_start), or None if the start delimiter is not found.\n    ')), Assign(targets=[Name(id='start_index', ctx=Store())], value=Call(func=Attribute(value=Name(id='full_text', ctx=Load()), attr='find', ctx=Load()), args=[Name(id='delimiter_start', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='start_index', ctx=Load()), ops=[Eq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value='in get_text_between_delimiters - no text found with delimiter_start: '), FormattedValue(value=Name(id='delimiter_start', ctx=Load()), conversion=-1), Constant(value=' using the function: get_text_between_delimiters')])], keywords=[])), Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='end_index', ctx=Store())], value=IfExp(test=Compare(left=Name(id='delimiter_end', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Call(func=Name(id='len', ctx=Load()), args=[Name(id='full_text', ctx=Load())], keywords=[]), orelse=Call(func=Attribute(value=Name(id='full_text', ctx=Load()), attr='find', ctx=Load()), args=[Name(id='delimiter_end', ctx=Load()), BinOp(left=Name(id='start_index', ctx=Load()), op=Add(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='delimiter_start', ctx=Load())], keywords=[]))], keywords=[]))), If(test=Compare(left=Name(id='end_index', ctx=Load()), ops=[Eq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=[Assign(targets=[Name(id='end_index', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='full_text', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='extracted_text', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Subscript(value=Name(id='full_text', ctx=Load()), slice=Slice(lower=Name(id='start_index', ctx=Load()), upper=Name(id='end_index', ctx=Load())), ctx=Load()), attr='rstrip', ctx=Load()), args=[Constant(value='\n')], keywords=[]), attr='rstrip', ctx=Load()), args=[Constant(value=' \t')], keywords=[])), Return(value=BinOp(left=Name(id='extracted_text', ctx=Load()), op=Add(), right=Constant(value='\n')))], decorator_list=[]), FunctionDef(name='check_if_duplicate_filename', args=arguments(posonlyargs=[], args=[arg(arg='filename'), arg(arg='folder'), arg(arg='exclude_suffix')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='\n    Checks if a filename already exists in a given folder, optionally excluding suffixes.\n\n    :param filename: str, the filename to check for duplicates.\n    :param folder: str, the path to the folder to search in.\n    :param exclude_suffix: bool, whether to exclude suffixes when comparing filenames.\n    :return: bool, True if a duplicate is found, False otherwise.\n    ')), Assign(targets=[Name(id='existing_files', ctx=Store())], value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='listdir', ctx=Load()), args=[Name(id='folder', ctx=Load())], keywords=[])), If(test=Name(id='exclude_suffix', ctx=Load()), body=[Assign(targets=[Name(id='input_name', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Name(id='filename', ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='input_suffix', ctx=Store())], value=Call(func=Name(id='get_suffix', ctx=Load()), args=[Name(id='input_name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='filename_without_suffix', ctx=Store())], value=IfExp(test=Name(id='input_suffix', ctx=Load()), body=Subscript(value=Name(id='input_name', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Call(func=Name(id='len', ctx=Load()), args=[Name(id='input_suffix', ctx=Load())], keywords=[]))), ctx=Load()), orelse=Name(id='input_name', ctx=Load()))), For(target=Name(id='existing_file', ctx=Store()), iter=Name(id='existing_files', ctx=Load()), body=[Assign(targets=[Name(id='existing_name', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Name(id='existing_file', ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='existing_suffix', ctx=Store())], value=Call(func=Name(id='get_suffix', ctx=Load()), args=[Name(id='existing_name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='existing_without_suffix', ctx=Store())], value=IfExp(test=Name(id='existing_suffix', ctx=Load()), body=Subscript(value=Name(id='existing_name', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Call(func=Name(id='len', ctx=Load()), args=[Name(id='existing_suffix', ctx=Load())], keywords=[]))), ctx=Load()), orelse=Name(id='existing_name', ctx=Load()))), If(test=Compare(left=Call(func=Attribute(value=Name(id='filename_without_suffix', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Call(func=Attribute(value=Name(id='existing_without_suffix', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])]), body=[Return(value=Constant(value=True))], orelse=[])], orelse=[]), Return(value=Constant(value=False))], orelse=[Return(value=Compare(left=Call(func=Attribute(value=Name(id='filename', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[In()], comparators=[ListComp(elt=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='f', ctx=Store()), iter=Name(id='existing_files', ctx=Load()), ifs=[], is_async=0)])]))])], decorator_list=[]), FunctionDef(name='convert_seconds_to_timestamp', args=arguments(posonlyargs=[], args=[arg(arg='seconds')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Converts a given number of seconds into a timestamp in the format hh:mm:ss or mm:ss.\n\n    :param seconds: integer or float representing the number of seconds to be converted.\n    :return: string representing the timestamp in the format hh:mm:ss or mm:ss.\n    ')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='seconds', ctx=Load()), Tuple(elts=[Name(id='int', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Input must be an integer or float representing seconds.')], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='seconds', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Input must be a non-negative number of seconds.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='hours', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='seconds', ctx=Load()), op=FloorDiv(), right=Constant(value=3600))], keywords=[])), Assign(targets=[Name(id='minutes', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='seconds', ctx=Load()), op=Mod(), right=Constant(value=3600)), op=FloorDiv(), right=Constant(value=60))], keywords=[])), Assign(targets=[Name(id='seconds', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='seconds', ctx=Load()), op=Mod(), right=Constant(value=60))], keywords=[])), If(test=Compare(left=Name(id='hours', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Return(value=JoinedStr(values=[FormattedValue(value=Name(id='hours', ctx=Load()), conversion=-1), Constant(value=':'), FormattedValue(value=Name(id='minutes', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='02')])), Constant(value=':'), FormattedValue(value=Name(id='seconds', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='02')]))]))], orelse=[If(test=Compare(left=Name(id='minutes', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Return(value=JoinedStr(values=[FormattedValue(value=Name(id='minutes', ctx=Load()), conversion=-1), Constant(value=':'), FormattedValue(value=Name(id='seconds', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='02')]))]))], orelse=[Return(value=JoinedStr(values=[Constant(value='0:'), FormattedValue(value=Name(id='seconds', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='02')]))]))])])], decorator_list=[]), FunctionDef(name='convert_timestamp_to_seconds', args=arguments(posonlyargs=[], args=[arg(arg='timestamp')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Converts a timestamp in the format hh:mm:ss or mm:ss into seconds.\n\n    :param timestamp: string representing the timestamp in the format hh:mm:ss or mm:ss.\n    :return: integer representing the total number of seconds.\n    ')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='timestamp', ctx=Load()), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='Timestamp must be a string in the format hh:mm:ss or mm:ss')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='time_components', ctx=Store())], value=Call(func=Attribute(value=Name(id='timestamp', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=':')], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='component', ctx=Load()), attr='isdigit', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='component', ctx=Store()), iter=Name(id='time_components', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Invalid timestamp: Non-numeric characters found')], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='time_components', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=3)]), body=[Assign(targets=[Tuple(elts=[Name(id='hours', ctx=Store()), Name(id='minutes', ctx=Store()), Name(id='seconds', ctx=Store())], ctx=Store())], value=Call(func=Name(id='map', ctx=Load()), args=[Name(id='int', ctx=Load()), Name(id='time_components', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='time_components', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=2)]), body=[Assign(targets=[Name(id='hours', ctx=Store())], value=Constant(value=0)), Assign(targets=[Tuple(elts=[Name(id='minutes', ctx=Store()), Name(id='seconds', ctx=Store())], ctx=Store())], value=Call(func=Name(id='map', ctx=Load()), args=[Name(id='int', ctx=Load()), Name(id='time_components', ctx=Load())], keywords=[]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Invalid timestamp format. Expected hh:mm:ss or mm:ss')], keywords=[]))])]), If(test=UnaryOp(op=Not(), operand=Compare(left=Constant(value=0), ops=[LtE(), LtE()], comparators=[Name(id='hours', ctx=Load()), Constant(value=99)])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Invalid timestamp: Hours must be in the range 0-99')], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Compare(left=Constant(value=0), ops=[LtE(), LtE()], comparators=[Name(id='minutes', ctx=Load()), Constant(value=59)])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Invalid timestamp: Minutes must be in the range 0-59')], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Compare(left=Constant(value=0), ops=[LtE(), LtE()], comparators=[Name(id='seconds', ctx=Load()), Constant(value=59)])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Invalid timestamp: Seconds must be in the range 0-59')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='total_seconds', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='seconds', ctx=Load()), op=Add(), right=BinOp(left=Name(id='minutes', ctx=Load()), op=Mult(), right=Constant(value=60))), op=Add(), right=BinOp(left=Name(id='hours', ctx=Load()), op=Mult(), right=Constant(value=3600)))), Return(value=Name(id='total_seconds', ctx=Load()))], decorator_list=[]), FunctionDef(name='change_timestamp', args=arguments(posonlyargs=[], args=[arg(arg='timestamp'), arg(arg='delta_seconds')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Changes a given timestamp by a specified number of seconds. Uncomment line in tune_timestamp\n\n    :param timestamp: string representing the timestamp in the format hh:mm:ss or mm:ss.\n    :param delta_seconds: integer representing the number of seconds to change the timestamp by.\n    :return: string representing the new timestamp after the change.\n    ')), If(test=Compare(left=Name(id='timestamp', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='No timestamp provided. Cannot change timestamp.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='modified_seconds', ctx=Store())], value=BinOp(left=Call(func=Name(id='convert_timestamp_to_seconds', ctx=Load()), args=[Name(id='timestamp', ctx=Load())], keywords=[]), op=Add(), right=Name(id='delta_seconds', ctx=Load()))), If(test=Compare(left=Name(id='modified_seconds', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Resulting time cannot be less than zero.')], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='convert_seconds_to_timestamp', ctx=Load()), args=[Name(id='modified_seconds', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='tune_timestamp', args=arguments(posonlyargs=[], args=[arg(arg='timestamp')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Converts a given timestamp to a standard format with respect to digits and leading zeros.\n\n    :param timestamp: string representing the timestamp in the format hh:mm:ss or mm:ss.\n    :return: string representing the tuned timestamp or None if the input timestamp is None.\n    ')), If(test=Compare(left=Name(id='timestamp', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='secs', ctx=Store())], value=Call(func=Name(id='convert_timestamp_to_seconds', ctx=Load()), args=[Name(id='timestamp', ctx=Load())], keywords=[])), Assign(targets=[Name(id='tuned_timestamp', ctx=Store())], value=Call(func=Name(id='convert_seconds_to_timestamp', ctx=Load()), args=[Name(id='secs', ctx=Load())], keywords=[])), Return(value=Name(id='tuned_timestamp', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_timestamp', args=arguments(posonlyargs=[], args=[arg(arg='line'), arg(arg='print_line'), arg(arg='max_words')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Constant(value=8)]), body=[Expr(value=Constant(value='\n    Extracts a timestamp from a given line of text.\n\n    :param line: string representing the line of text to search for a timestamp.\n    :param print_line: boolean indicating whether to print the line where the timestamp was found. Default is False.\n    :param max_words: integer representing the maximum number of words allowed before and after the timestamp. Default is 5.\n    :return: tuple containing the extracted timestamp as a string and its index in the line, or (None, None) if no valid timestamp is found.\n    ')), Assign(targets=[Name(id='line', ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='rstrip', ctx=Load()), args=[Constant(value='\n')], keywords=[])), Assign(targets=[Name(id='timestamp_regex', ctx=Store())], value=Constant(value='\\b(?:\\d{1,2}:)?\\d{1,2}:\\d{2}\\b')), Assign(targets=[Name(id='link_regex', ctx=Store())], value=Constant(value='\\[\\s*([^\\]]*)\\]\\(\\s*([^)]+)\\s*\\)')), Assign(targets=[Name(id='combined_regex', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Constant(value='('), op=Add(), right=Name(id='timestamp_regex', ctx=Load())), op=Add(), right=Constant(value=')')), op=Add(), right=Constant(value='(?:')), op=Add(), right=Name(id='link_regex', ctx=Load())), op=Add(), right=Constant(value=')?'))), Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='search', ctx=Load()), args=[Name(id='combined_regex', ctx=Load()), Name(id='line', ctx=Load())], keywords=[])), If(test=Name(id='match', ctx=Load()), body=[Assign(targets=[Name(id='timestamp', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[], keywords=[]), attr='rstrip', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='words_before_timestamp', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='line', ctx=Load()), slice=Slice(upper=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='start', ctx=Load()), args=[], keywords=[])), ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='words_before_timestamp', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Name(id='max_words', ctx=Load())]), body=[Return(value=Tuple(elts=[Constant(value=None), Constant(value=None)], ctx=Load()))], orelse=[]), If(test=Compare(left=Call(func=Attribute(value=Call(func=Attribute(value=Constant(value=''), attr='join', ctx=Load()), args=[Name(id='words_before_timestamp', ctx=Load())], keywords=[]), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Constant(value='length:')]), body=[Return(value=Tuple(elts=[Constant(value=None), Constant(value=None)], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='index', ctx=Store())], value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='start', ctx=Load()), args=[], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='index', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), Compare(left=Subscript(value=Name(id='line', ctx=Load()), slice=BinOp(left=Name(id='index', ctx=Load()), op=Sub(), right=Constant(value=1)), ctx=Load()), ops=[Eq()], comparators=[Constant(value='[')])]), body=[AugAssign(target=Name(id='index', ctx=Store()), op=Sub(), value=Constant(value=1))], orelse=[]), Assign(targets=[Name(id='string_after_index', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='line', ctx=Load()), slice=Slice(lower=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='end', ctx=Load()), args=[], keywords=[])), ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='string_after_index', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Name(id='max_words', ctx=Load())]), Compare(left=Name(id='index', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=0)])]), body=[Return(value=Tuple(elts=[Constant(value=None), Constant(value=None)], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='pure_timestamp_match', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='search', ctx=Load()), args=[Name(id='timestamp_regex', ctx=Load()), Name(id='timestamp', ctx=Load())], keywords=[])), If(test=Name(id='pure_timestamp_match', ctx=Load()), body=[Assign(targets=[Name(id='timestamp', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=1)], keywords=[]), attr='rstrip', ctx=Load()), args=[], keywords=[]))], orelse=[]), Try(body=[Expr(value=Call(func=Name(id='convert_timestamp_to_seconds', ctx=Load()), args=[Name(id='timestamp', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), name='ve', body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Invalid timestamp: '), FormattedValue(value=Name(id='timestamp', ctx=Load()), conversion=-1), Constant(value='. Minutes or seconds exceed 59!')])], keywords=[]), cause=Name(id='ve', ctx=Load()))])], orelse=[], finalbody=[]), If(test=Name(id='print_line', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Timestamp found in line: '), FormattedValue(value=Name(id='line', ctx=Load()), conversion=-1), Constant(value=' with timestamp = '), FormattedValue(value=Name(id='timestamp', ctx=Load()), conversion=-1), Constant(value=' and index = '), FormattedValue(value=Name(id='index', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), Return(value=Tuple(elts=[Name(id='timestamp', ctx=Load()), Name(id='index', ctx=Load())], ctx=Load()))], orelse=[Return(value=Tuple(elts=[Constant(value=None), Constant(value=None)], ctx=Load()))])], decorator_list=[]), FunctionDef(name='get_current_datetime_humanfriendly', args=arguments(posonlyargs=[], args=[arg(arg='timezone'), arg(arg='include_timezone')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='America/Los_Angeles'), Constant(value=True)]), body=[Expr(value=Constant(value='\n    Returns the current date and time as a string for a given timezone, optionally including the timezone abbreviation and UTC offset.\n\n    :param timezone: string representing the timezone to use for the current time.\n    :param include_timezone: boolean indicating whether to include the timezone abbreviation and UTC offset in the returned string.\n    :return: string representing the current date and time in the specified timezone, optionally followed by the timezone abbreviation and UTC offset.\n        ')), Assign(targets=[Name(id='tz', ctx=Store())], value=Call(func=Attribute(value=Name(id='pytz', ctx=Load()), attr='timezone', ctx=Load()), args=[Name(id='timezone', ctx=Load())], keywords=[])), Assign(targets=[Name(id='current_time', ctx=Store())], value=Call(func=Attribute(value=Name(id='datetime', ctx=Load()), attr='now', ctx=Load()), args=[Name(id='tz', ctx=Load())], keywords=[])), Assign(targets=[Name(id='datetime_str', ctx=Store())], value=Call(func=Attribute(value=Name(id='current_time', ctx=Load()), attr='strftime', ctx=Load()), args=[Constant(value='%Y-%m-%d %H:%M:%S')], keywords=[])), If(test=Name(id='include_timezone', ctx=Load()), body=[Assign(targets=[Name(id='utc_offset', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='tz', ctx=Load()), attr='utcoffset', ctx=Load()), args=[Call(func=Attribute(value=Name(id='current_time', ctx=Load()), attr='replace', ctx=Load()), args=[], keywords=[keyword(arg='tzinfo', value=Constant(value=None))])], keywords=[]), attr='total_seconds', ctx=Load()), args=[], keywords=[]), op=Div(), right=Constant(value=3600))), AugAssign(target=Name(id='datetime_str', ctx=Store()), op=Add(), value=JoinedStr(values=[Constant(value=' UTC'), FormattedValue(value=Call(func=Name(id='int', ctx=Load()), args=[Name(id='utc_offset', ctx=Load())], keywords=[]), conversion=-1, format_spec=JoinedStr(values=[Constant(value='+03d')])), Constant(value=':00 '), FormattedValue(value=Name(id='timezone', ctx=Load()), conversion=-1)]))], orelse=[]), Return(value=Name(id='datetime_str', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_current_datetime_filefriendly', args=arguments(posonlyargs=[], args=[arg(arg='location'), arg(arg='include_utc')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='America/Los_Angeles'), Constant(value=False)]), body=[Expr(value=Constant(value='\n    Returns the current date and time as a filename-friendly string for a given timezone, optionally including only the UTC offset.\n\n    :param location: string representing the timezone to use for the current time.\n    :param include_utc: boolean indicating whether to include the UTC offset in the returned string.\n    :return: string representing the current date and time in the specified timezone, formatted for filenames, optionally followed by the UTC offset.\n        ')), Assign(targets=[Name(id='datetime_str', ctx=Store())], value=Call(func=Name(id='get_current_datetime_humanfriendly', ctx=Load()), args=[Name(id='location', ctx=Load())], keywords=[keyword(arg='include_timezone', value=Constant(value=True))])), Assign(targets=[Name(id='filename_friendly_datetime', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='datetime_str', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value=':'), Constant(value='')], keywords=[]), attr='replace', ctx=Load()), args=[Constant(value=' '), Constant(value='_')], keywords=[])), If(test=Name(id='include_utc', ctx=Load()), body=[Assign(targets=[Name(id='utc_offset', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Attribute(value=Name(id='filename_friendly_datetime', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='_UTC')], keywords=[]), slice=Constant(value=1), ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='_')], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='utc_offset', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='utc_offset', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='+'), Constant(value='')], keywords=[]), attr='replace', ctx=Load()), args=[Constant(value=':'), Constant(value='')], keywords=[])), Assign(targets=[Name(id='filename_friendly_datetime', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Call(func=Attribute(value=Name(id='filename_friendly_datetime', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='_UTC')], keywords=[]), slice=Constant(value=0), ctx=Load()), op=Add(), right=Constant(value='_UTC')), op=Add(), right=Name(id='utc_offset', ctx=Load())))], orelse=[Assign(targets=[Name(id='filename_friendly_datetime', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='filename_friendly_datetime', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='_UTC')], keywords=[]), slice=Constant(value=0), ctx=Load()))]), Return(value=Name(id='filename_friendly_datetime', ctx=Load()))], decorator_list=[]), FunctionDef(name='convert_to_epoch_seconds', args=arguments(posonlyargs=[], args=[arg(arg='datetime_flex'), arg(arg='timezone'), arg(arg='verbose')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='America/Los_Angeles'), Constant(value=False)]), body=[Expr(value=Constant(value="\n    Converts a human-readable time to the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n    The function assumes the input format is 'YYYY-MM-DD_HH:MM:SS [optional UTC offset] [optional timezone]', \n    where the date and time are separated by an underscore or space,\n    and the time may be followed by another underscore or space and a UTC offset string, and optionally a timezone string.\n\n    :param datetime_flex: string representing the time, which can be in 'YYYY-MM-DD_HH:MM:SS' format or 'YYYY-MM-DD HH:MM:SS [UTC offset] [timezone]'.\n    :param default_timezone: string representing the default timezone if not specified in datetime_flex. Defaults to 'America/Los_Angeles'.\n    :return: float representing the number of seconds since the Unix epoch.\n    ")), Assign(targets=[Name(id='first_delimiter_index', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='search', ctx=Load()), args=[Constant(value='[ _]'), Name(id='datetime_flex', ctx=Load())], keywords=[]), attr='start', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='date_part', ctx=Store())], value=Subscript(value=Name(id='datetime_flex', ctx=Load()), slice=Slice(upper=Name(id='first_delimiter_index', ctx=Load())), ctx=Load())), Assign(targets=[Name(id='remainder', ctx=Store())], value=Subscript(value=Name(id='datetime_flex', ctx=Load()), slice=Slice(lower=BinOp(left=Name(id='first_delimiter_index', ctx=Load()), op=Add(), right=Constant(value=1))), ctx=Load())), Assign(targets=[Name(id='next_delimiter_index', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='search', ctx=Load()), args=[Constant(value='[ _]'), Name(id='remainder', ctx=Load())], keywords=[])), If(test=Name(id='next_delimiter_index', ctx=Load()), body=[Assign(targets=[Name(id='next_delimiter_index', ctx=Store())], value=Call(func=Attribute(value=Name(id='next_delimiter_index', ctx=Load()), attr='start', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='time_part', ctx=Store())], value=Subscript(value=Name(id='remainder', ctx=Load()), slice=Slice(upper=Name(id='next_delimiter_index', ctx=Load())), ctx=Load())), Assign(targets=[Name(id='remainder', ctx=Store())], value=Subscript(value=Name(id='remainder', ctx=Load()), slice=Slice(lower=BinOp(left=Name(id='next_delimiter_index', ctx=Load()), op=Add(), right=Constant(value=1))), ctx=Load()))], orelse=[Assign(targets=[Name(id='time_part', ctx=Store())], value=Name(id='remainder', ctx=Load())), Assign(targets=[Name(id='remainder', ctx=Store())], value=Constant(value=''))]), Assign(targets=[Name(id='utc_offset_part', ctx=Store())], value=Constant(value='')), Assign(targets=[Name(id='timezone_part', ctx=Store())], value=Constant(value='')), Assign(targets=[Name(id='utc_index', ctx=Store())], value=Call(func=Attribute(value=Name(id='remainder', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value='UTC')], keywords=[])), If(test=Compare(left=Name(id='utc_index', ctx=Load()), ops=[NotEq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=[Assign(targets=[Name(id='utc_end_index', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='search', ctx=Load()), args=[Constant(value='[ _]'), Subscript(value=Name(id='remainder', ctx=Load()), slice=Slice(lower=Name(id='utc_index', ctx=Load())), ctx=Load())], keywords=[])), If(test=Name(id='utc_end_index', ctx=Load()), body=[Assign(targets=[Name(id='utc_end_index', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='utc_end_index', ctx=Load()), attr='start', ctx=Load()), args=[], keywords=[]), op=Add(), right=Name(id='utc_index', ctx=Load()))), Assign(targets=[Name(id='utc_offset_part', ctx=Store())], value=Subscript(value=Name(id='remainder', ctx=Load()), slice=Slice(lower=Name(id='utc_index', ctx=Load()), upper=Name(id='utc_end_index', ctx=Load())), ctx=Load())), Assign(targets=[Name(id='timezone_part', ctx=Store())], value=Subscript(value=Name(id='remainder', ctx=Load()), slice=Slice(lower=BinOp(left=Name(id='utc_end_index', ctx=Load()), op=Add(), right=Constant(value=1))), ctx=Load()))], orelse=[Assign(targets=[Name(id='utc_offset_part', ctx=Store())], value=Subscript(value=Name(id='remainder', ctx=Load()), slice=Slice(lower=Name(id='utc_index', ctx=Load())), ctx=Load())), Assign(targets=[Name(id='timezone_part', ctx=Store())], value=Constant(value=''))])], orelse=[Assign(targets=[Name(id='timezone_part', ctx=Store())], value=Name(id='remainder', ctx=Load()))]), Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='Date part: '), FormattedValue(value=Name(id='date_part', ctx=Load()), conversion=-1)])], keywords=[])), Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='Time part: '), FormattedValue(value=Name(id='time_part', ctx=Load()), conversion=-1)])], keywords=[])), Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value="UTC offset part: '"), FormattedValue(value=Name(id='utc_offset_part', ctx=Load()), conversion=-1), Constant(value="'")])], keywords=[])), Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value="Timezone part: '"), FormattedValue(value=Name(id='timezone_part', ctx=Load()), conversion=-1), Constant(value="'")])], keywords=[])), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='datetime', ctx=Load()), attr='strptime', ctx=Load()), args=[Name(id='date_part', ctx=Load()), Constant(value='%Y-%m-%d')], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Date format not recognized: '), FormattedValue(value=Name(id='date_part', ctx=Load()), conversion=-1), Constant(value='. Expected format: YYYY-MM-DD')])], keywords=[]))])], orelse=[], finalbody=[]), If(test=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='time_part', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=6)]), Call(func=Attribute(value=Name(id='time_part', ctx=Load()), attr='isdigit', ctx=Load()), args=[], keywords=[])]), body=[Assign(targets=[Name(id='time_part', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Subscript(value=Name(id='time_part', ctx=Load()), slice=Slice(upper=Constant(value=2)), ctx=Load()), op=Add(), right=Constant(value=':')), op=Add(), right=Subscript(value=Name(id='time_part', ctx=Load()), slice=Slice(lower=Constant(value=2), upper=Constant(value=4)), ctx=Load())), op=Add(), right=Constant(value=':')), op=Add(), right=Subscript(value=Name(id='time_part', ctx=Load()), slice=Slice(lower=Constant(value=4)), ctx=Load()))), Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='Formatted time part: '), FormattedValue(value=Name(id='time_part', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='time_part', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=8)]), Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='match', ctx=Load()), args=[Constant(value='\\d{2}:\\d{2}:\\d{2}'), Name(id='time_part', ctx=Load())], keywords=[])]), body=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='Time part already formatted: '), FormattedValue(value=Name(id='time_part', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Time format not recognized: '), FormattedValue(value=Name(id='time_part', ctx=Load()), conversion=-1), Constant(value='. Expected formats: HHMMSS (6 digits) or HH:MM:SS')])], keywords=[]))])]), If(test=Call(func=Attribute(value=Name(id='utc_offset_part', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='utc_offset_match', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='search', ctx=Load()), args=[Constant(value='([-+]?\\d{2}):?(\\d{2})'), Name(id='utc_offset_part', ctx=Load())], keywords=[])), If(test=Name(id='utc_offset_match', ctx=Load()), body=[Assign(targets=[Name(id='hours', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='utc_offset_match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=1)], keywords=[])], keywords=[])), Assign(targets=[Name(id='minutes', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='utc_offset_match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=2)], keywords=[])], keywords=[])), Assign(targets=[Name(id='utc_offset_minutes', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='hours', ctx=Load()), op=Mult(), right=Constant(value=60)), op=Add(), right=Name(id='minutes', ctx=Load()))), Assign(targets=[Name(id='tz', ctx=Store())], value=Call(func=Attribute(value=Name(id='pytz', ctx=Load()), attr='FixedOffset', ctx=Load()), args=[Name(id='utc_offset_minutes', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='Using extracted UTC offset: '), FormattedValue(value=Name(id='utc_offset_part', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Invalid UTC offset format: '), FormattedValue(value=Name(id='utc_offset_part', ctx=Load()), conversion=-1)])], keywords=[]))])], orelse=[If(test=Name(id='timezone_part', ctx=Load()), body=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='Using extracted timezone part: '), FormattedValue(value=Name(id='timezone_part', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='tz', ctx=Store())], value=Call(func=Attribute(value=Name(id='pytz', ctx=Load()), attr='timezone', ctx=Load()), args=[Name(id='timezone_part', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='No valid UTC offset or timezone part extracted, using default timezone: '), FormattedValue(value=Name(id='timezone', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='tz', ctx=Store())], value=Call(func=Attribute(value=Name(id='pytz', ctx=Load()), attr='timezone', ctx=Load()), args=[Name(id='timezone', ctx=Load())], keywords=[]))])]), Assign(targets=[Name(id='datetime_str', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='date_part', ctx=Load()), conversion=-1), Constant(value=' '), FormattedValue(value=Name(id='time_part', ctx=Load()), conversion=-1)])), Try(body=[Assign(targets=[Name(id='naive_time', ctx=Store())], value=Call(func=Attribute(value=Name(id='datetime', ctx=Load()), attr='strptime', ctx=Load()), args=[Name(id='datetime_str', ctx=Load()), Constant(value='%Y-%m-%d %H:%M:%S')], keywords=[])), Assign(targets=[Name(id='localized_time', ctx=Store())], value=Call(func=Attribute(value=Name(id='tz', ctx=Load()), attr='localize', ctx=Load()), args=[Name(id='naive_time', ctx=Load())], keywords=[])), Assign(targets=[Name(id='epoch_time', ctx=Store())], value=Call(func=Attribute(value=BinOp(left=Name(id='localized_time', ctx=Load()), op=Sub(), right=Call(func=Name(id='datetime', ctx=Load()), args=[Constant(value=1970), Constant(value=1), Constant(value=1)], keywords=[keyword(arg='tzinfo', value=Attribute(value=Name(id='pytz', ctx=Load()), attr='utc', ctx=Load()))])), attr='total_seconds', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='epoch_time', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Time format not recognized: '), FormattedValue(value=Name(id='datetime_str', ctx=Load()), conversion=-1)])], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='get_elapsed_seconds', args=arguments(posonlyargs=[], args=[arg(arg='start_time_epoch_seconds')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Calculates the time elapsed since the start_time and returns it in seconds.\n\n    :param start_time: float, the start time in seconds since the epoch (as returned by time.time())\n    :param return_format: string ('minutes' or 'timestamp') for the return value format - 'timestamp' for H:MM:SS or minutes with one decimal place\n    :return: integer of the number of seconds\n    ")), Assign(targets=[Name(id='current_time', ctx=Store())], value=Call(func=Attribute(value=Name(id='time', ctx=Load()), attr='time', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Name(id='current_time', ctx=Load()), op=Sub(), right=Name(id='start_time_epoch_seconds', ctx=Load()))], keywords=[])], keywords=[]))], decorator_list=[]), FunctionDef(name='remove_timestamp_links_from_content', args=arguments(posonlyargs=[], args=[arg(arg='content')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Removes markdown timestamp links from the content and returns the modified content.\n\n    :param content: string of the content from which to remove markdown timestamp links.\n    :return: string of the content with markdown timestamp links removed.\n    ')), Assign(targets=[Name(id='content_lines', ctx=Store())], value=Call(func=Attribute(value=Name(id='content', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='processed_lines', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[Constant(value='\\[(.*?)\\]\\(.*?\\)'), Constant(value='\\1'), Name(id='line', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='line', ctx=Store()), iter=Name(id='content_lines', ctx=Load()), ifs=[], is_async=0)])), Return(value=BinOp(left=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='processed_lines', ctx=Load())], keywords=[]), op=Add(), right=Constant(value='\n')))], decorator_list=[]), FunctionDef(name='remove_timestamp_links', args=arguments(posonlyargs=[], args=[arg(arg='file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Removes markdown timestamp links and overwrites the file.\n\n    :param file_path: string of the path to the original file.\n    :return: none.\n    ')), Assign(targets=[Tuple(elts=[Name(id='metadata', ctx=Store()), Name(id='content', ctx=Store())], ctx=Store())], value=Call(func=Name(id='read_file_flex', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='new_content', ctx=Store())], value=Call(func=Name(id='remove_timestamp_links_from_content', ctx=Load()), args=[Name(id='content', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='metadata', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='write_complete_text', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='new_content', ctx=Load())], keywords=[keyword(arg='overwrite', value=Constant(value='yes'))]))], orelse=[Expr(value=Call(func=Name(id='write_metadata_and_content', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='metadata', ctx=Load()), Name(id='new_content', ctx=Load())], keywords=[keyword(arg='suffix_new', value=Constant(value='_temp')), keyword(arg='overwrite', value=Constant(value='yes'))]))])], decorator_list=[]), FunctionDef(name='generate_timestamp_link', args=arguments(posonlyargs=[], args=[arg(arg='base_link'), arg(arg='timestamp')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Helper function to generate a timestamp link for a given base link and timestamp.\n    It uses a dictionary to map domains to their respective timestamp formats.\n    For Vimeo, the timestamp is converted to milliseconds.\n    \n    :param base_link: string of the base URL to which the timestamp will be appended.\n    :param timestamp: string of the timestamp to be converted and appended to the base URL.\n    :return: string of the complete URL with the timestamp appended in the appropriate format.\n    ')), Assign(targets=[Name(id='domain_timestamp_formats', ctx=Store())], value=Dict(keys=[Constant(value='youtube.com'), Constant(value='youtu.be'), Constant(value='spotify.com'), Constant(value='vimeo.com')], values=[Constant(value='&t={}'), Constant(value='&t={}'), Constant(value='&t={}'), Constant(value='?ts={}')])), For(target=Tuple(elts=[Name(id='domain', ctx=Store()), Name(id='format_string', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='domain_timestamp_formats', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Name(id='domain', ctx=Load()), ops=[In()], comparators=[Name(id='base_link', ctx=Load())]), body=[Assign(targets=[Name(id='domain_timestamp_format', ctx=Store())], value=Name(id='format_string', ctx=Load())), Break()], orelse=[])], orelse=[Assign(targets=[Name(id='domain_timestamp_format', ctx=Store())], value=Constant(value='&t={}'))]), If(test=Compare(left=Constant(value='?ts={}'), ops=[In()], comparators=[Name(id='domain_timestamp_format', ctx=Load())]), body=[Assign(targets=[Name(id='timestamp_seconds', ctx=Store())], value=BinOp(left=Call(func=Name(id='convert_timestamp_to_seconds', ctx=Load()), args=[Name(id='timestamp', ctx=Load())], keywords=[]), op=Mult(), right=Constant(value=1000)))], orelse=[Assign(targets=[Name(id='timestamp_seconds', ctx=Store())], value=Call(func=Name(id='convert_timestamp_to_seconds', ctx=Load()), args=[Name(id='timestamp', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='timestamp_link', ctx=Store())], value=JoinedStr(values=[Constant(value='['), FormattedValue(value=Name(id='timestamp', ctx=Load()), conversion=-1), Constant(value=']('), FormattedValue(value=Name(id='base_link', ctx=Load()), conversion=-1), FormattedValue(value=Call(func=Attribute(value=Name(id='domain_timestamp_format', ctx=Load()), attr='format', ctx=Load()), args=[Name(id='timestamp_seconds', ctx=Load())], keywords=[]), conversion=-1), Constant(value=')')])), Return(value=Name(id='timestamp_link', ctx=Load()))], decorator_list=[]), FunctionDef(name='add_timestamp_links_to_content', args=arguments(posonlyargs=[], args=[arg(arg='content'), arg(arg='base_link')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Adds timestamp links to the content using the provided base link.\n\n    :param content: string of the content where timestamp links will be added.\n    :param base_link: string of the base URL to which the timestamp will be appended.\n    :return: string of the content with timestamp links added.\n    ')), Assign(targets=[Name(id='content_lines', ctx=Store())], value=Call(func=Attribute(value=Name(id='content', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='processed_lines', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='line', ctx=Store()), iter=Name(id='content_lines', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='timestamp', ctx=Store()), Name(id='index', ctx=Store())], ctx=Store())], value=Call(func=Name(id='get_timestamp', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])), If(test=Name(id='timestamp', ctx=Load()), body=[Assign(targets=[Name(id='tuned_timestamp', ctx=Store())], value=Call(func=Name(id='tune_timestamp', ctx=Load()), args=[Name(id='timestamp', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='tuned_timestamp', ctx=Load()), Compare(left=Name(id='index', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])]), body=[Assign(targets=[Name(id='timestamp_link', ctx=Store())], value=Call(func=Name(id='generate_timestamp_link', ctx=Load()), args=[Name(id='base_link', ctx=Load()), Name(id='tuned_timestamp', ctx=Load())], keywords=[])), Assign(targets=[Name(id='line_with_link', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Name(id='line', ctx=Load()), slice=Slice(upper=Name(id='index', ctx=Load())), ctx=Load()), op=Add(), right=Name(id='timestamp_link', ctx=Load())), op=Add(), right=Subscript(value=Name(id='line', ctx=Load()), slice=Slice(lower=BinOp(left=Name(id='index', ctx=Load()), op=Add(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='timestamp', ctx=Load())], keywords=[]))), ctx=Load())))], orelse=[Assign(targets=[Name(id='line_with_link', ctx=Store())], value=Name(id='line', ctx=Load()))])], orelse=[Assign(targets=[Name(id='line_with_link', ctx=Store())], value=Name(id='line', ctx=Load()))]), Expr(value=Call(func=Attribute(value=Name(id='processed_lines', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='line_with_link', ctx=Load())], keywords=[]))], orelse=[]), Return(value=BinOp(left=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='processed_lines', ctx=Load())], keywords=[]), op=Add(), right=Constant(value='\n')))], decorator_list=[]), FunctionDef(name='add_timestamp_links', args=arguments(posonlyargs=[], args=[arg(arg='file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Adds markdown timestamp links and overwrites the file.\n\n    :param file_path: string, the path to the file where timestamp links will be added.\n    :return: none\n    ')), Assign(targets=[Tuple(elts=[Name(id='metadata', ctx=Store()), Name(id='content', ctx=Store())], ctx=Store())], value=Call(func=Name(id='read_metadata_and_content', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='_', ctx=Store()), Name(id='base_link', ctx=Store())], ctx=Store())], value=Call(func=Name(id='read_metadata_field_from_file', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='link')], keywords=[])), Assign(targets=[Name(id='content_without_links', ctx=Store())], value=Call(func=Name(id='remove_timestamp_links_from_content', ctx=Load()), args=[Name(id='content', ctx=Load())], keywords=[])), Assign(targets=[Name(id='new_content', ctx=Store())], value=Call(func=Name(id='add_timestamp_links_to_content', ctx=Load()), args=[Name(id='content_without_links', ctx=Load()), Name(id='base_link', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='write_metadata_and_content', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='metadata', ctx=Load()), Name(id='new_content', ctx=Load())], keywords=[keyword(arg='suffix_new', value=Constant(value='_temp')), keyword(arg='overwrite', value=Constant(value='yes'))]))], decorator_list=[]), FunctionDef(name='count_num_instances', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='find_str')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Counts the number of instances of a specific string in the text of the file.\n    Is case-sensitive.\n\n    :param file_path: string, the path to the file where the search will be performed.\n    :param find_str: string, the string to find in the file content.\n    :return: int, the number of instances found, or zero if no instances are found.\n        ')), Assign(targets=[Name(id='complete_text', ctx=Store())], value=Call(func=Name(id='read_complete_text', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='count', ctx=Store())], value=Call(func=Attribute(value=Name(id='complete_text', ctx=Load()), attr='count', ctx=Load()), args=[Name(id='find_str', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Number instances: '), FormattedValue(value=Name(id='count', ctx=Load()), conversion=-1), Constant(value=' of '), FormattedValue(value=Name(id='find_str', ctx=Load()), conversion=-1), Constant(value=' found in '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Name(id='count', ctx=Load()))], decorator_list=[]), FunctionDef(name='find_and_replace_pairs', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='find_replace_pairs'), arg(arg='use_regex')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='\n    Finds and replaces multiple specified strings or regex patterns in the file and overwrites the original file.\n\n    :param file_path: string, the path to the file where the find and replace operations will be performed.\n    :param find_replace_pairs: list of tuples, each containing a string or regex pattern to be found and a string to replace it with.\n    :param use_regex: boolean for whether to use regex patterns for finding. Default is False (use exact string matching).\n    :return: int, the total number of replacements made.\n    ')), Assign(targets=[Tuple(elts=[Name(id='metadata', ctx=Store()), Name(id='content', ctx=Store())], ctx=Store())], value=Call(func=Name(id='read_file_flex', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='total_replacements', ctx=Store())], value=Constant(value=0)), For(target=Tuple(elts=[Name(id='find_str', ctx=Store()), Name(id='replace_str', ctx=Store())], ctx=Store()), iter=Name(id='find_replace_pairs', ctx=Load()), body=[If(test=Name(id='use_regex', ctx=Load()), body=[Assign(targets=[Name(id='regex', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Name(id='find_str', ctx=Load()), Attribute(value=Name(id='re', ctx=Load()), attr='DOTALL', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='content', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='regex', ctx=Load()), attr='subn', ctx=Load()), args=[Name(id='replace_str', ctx=Load()), Name(id='content', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Tuple(elts=[Name(id='content', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='subn', ctx=Load()), args=[Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='find_str', ctx=Load())], keywords=[]), Name(id='replace_str', ctx=Load()), Name(id='content', ctx=Load())], keywords=[keyword(arg='flags', value=Attribute(value=Name(id='re', ctx=Load()), attr='DOTALL', ctx=Load()))]))]), AugAssign(target=Name(id='total_replacements', ctx=Store()), op=Add(), value=Name(id='count', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='metadata', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='write_complete_text', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='content', ctx=Load())], keywords=[keyword(arg='overwrite', value=Constant(value='yes'))]))], orelse=[Expr(value=Call(func=Name(id='write_metadata_and_content', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='metadata', ctx=Load()), Name(id='content', ctx=Load())], keywords=[keyword(arg='overwrite', value=Constant(value='yes'))]))]), Return(value=Name(id='total_replacements', ctx=Load()))], decorator_list=[]), FunctionDef(name='parse_csv_for_find_replace', args=arguments(posonlyargs=[], args=[arg(arg='csv_file')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Parses a CSV file to extract find and replace pairs.\n    Returns a list of the find_\n    ')), Assign(targets=[Name(id='pairs', ctx=Store())], value=List(elts=[], ctx=Load())), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='csv_file', ctx=Load())], keywords=[keyword(arg='mode', value=Constant(value='r')), keyword(arg='newline', value=Constant(value=''))]), optional_vars=Name(id='csvfile', ctx=Store()))], body=[Assign(targets=[Name(id='csvreader', ctx=Store())], value=Call(func=Attribute(value=Name(id='csv', ctx=Load()), attr='reader', ctx=Load()), args=[Name(id='csvfile', ctx=Load())], keywords=[])), Assign(targets=[Name(id='first_row', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='csvreader', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=BoolOp(op=And(), values=[Name(id='first_row', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Constant(value=','), attr='join', ctx=Load()), args=[Name(id='first_row', ctx=Load())], keywords=[]), attr='strip', ctx=Load()), args=[], keywords=[]), attr='startswith', ctx=Load()), args=[Constant(value='find')], keywords=[])])), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value="CSV does not start with 'find, replace' header. Processing the first row as data.")], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pairs', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Call(func=Attribute(value=Subscript(value=Name(id='first_row', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Subscript(value=Name(id='first_row', ctx=Load()), slice=Constant(value=1), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])], ctx=Load())], keywords=[]))], orelse=[]), For(target=Name(id='row', ctx=Store()), iter=Name(id='csvreader', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Name(id='row', ctx=Load()), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Call(func=Attribute(value=Subscript(value=Name(id='row', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), attr='startswith', ctx=Load()), args=[Constant(value='#')], keywords=[]))]), body=[Try(body=[Assign(targets=[Tuple(elts=[Name(id='find_str', ctx=Store()), Name(id='replace_str', ctx=Store())], ctx=Store())], value=Tuple(elts=[Call(func=Attribute(value=Subscript(value=Name(id='row', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Subscript(value=Name(id='row', ctx=Load()), slice=Constant(value=1), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])], ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='pairs', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='find_str', ctx=Load()), Name(id='replace_str', ctx=Load())], ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='IndexError', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Error processing row: '), FormattedValue(value=Name(id='row', ctx=Load()), conversion=-1), Constant(value=' - '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[]))])], orelse=[], finalbody=[])], orelse=[])], orelse=[])]), Return(value=Name(id='pairs', ctx=Load()))], decorator_list=[]), FunctionDef(name='find_and_replace_from_csv', args=arguments(posonlyargs=[], args=[arg(arg='folder_path'), arg(arg='find_replace_csv'), arg(arg='suffixpat_include'), arg(arg='verbose')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value="\n    Applies find and replace operations on all files in a specified folder based on pairs defined in a CSV file.\n    Overwrite is fixed at 'yes' so you have to copy the files before running.\n    IMPORTANT csv file cannot be in the same folder if suffixpat_include=None\n    Good practice is to always include a suffixpat_include even if those are the only type of file in the folder.\n\n    :param folder_path: string, the path to the folder where the files are located.\n    :param find_replace_csv: string, the path to the CSV file containing find and replace pairs.\n    :param suffixpat_include: string, the suffix pattern that included files must have. If None, all files will be processed.\n    :param verbose: boolean, if True prints verbose messages.\n    :return: None\n    ")), Assign(targets=[Name(id='find_replace_pairs', ctx=Store())], value=Call(func=Name(id='parse_csv_for_find_replace', ctx=Load()), args=[Name(id='find_replace_csv', ctx=Load())], keywords=[])), Assign(targets=[Name(id='results', ctx=Store())], value=Call(func=Name(id='apply_to_folder', ctx=Load()), args=[Name(id='find_and_replace_pairs', ctx=Load()), Name(id='folder_path', ctx=Load()), Name(id='find_replace_pairs', ctx=Load())], keywords=[keyword(arg='suffixpat_include', value=Name(id='suffixpat_include', ctx=Load())), keyword(arg='verbose', value=Name(id='verbose', ctx=Load()))])), Assign(targets=[Name(id='total_replacements', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='results', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='total_replacements', ctx=Load()), conversion=-1), Constant(value=' REPLACEMENTS IN '), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='results', ctx=Load())], keywords=[]), conversion=-1), Constant(value=' files run.')])], keywords=[])), If(test=Name(id='verbose', ctx=Load()), body=[For(target=Tuple(elts=[Name(id='file_path', ctx=Store()), Name(id='num_replacements', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='num_replacements', ctx=Load()), conversion=-1), Constant(value=' replacements in file: '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value='  '), FormattedValue(value=Name(id='num_replacements', ctx=Load()), conversion=-1), Constant(value=' replacements')])], keywords=[]))], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='get_heading_level', args=arguments(posonlyargs=[], args=[arg(arg='heading')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Determines the level of a markdown heading.\n\n    :param heading: string, the markdown heading including '#' characters.\n    :return: int, the level of the heading.\n    ")), Return(value=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='heading', ctx=Load())], keywords=[]), op=Sub(), right=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Attribute(value=Name(id='heading', ctx=Load()), attr='lstrip', ctx=Load()), args=[Constant(value='#')], keywords=[])], keywords=[])))], decorator_list=[]), FunctionDef(name='get_heading_pattern', args=arguments(posonlyargs=[], args=[arg(arg='heading')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Creates a regex pattern to match a heading and its content, including subheadings.\n\n    :param heading: string, the markdown heading including '#' characters.\n    :return: compiled regex pattern or None if heading is empty\n    ")), If(test=UnaryOp(op=Not(), operand=Name(id='heading', ctx=Load())), body=[Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='heading_level', ctx=Store())], value=Call(func=Name(id='get_heading_level', ctx=Load()), args=[Name(id='heading', ctx=Load())], keywords=[])), Assign(targets=[Name(id='escaped_heading', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='heading', ctx=Load())], keywords=[])), Assign(targets=[Name(id='delimiter_end_pattern', ctx=Store())], value=BinOp(left=BinOp(left=Constant(value='(?=^#{1,'), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='heading_level', ctx=Load())], keywords=[])), op=Add(), right=Constant(value='}\\s|\\Z)'))), Assign(targets=[Name(id='full_pattern', ctx=Store())], value=JoinedStr(values=[Constant(value='('), FormattedValue(value=Name(id='escaped_heading', ctx=Load()), conversion=-1), Constant(value='.*?)'), FormattedValue(value=Name(id='delimiter_end_pattern', ctx=Load()), conversion=-1)])), Return(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Name(id='full_pattern', ctx=Load()), BinOp(left=Attribute(value=Name(id='re', ctx=Load()), attr='MULTILINE', ctx=Load()), op=BitOr(), right=Attribute(value=Name(id='re', ctx=Load()), attr='DOTALL', ctx=Load()))], keywords=[]))], decorator_list=[]), FunctionDef(name='find_heading_text', args=arguments(posonlyargs=[], args=[arg(arg='full_text'), arg(arg='heading')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Finds the heading text, including its subheadings, inclusive of the heading itself.\n\n    :param text: string, the text to search in.\n    :param heading: string, the markdown heading to find.\n    :return: tuple (start_index, end_index) or None if not found.\n    ')), Assign(targets=[Name(id='pattern', ctx=Store())], value=Call(func=Name(id='get_heading_pattern', ctx=Load()), args=[Name(id='heading', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='pattern', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='pattern', ctx=Load()), attr='search', ctx=Load()), args=[Name(id='full_text', ctx=Load())], keywords=[])), If(test=Name(id='match', ctx=Load()), body=[Return(value=Tuple(elts=[Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='start', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='end', ctx=Load()), args=[], keywords=[])], ctx=Load()))], orelse=[]), Return(value=Constant(value=None))], decorator_list=[]), FunctionDef(name='get_heading', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='heading')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Extracts the markdown heading and its associated text from a file, including any subheadings of equal or lower order.\n    Uses the complete text and does not parse the metadata and content sections.\n\n    :param file_path: string, the path to the file to be read.\n    :param heading: string, the markdown heading to be extracted, including the '#' characters and the following space.\n    :return: string, the markdown heading and its associated text, including any subheadings of equal or lower order.\n    ")), Assign(targets=[Name(id='complete_text', ctx=Store())], value=Call(func=Name(id='read_complete_text', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='find_heading_text', ctx=Load()), args=[Name(id='complete_text', ctx=Load()), Name(id='heading', ctx=Load())], keywords=[])), If(test=Name(id='result', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='start', ctx=Store()), Name(id='end', ctx=Store())], ctx=Store())], value=Name(id='result', ctx=Load())), Return(value=Subscript(value=Name(id='complete_text', ctx=Load()), slice=Slice(lower=Name(id='start', ctx=Load()), upper=Name(id='end', ctx=Load())), ctx=Load()))], orelse=[]), Return(value=Constant(value=None))], decorator_list=[]), FunctionDef(name='set_heading', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='new_text'), arg(arg='heading')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Sets the heading and following text associated with a markdown heading and overwrites the file.\n    Replaces if the heading already exists. Adds if it does not exist.\n    New line characters must be included in the new_text (e.g., "\nHere\'s new text\n\n").\n    \n    :param file_path: string, the path to the file where the heading text will be set.\n    :param new_text: string, the new text to be associated with the markdown heading, inclusive of newlines.\n    :param heading: string, the markdown heading whose text will be set, including the \'#\' characters and the following space.\n    :return: None\n    ')), Assign(targets=[Tuple(elts=[Name(id='metadata', ctx=Store()), Name(id='content', ctx=Store())], ctx=Store())], value=Call(func=Name(id='read_metadata_and_content', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='new_text_with_heading', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='heading', ctx=Load()), conversion=-1), Constant(value='\n'), FormattedValue(value=Name(id='new_text', ctx=Load()), conversion=-1)])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='new_text_with_heading', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='\n')], keywords=[])), body=[AugAssign(target=Name(id='new_text_with_heading', ctx=Store()), op=Add(), value=Constant(value='\n'))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='find_heading_text', ctx=Load()), args=[Name(id='content', ctx=Load()), Name(id='heading', ctx=Load())], keywords=[])), If(test=Name(id='result', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='start', ctx=Store()), Name(id='end', ctx=Store())], ctx=Store())], value=Name(id='result', ctx=Load())), Assign(targets=[Name(id='new_content', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Name(id='content', ctx=Load()), slice=Slice(upper=Name(id='start', ctx=Load())), ctx=Load()), op=Add(), right=Name(id='new_text_with_heading', ctx=Load())), op=Add(), right=Subscript(value=Name(id='content', ctx=Load()), slice=Slice(lower=Name(id='end', ctx=Load())), ctx=Load())))], orelse=[Assign(targets=[Name(id='content_lines', ctx=Store())], value=Call(func=Attribute(value=Name(id='content', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[])), If(test=Call(func=Attribute(value=Name(id='content', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='content_lines', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=1)]), body=[Assign(targets=[Name(id='insert_position', ctx=Store())], value=Constant(value=1)), While(test=BoolOp(op=And(), values=[Compare(left=Name(id='insert_position', ctx=Load()), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='content_lines', ctx=Load())], keywords=[])]), Compare(left=Call(func=Attribute(value=Subscript(value=Name(id='content_lines', ctx=Load()), slice=Name(id='insert_position', ctx=Load()), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Constant(value='')])]), body=[AugAssign(target=Name(id='insert_position', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[]), Assign(targets=[Name(id='new_text_to_insert', ctx=Store())], value=IfExp(test=Call(func=Attribute(value=Name(id='new_text_with_heading', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='\n')], keywords=[]), body=Subscript(value=Name(id='new_text_with_heading', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()), orelse=Name(id='new_text_with_heading', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='content_lines', ctx=Load()), attr='insert', ctx=Load()), args=[Name(id='insert_position', ctx=Load()), Name(id='new_text_to_insert', ctx=Load())], keywords=[])), Assign(targets=[Name(id='new_content', ctx=Store())], value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='content_lines', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='new_content', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Call(func=Attribute(value=Name(id='content', ctx=Load()), attr='rstrip', ctx=Load()), args=[], keywords=[]), conversion=-1), Constant(value='\n\n'), FormattedValue(value=Name(id='new_text_with_heading', ctx=Load()), conversion=-1)]))])], orelse=[Assign(targets=[Name(id='new_content', ctx=Store())], value=Name(id='new_text_with_heading', ctx=Load()))])]), Expr(value=Call(func=Name(id='write_metadata_and_content', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='metadata', ctx=Load()), Name(id='new_content', ctx=Load())], keywords=[keyword(arg='suffix_new', value=Constant(value='_temp')), keyword(arg='overwrite', value=Constant(value='yes'))]))], decorator_list=[]), FunctionDef(name='delete_heading', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='heading')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Deletes the specified markdown heading and its following text, including subheadings, and overwrites the file.\n    If the heading does not exist, a warning is issued and no action is taken.\n\n    :param file_path: string of the path to the file from which the heading will be deleted.\n    :param heading: string of the markdown heading to be deleted, including the '#' characters and the following space.\n    ")), Assign(targets=[Tuple(elts=[Name(id='metadata', ctx=Store()), Name(id='content', ctx=Store())], ctx=Store())], value=Call(func=Name(id='read_metadata_and_content', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='find_heading_text', ctx=Load()), args=[Name(id='content', ctx=Load()), Name(id='heading', ctx=Load())], keywords=[])), If(test=Name(id='result', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='start', ctx=Store()), Name(id='end', ctx=Store())], ctx=Store())], value=Name(id='result', ctx=Load())), Assign(targets=[Name(id='new_content', ctx=Store())], value=BinOp(left=Subscript(value=Name(id='content', ctx=Load()), slice=Slice(upper=Name(id='start', ctx=Load())), ctx=Load()), op=Add(), right=Subscript(value=Name(id='content', ctx=Load()), slice=Slice(lower=Name(id='end', ctx=Load())), ctx=Load()))), Assign(targets=[Name(id='new_content', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[Constant(value='\\n{3,}'), Constant(value='\n\n'), Name(id='new_content', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='write_metadata_and_content', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='metadata', ctx=Load()), Name(id='new_content', ctx=Load())], keywords=[keyword(arg='suffix_new', value=Constant(value='_temp')), keyword(arg='overwrite', value=Constant(value='yes'))]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='in delete_heading: trying to delete heading that does not exist - no action')], keywords=[]))])], decorator_list=[]), FunctionDef(name='append_heading_to_file', args=arguments(posonlyargs=[], args=[arg(arg='source_file_path'), arg(arg='target_file_path'), arg(arg='heading'), arg(arg='include_filename')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='\n    Appends the text under a specified heading from a source file to a target file, optionally including the source filename as a heading.\n\n    :param source_file_path: string of the path to the source file.\n    :param target_file_path: string of the path to the target file where the text will be appended.\n    :param heading: string of the markdown heading to be appended.\n    :param include_filename: boolean indicating whether to include the source filename as a heading. Defaults to True.\n    :return: string of the appended text or None if the heading is not found in the source file.\n    ')), Assign(targets=[Name(id='new_text', ctx=Store())], value=Call(func=Name(id='get_heading', ctx=Load()), args=[Name(id='source_file_path', ctx=Load()), Name(id='heading', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='new_text', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[If(test=Name(id='include_filename', ctx=Load()), body=[Assign(targets=[Name(id='filename', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='source_file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='heading_level', ctx=Store())], value=BinOp(left=Constant(value='#'), op=Mult(), right=IfExp(test=Compare(left=Call(func=Attribute(value=Name(id='heading', ctx=Load()), attr='count', ctx=Load()), args=[Constant(value='#')], keywords=[]), ops=[Gt()], comparators=[Constant(value=1)]), body=BinOp(left=Call(func=Attribute(value=Name(id='heading', ctx=Load()), attr='count', ctx=Load()), args=[Constant(value='#')], keywords=[]), op=Sub(), right=Constant(value=1)), orelse=Constant(value=1)))), Assign(targets=[Name(id='new_text', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='heading_level', ctx=Load()), conversion=-1), Constant(value=' '), FormattedValue(value=Name(id='filename', ctx=Load()), conversion=-1), Constant(value='\n'), FormattedValue(value=Name(id='new_text', ctx=Load()), conversion=-1)]))], orelse=[]), Assign(targets=[Name(id='target_folder', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Name(id='target_file_path', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='target_folder', ctx=Load())), body=[Assign(targets=[Name(id='source_folder', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Name(id='source_file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='target_file_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='source_folder', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='target_file_path', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='target_file_path', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Name(id='read_complete_text', ctx=Load()), args=[Name(id='target_file_path', ctx=Load())], keywords=[])), AugAssign(target=Name(id='text', ctx=Store()), op=Add(), value=BinOp(left=Constant(value='\n'), op=Add(), right=Name(id='new_text', ctx=Load())))], orelse=[]), Expr(value=Call(func=Name(id='write_complete_text', ctx=Load()), args=[Name(id='target_file_path', ctx=Load()), Name(id='text', ctx=Load())], keywords=[keyword(arg='suffix_new', value=Constant(value='_temp')), keyword(arg='overwrite', value=Constant(value='yes'))])), Return(value=Name(id='new_text', ctx=Load()))], orelse=[Return(value=Constant(value=None))])], decorator_list=[]), FunctionDef(name='create_new_file_from_heading', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='heading'), arg(arg='suffix_new'), arg(arg='remove_heading')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='_headingonly'), Constant(value=False)]), body=[Expr(value=Constant(value='\n    Extracts text under a specified heading from a file and writes it to a new file with a specified suffix.\n\n    :param file_path: string of the path to the file.\n    :param heading: string of the markdown heading to be processed.\n    :param suffix_new: string of the suffix to be appended to the new file. Defaults to "_headingonly".\n    :param remove_heading: boolean indicating whether to remove the heading from the extracted text. Defaults to False.\n    :return: string of the path to the newly created file.\n    ')), Assign(targets=[Name(id='heading_text', ctx=Store())], value=Call(func=Name(id='get_heading', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='heading', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='heading_text', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='heading_text', ctx=Store())], value=Constant(value=''))], orelse=[If(test=Name(id='remove_heading', ctx=Load()), body=[Assign(targets=[Name(id='lines', ctx=Store())], value=Call(func=Attribute(value=Name(id='heading_text', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[])), Assign(targets=[Name(id='non_empty_index', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[GeneratorExp(elt=Name(id='i', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='line', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[]), ifs=[BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='#')], keywords=[]))])], is_async=0)]), Call(func=Name(id='len', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='heading_text', ctx=Store())], value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Subscript(value=Name(id='lines', ctx=Load()), slice=Slice(lower=Name(id='non_empty_index', ctx=Load())), ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='heading_text', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='heading_text', ctx=Load()), attr='lstrip', ctx=Load()), args=[Name(id='heading', ctx=Load())], keywords=[]), attr='lstrip', ctx=Load()), args=[Constant(value='\n')], keywords=[]))])]), Return(value=Call(func=Name(id='write_complete_text', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='heading_text', ctx=Load()), Name(id='suffix_new', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='set_metadata_field', args=arguments(posonlyargs=[], args=[arg(arg='metadata'), arg(arg='field'), arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Sets or updates a metadata field with a given value.\n\n    :param metadata: string, the metadata from which a metadata field is to be set or updated.\n    :param field: string, the metadata field to be set or updated without the : and space.\n    :param value: string, the value to be set for the metadata field.\n    :return: string, the updated metadata with the set or updated metadata field.\n    ')), Assign(targets=[Name(id='lines', ctx=Store())], value=Call(func=Attribute(value=Name(id='metadata', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[])), Assign(targets=[Name(id='field_line', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='field_exists', ctx=Store())], value=Constant(value=False)), Assign(targets=[Name(id='insert_index', ctx=Store())], value=UnaryOp(op=USub(), operand=Constant(value=1))), Assign(targets=[Name(id='metadata_start_found', ctx=Store())], value=Constant(value=False)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='line', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Constant(value='## metadata'), ops=[In()], comparators=[Name(id='line', ctx=Load())]), body=[Assign(targets=[Name(id='metadata_start_found', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='metadata_index', ctx=Store())], value=Name(id='i', ctx=Load()))], orelse=[If(test=BoolOp(op=And(), values=[Name(id='metadata_start_found', ctx=Load()), Compare(left=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Constant(value='')])]), body=[Assign(targets=[Name(id='insert_index', ctx=Store())], value=Name(id='i', ctx=Load())), Break()], orelse=[])]), If(test=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='startswith', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='field', ctx=Load()), conversion=-1), Constant(value=':')])], keywords=[]), body=[Assign(targets=[Name(id='field_exists', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='field_line', ctx=Store())], value=Name(id='i', ctx=Load())), Break()], orelse=[])], orelse=[]), If(test=Name(id='field_exists', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='lines', ctx=Load()), slice=Name(id='field_line', ctx=Load()), ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='field', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1)]))], orelse=[If(test=Compare(left=Name(id='insert_index', ctx=Load()), ops=[Eq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=[Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='insert', ctx=Load()), args=[BinOp(left=Name(id='metadata_index', ctx=Load()), op=Add(), right=Constant(value=1)), JoinedStr(values=[FormattedValue(value=Name(id='field', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='insert', ctx=Load()), args=[Name(id='insert_index', ctx=Load()), JoinedStr(values=[FormattedValue(value=Name(id='field', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1)])], keywords=[]))])]), Assign(targets=[Name(id='updated_metadata', ctx=Store())], value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[])), Return(value=Name(id='updated_metadata', ctx=Load()))], decorator_list=[]), FunctionDef(name='remove_metadata_field', args=arguments(posonlyargs=[], args=[arg(arg='metadata'), arg(arg='field')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Removes a specified metadata field from the metadata.\n\n    :param metadata: string, the metadata from which a metadata field is to be removed.\n    :param field: string, the metadata field to be removed.\n    :return: string, the updated metadata with the removed metadata field.\n    ')), Assign(targets=[Name(id='lines', ctx=Store())], value=Call(func=Attribute(value=Name(id='metadata', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[])), Assign(targets=[Name(id='updated_lines', ctx=Store())], value=ListComp(elt=Name(id='line', ctx=Load()), generators=[comprehension(target=Name(id='line', ctx=Store()), iter=Name(id='lines', ctx=Load()), ifs=[UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='startswith', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='field', ctx=Load()), conversion=-1), Constant(value=':')])], keywords=[]))], is_async=0)])), Assign(targets=[Name(id='updated_metadata', ctx=Store())], value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='updated_lines', ctx=Load())], keywords=[])), Return(value=Name(id='updated_metadata', ctx=Load()))], decorator_list=[]), FunctionDef(name='create_initial_metadata', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Creates an initial metadata for a file.\n\n    :return: string, the initial metadata for a file.\n    ')), Assign(targets=[Name(id='metadata', ctx=Store())], value=Constant(value='## metadata\nlast updated: \n')), Return(value=Name(id='metadata', ctx=Load()))], decorator_list=[]), FunctionDef(name='set_last_updated', args=arguments(posonlyargs=[], args=[arg(arg='metadata'), arg(arg='new_last_updated_value'), arg(arg='use_today')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value="\n    Updates the 'last updated' metadata field in the metadata with a new value.\n\n    :param metadata: string, the metadata from which the 'last updated' metadata field is to be updated.\n    :param new_last_updated_value: string, the new value for the 'last updated' metadata field.\n    :param use_today: boolean, if True, today's date is prepended to the new_last_updated_value. Default is True.\n    :return: string, the updated metadata with the new 'last updated' value.\n    ")), If(test=Name(id='use_today', ctx=Load()), body=[Assign(targets=[Name(id='date_today', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='datetime', ctx=Load()), attr='now', ctx=Load()), args=[], keywords=[]), attr='strftime', ctx=Load()), args=[Constant(value='%m-%d-%Y')], keywords=[])), Assign(targets=[Name(id='new_last_updated_value', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='date_today', ctx=Load()), conversion=-1), Constant(value=' '), FormattedValue(value=Name(id='new_last_updated_value', ctx=Load()), conversion=-1)]))], orelse=[]), Return(value=Call(func=Name(id='set_metadata_field', ctx=Load()), args=[Name(id='metadata', ctx=Load()), Constant(value='last updated'), Name(id='new_last_updated_value', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='read_metadata_field_from_file', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='field')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Reads a specific metadata field from a file.\n\n    :param file_path: string, the path to the file to be read.\n    :param field: string, the metadata field to be read from the file.\n    :return: tuple, the line number of the field and the value of the field.\n    ')), Assign(targets=[Tuple(elts=[Name(id='metadata', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Name(id='read_metadata_and_content', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='metadata_start', ctx=Store())], value=Call(func=Attribute(value=Name(id='metadata', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value='## metadata')], keywords=[])), Assign(targets=[Name(id='metadata_end', ctx=Store())], value=Call(func=Attribute(value=Name(id='metadata', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value='##'), BinOp(left=Name(id='metadata_start', ctx=Load()), op=Add(), right=Call(func=Name(id='len', ctx=Load()), args=[Constant(value='## metadata')], keywords=[]))], keywords=[])), If(test=Compare(left=Name(id='metadata_end', ctx=Load()), ops=[Eq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=[Assign(targets=[Name(id='metadata_end', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='metadata', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='metadata_selection', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='metadata', ctx=Load()), slice=Slice(lower=Name(id='metadata_start', ctx=Load()), upper=Name(id='metadata_end', ctx=Load())), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='field_search', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='field', ctx=Load()), conversion=-1), Constant(value=': ')])), Assign(targets=[Name(id='field_start', ctx=Store())], value=Call(func=Attribute(value=Name(id='metadata_selection', ctx=Load()), attr='find', ctx=Load()), args=[Name(id='field_search', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='field_start', ctx=Load()), ops=[NotEq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=[Assign(targets=[Name(id='field_line', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Subscript(value=Name(id='metadata_selection', ctx=Load()), slice=Slice(upper=Name(id='field_start', ctx=Load())), ctx=Load()), attr='count', ctx=Load()), args=[Constant(value='\n')], keywords=[]), op=Add(), right=Constant(value=2))), AugAssign(target=Name(id='field_start', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='field_search', ctx=Load())], keywords=[])), Assign(targets=[Name(id='field_end', ctx=Store())], value=Call(func=Attribute(value=Name(id='metadata_selection', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value='\n'), Name(id='field_start', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='field_end', ctx=Load()), ops=[Eq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=[Assign(targets=[Name(id='field_end', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='metadata_selection', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='field_value', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='metadata_selection', ctx=Load()), slice=Slice(lower=Name(id='field_start', ctx=Load()), upper=Name(id='field_end', ctx=Load())), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), Return(value=Tuple(elts=[Name(id='field_line', ctx=Load()), Name(id='field_value', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Constant(value=None))], decorator_list=[]), FunctionDef(name='set_metadata_fields_from_csv', args=arguments(posonlyargs=[], args=[arg(arg='folder_path'), arg(arg='csv_file_path'), arg(arg='suffix_extension')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Sets metadata fields for all files in a folder based on a CSV file.\n\n    :param folder_path: string of the path to the folder containing the files.\n    :param csv_file_path: string of the path to the CSV file with metadata fields and values.\n    :param suffix_extension: string of the file extension to be appended to file bases.\n    :return: None, but prints the number of files processed successfully and the total in the CSV excluding empty rows.\n    ')), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='csv_file_path', ctx=Load())], keywords=[keyword(arg='mode', value=Constant(value='r')), keyword(arg='encoding', value=Constant(value='utf-8'))]), optional_vars=Name(id='csvfile', ctx=Store()))], body=[Assign(targets=[Name(id='csv_reader', ctx=Store())], value=Call(func=Attribute(value=Name(id='csv', ctx=Load()), attr='reader', ctx=Load()), args=[Name(id='csvfile', ctx=Load())], keywords=[])), Assign(targets=[Name(id='metadata_fields', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='csv_reader', ctx=Load())], keywords=[])), Assign(targets=[Name(id='metadata_values', ctx=Store())], value=ListComp(elt=Name(id='row', ctx=Load()), generators=[comprehension(target=Name(id='row', ctx=Store()), iter=Name(id='csv_reader', ctx=Load()), ifs=[Name(id='row', ctx=Load())], is_async=0)]))]), Assign(targets=[Name(id='total_files_in_csv', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='metadata_values', ctx=Load())], keywords=[])), Assign(targets=[Name(id='successfully_processed_files', ctx=Store())], value=Constant(value=0)), For(target=Tuple(elts=[Name(id='row_index', ctx=Store()), Name(id='row', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='metadata_values', ctx=Load())], keywords=[keyword(arg='start', value=Constant(value=1))]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='row', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='metadata_fields', ctx=Load())], keywords=[])]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Row '), FormattedValue(value=Name(id='row_index', ctx=Load()), conversion=-1), Constant(value=' in CSV does not have enough columns. Expected '), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='metadata_fields', ctx=Load())], keywords=[]), conversion=-1), Constant(value=', got '), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='row', ctx=Load())], keywords=[]), conversion=-1), Constant(value='.')])], keywords=[])), Continue()], orelse=[]), Assign(targets=[Name(id='file_base', ctx=Store())], value=BinOp(left=Subscript(value=Name(id='row', ctx=Load()), slice=Constant(value=0), ctx=Load()), op=Add(), right=Name(id='suffix_extension', ctx=Load()))), Assign(targets=[Name(id='file_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='folder_path', ctx=Load()), Name(id='file_base', ctx=Load())], keywords=[])), Assign(targets=[Name(id='metadata_dict', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Subscript(value=Name(id='metadata_fields', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()), Subscript(value=Name(id='row', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load())], keywords=[])], keywords=[])), Try(body=[Assign(targets=[Tuple(elts=[Name(id='metadata', ctx=Store()), Name(id='content', ctx=Store())], ctx=Store())], value=Call(func=Name(id='read_metadata_and_content', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='field', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='metadata_dict', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Name(id='set_metadata_field', ctx=Load()), args=[Name(id='metadata', ctx=Load()), Name(id='field', ctx=Load()), Name(id='value', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='write_metadata_and_content', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='metadata', ctx=Load()), Name(id='content', ctx=Load())], keywords=[keyword(arg='suffix_new', value=Constant(value='_temp')), keyword(arg='overwrite', value=Constant(value='yes'))])), AugAssign(target=Name(id='successfully_processed_files', ctx=Store()), op=Add(), value=Constant(value=1))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Failed to process file '), FormattedValue(value=Name(id='file_base', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[]))])], orelse=[], finalbody=[])], orelse=[]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Total files in CSV excluding empty rows: '), FormattedValue(value=Name(id='total_files_in_csv', ctx=Load()), conversion=-1)])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Successfully processed files: '), FormattedValue(value=Name(id='successfully_processed_files', ctx=Load()), conversion=-1)])], keywords=[]))], decorator_list=[]), FunctionDef(name='create_csv_from_fields', args=arguments(posonlyargs=[], args=[arg(arg='folder_path'), arg(arg='fields')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Generates a CSV file of input fields from all markdown files in a folder.\n    Fields can be 2 formats, 1) generic, usually metadata (ending with a ':') or 2) markdown headings (starting with a '#').\n    Generic fields extract single-line values, while heading fields capture all content under the heading.\n\n    :param folder_path: string, the path to the folder containing the markdown files.\n    :param fields: list, the fields to be extracted from the markdown files.\n    :return: string of the path to the created csv file.\n    ")), Assign(targets=[Name(id='folder_name', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='normpath', ctx=Load()), args=[Name(id='folder_path', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='csv_filename', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='folder_path', ctx=Load()), JoinedStr(values=[FormattedValue(value=Name(id='folder_name', ctx=Load()), conversion=-1), Constant(value='.csv')])], keywords=[])), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='csv_filename', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='user_input', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='input', ctx=Load()), args=[JoinedStr(values=[Constant(value='The file '), FormattedValue(value=Name(id='csv_filename', ctx=Load()), conversion=-1), Constant(value=' already exists. Overwrite? (y/n): ')])], keywords=[]), attr='strip', ctx=Load()), args=[], keywords=[]), attr='lower', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='user_input', ctx=Load()), ops=[Eq()], comparators=[Constant(value='n')]), body=[Assign(targets=[Tuple(elts=[Name(id='base', ctx=Store()), Name(id='ext', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Name(id='csv_filename', ctx=Load())], keywords=[])), Assign(targets=[Name(id='csv_filename', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='base', ctx=Load()), conversion=-1), Constant(value='(1)'), FormattedValue(value=Name(id='ext', ctx=Load()), conversion=-1)]))], orelse=[])], orelse=[]), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='csv_filename', ctx=Load()), Constant(value='w')], keywords=[keyword(arg='newline', value=Constant(value=''))]), optional_vars=Name(id='csvfile', ctx=Store()))], body=[Assign(targets=[Name(id='adjusted_fields', ctx=Store())], value=BinOp(left=List(elts=[Constant(value='file_name'), Constant(value='title')], ctx=Load()), op=Add(), right=ListComp(elt=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='field', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), attr='replace', ctx=Load()), args=[Constant(value=':'), Constant(value='')], keywords=[]), attr='replace', ctx=Load()), args=[Constant(value='#'), Constant(value='')], keywords=[]), generators=[comprehension(target=Name(id='field', ctx=Store()), iter=Name(id='fields', ctx=Load()), ifs=[], is_async=0)]))), Assign(targets=[Name(id='csv_writer', ctx=Store())], value=Call(func=Attribute(value=Name(id='csv', ctx=Load()), attr='DictWriter', ctx=Load()), args=[Name(id='csvfile', ctx=Load())], keywords=[keyword(arg='fieldnames', value=Name(id='adjusted_fields', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='csv_writer', ctx=Load()), attr='writeheader', ctx=Load()), args=[], keywords=[])), For(target=Name(id='filename', ctx=Store()), iter=Call(func=Name(id='sorted', ctx=Load()), args=[Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='listdir', ctx=Load()), args=[Name(id='folder_path', ctx=Load())], keywords=[])], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='filename', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='.md')], keywords=[]), body=[Assign(targets=[Name(id='file_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='folder_path', ctx=Load()), Name(id='filename', ctx=Load())], keywords=[])), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='content', ctx=Store())], value=Call(func=Attribute(value=Name(id='file', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))]), Assign(targets=[Name(id='data', ctx=Store())], value=Dict(keys=[Constant(value='file_name'), Constant(value='title')], values=[Name(id='filename', ctx=Load()), Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Name(id='filename', ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load())])), For(target=Name(id='field', ctx=Store()), iter=Name(id='fields', ctx=Load()), body=[Assign(targets=[Name(id='adjusted_field', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='field', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), attr='replace', ctx=Load()), args=[Constant(value=':'), Constant(value='')], keywords=[]), attr='replace', ctx=Load()), args=[Constant(value='#'), Constant(value='')], keywords=[])), If(test=Call(func=Attribute(value=Name(id='field', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value=':')], keywords=[]), body=[Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='search', ctx=Load()), args=[JoinedStr(values=[Constant(value='^'), FormattedValue(value=Name(id='field', ctx=Load()), conversion=-1), Constant(value='\\s+(.*)')]), Name(id='content', ctx=Load()), Attribute(value=Name(id='re', ctx=Load()), attr='MULTILINE', ctx=Load())], keywords=[])), If(test=Name(id='match', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='data', ctx=Load()), slice=Name(id='adjusted_field', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=1)], keywords=[]), attr='strip', ctx=Load()), args=[], keywords=[]))], orelse=[])], orelse=[If(test=Call(func=Attribute(value=Name(id='field', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='#')], keywords=[]), body=[Assign(targets=[Name(id='heading_text', ctx=Store())], value=Call(func=Name(id='get_heading', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='field', ctx=Load())], keywords=[])), If(test=Name(id='heading_text', ctx=Load()), body=[Assign(targets=[Name(id='field_content', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[JoinedStr(values=[Constant(value='^'), FormattedValue(value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='field', ctx=Load())], keywords=[]), conversion=-1), Constant(value='.*\\n?')]), Constant(value=''), Name(id='heading_text', ctx=Load())], keywords=[keyword(arg='flags', value=Attribute(value=Name(id='re', ctx=Load()), attr='MULTILINE', ctx=Load()))])), Assign(targets=[Name(id='field_content', ctx=Store())], value=Call(func=Attribute(value=Name(id='field_content', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='field_content', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[Constant(value='\\n\\s*\\n'), Constant(value='\n'), Name(id='field_content', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='data', ctx=Load()), slice=Name(id='adjusted_field', ctx=Load()), ctx=Store())], value=Name(id='field_content', ctx=Load()))], orelse=[])], orelse=[])])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='csv_writer', ctx=Load()), attr='writerow', ctx=Load()), args=[Name(id='data', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='CSV file created at '), FormattedValue(value=Name(id='csv_filename', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Name(id='csv_filename', ctx=Load()))], decorator_list=[]), FunctionDef(name='create_csv_matrix_from_triples', args=arguments(posonlyargs=[], args=[arg(arg='triples_text'), arg(arg='target_file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Converts multiline text of triples into a csv matrix file where each entry is the number for that row and column.\n\n    :param triples_text: string of multiline text containing rows of data separated by newlines, each row containing two strings and a number separated by commas.\n    :param target_file_path: string of the path to the target csv file.\n    :return: string of the path to the created csv file.\n    ')), Import(names=[alias(name='csv')]), ImportFrom(module='collections', names=[alias(name='defaultdict')], level=0), Assign(targets=[Name(id='triples', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='triples_text', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[]), body=[If(test=Name(id='line', ctx=Load()), body=[Assign(targets=[Name(id='items', ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=', ')], keywords=[])), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='items', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Constant(value=3)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Line does not contain exactly three items: '), FormattedValue(value=Name(id='line', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='triples', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='items', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='row_titles', ctx=Store())], value=Call(func=Name(id='sorted', ctx=Load()), args=[Call(func=Name(id='set', ctx=Load()), args=[GeneratorExp(elt=Subscript(value=Name(id='row', ctx=Load()), slice=Constant(value=0), ctx=Load()), generators=[comprehension(target=Name(id='row', ctx=Store()), iter=Name(id='triples', ctx=Load()), ifs=[], is_async=0)])], keywords=[])], keywords=[keyword(arg='key', value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='s')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Name(id='s', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])))])), Assign(targets=[Name(id='column_headers', ctx=Store())], value=Call(func=Name(id='sorted', ctx=Load()), args=[Call(func=Name(id='set', ctx=Load()), args=[GeneratorExp(elt=Subscript(value=Name(id='row', ctx=Load()), slice=Constant(value=1), ctx=Load()), generators=[comprehension(target=Name(id='row', ctx=Store()), iter=Name(id='triples', ctx=Load()), ifs=[], is_async=0)])], keywords=[])], keywords=[])), Assign(targets=[Name(id='matrix', ctx=Store())], value=Call(func=Name(id='defaultdict', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Name(id='defaultdict', ctx=Load()), args=[Name(id='int', ctx=Load())], keywords=[]))], keywords=[])), For(target=Tuple(elts=[Name(id='row_title', ctx=Store()), Name(id='col_header', ctx=Store()), Name(id='number', ctx=Store())], ctx=Store()), iter=Name(id='triples', ctx=Load()), body=[Assign(targets=[Subscript(value=Subscript(value=Name(id='matrix', ctx=Load()), slice=Name(id='row_title', ctx=Load()), ctx=Load()), slice=Name(id='col_header', ctx=Load()), ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Name(id='number', ctx=Load())], keywords=[]))], orelse=[]), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='target_file_path', ctx=Load()), Constant(value='w')], keywords=[keyword(arg='newline', value=Constant(value=''))]), optional_vars=Name(id='csvfile', ctx=Store()))], body=[Assign(targets=[Name(id='csv_writer', ctx=Store())], value=Call(func=Attribute(value=Name(id='csv', ctx=Load()), attr='writer', ctx=Load()), args=[Name(id='csvfile', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='csv_writer', ctx=Load()), attr='writerow', ctx=Load()), args=[BinOp(left=List(elts=[Constant(value='row title')], ctx=Load()), op=Add(), right=Name(id='column_headers', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='row_count', ctx=Store())], value=Constant(value=0)), For(target=Name(id='row_title', ctx=Store()), iter=Name(id='row_titles', ctx=Load()), body=[Assign(targets=[Name(id='row_data', ctx=Store())], value=ListComp(elt=Subscript(value=Subscript(value=Name(id='matrix', ctx=Load()), slice=Name(id='row_title', ctx=Load()), ctx=Load()), slice=Name(id='col_header', ctx=Load()), ctx=Load()), generators=[comprehension(target=Name(id='col_header', ctx=Store()), iter=Name(id='column_headers', ctx=Load()), ifs=[], is_async=0)])), Expr(value=Call(func=Attribute(value=Name(id='csv_writer', ctx=Load()), attr='writerow', ctx=Load()), args=[BinOp(left=List(elts=[Name(id='row_title', ctx=Load())], ctx=Load()), op=Add(), right=Name(id='row_data', ctx=Load()))], keywords=[])), AugAssign(target=Name(id='row_count', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[])]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='CSV file with '), FormattedValue(value=Name(id='row_count', ctx=Load()), conversion=-1), Constant(value=' rows created at '), FormattedValue(value=Name(id='target_file_path', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Name(id='target_file_path', ctx=Load()))], decorator_list=[])], type_ignores=[])

Module(body=[Import(names=[alias(name='os')]), Import(names=[alias(name='sys')]), Import(names=[alias(name='re')]), Import(names=[alias(name='threading')]), Import(names=[alias(name='time')]), ImportFrom(module='datetime', names=[alias(name='datetime'), alias(name='timedelta')], level=0), Import(names=[alias(name='requests')]), Import(names=[alias(name='yt_dlp', asname='youtube_dl')]), ImportFrom(module='num2words', names=[alias(name='num2words')], level=0), Import(names=[alias(name='json')]), Import(names=[alias(name='math')]), Import(names=[alias(name='mutagen')]), ImportFrom(module='wordfreq', names=[alias(name='top_n_list')], level=0), Assign(targets=[Name(id='common_english_vocab', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Name(id='top_n_list', ctx=Load()), args=[Constant(value='en'), Constant(value=3000)], keywords=[])], keywords=[])), ImportFrom(module='config', names=[alias(name='DEEPGRAM_API_KEY')], level=0), Import(names=[alias(name='warnings')]), ImportFrom(module='primary.fileops', names=[alias(name='custom_formatwarning')], level=0), Assign(targets=[Attribute(value=Name(id='warnings', ctx=Load()), attr='formatwarning', ctx=Store())], value=Name(id='custom_formatwarning', ctx=Load())), Assign(targets=[Name(id='current_dir', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='abspath', ctx=Load()), args=[Name(id='__file__', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='parent_dir', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Name(id='current_dir', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='parent_dir', ctx=Load())], keywords=[])), FunctionDef(name='download_mp3_from_youtube', args=arguments(posonlyargs=[], args=[arg(arg='url'), arg(arg='output_title')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='downloaded_audio')]), body=[Expr(value=Constant(value=" \n    Downloads an audio file from a YouTube URL and saves it as an mp3 file. Uses yt_dlp package.\n\n    :param url: string of the YouTube URL from which to download the audio.\n    :param output_title: string of the title to save the downloaded mp3 file as. defaults to 'downloaded_audio'.\n    :return: string of the path to the saved mp3 file.\n    ")), Assign(targets=[Name(id='output_file_path', ctx=Store())], value=BinOp(left=Name(id='output_title', ctx=Load()), op=Add(), right=Constant(value='.mp3'))), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='output_file_path', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='user_input', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='input', ctx=Load()), args=[Constant(value="Audio file already exists. Enter 'y' or 'yes' to download again and overwrite, or any other key to skip: ")], keywords=[]), attr='lower', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='user_input', ctx=Load()), ops=[NotIn()], comparators=[List(elts=[Constant(value='y'), Constant(value='yes')], ctx=Load())]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Skipping download.')], keywords=[])), Return(value=Name(id='output_file_path', ctx=Load()))], orelse=[])], orelse=[]), Assign(targets=[Name(id='ydl_opts', ctx=Store())], value=Dict(keys=[Constant(value='format'), Constant(value='postprocessors'), Constant(value='outtmpl')], values=[Constant(value='bestaudio/best'), List(elts=[Dict(keys=[Constant(value='key'), Constant(value='preferredcodec'), Constant(value='preferredquality')], values=[Constant(value='FFmpegExtractAudio'), Constant(value='mp3'), Constant(value='192')])], ctx=Load()), Name(id='output_title', ctx=Load())])), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='youtube_dl', ctx=Load()), attr='YoutubeDL', ctx=Load()), args=[Name(id='ydl_opts', ctx=Load())], keywords=[]), optional_vars=Name(id='ydl', ctx=Store()))], body=[Expr(value=Call(func=Attribute(value=Name(id='ydl', ctx=Load()), attr='download', ctx=Load()), args=[List(elts=[Name(id='url', ctx=Load())], ctx=Load())], keywords=[]))]), Return(value=Name(id='output_file_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_youtube_title_length', args=arguments(posonlyargs=[], args=[arg(arg='url')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=' \n    Retrieves the title and duration of a youtube video in a formatted timestamp. Uses yt_dlp package.\n\n    :param url: string of the youtube url to retrieve information from.\n    :return: tuple containing the video title and its duration as a string in a formatted timestamp.\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='tune_timestamp')], level=0), Assign(targets=[Name(id='ydl_opts', ctx=Store())], value=Dict(keys=[Constant(value='quiet'), Constant(value='skip_download'), Constant(value='format'), Constant(value='postprocessors')], values=[Constant(value=True), Constant(value=True), Constant(value='bestaudio/best'), List(elts=[Dict(keys=[Constant(value='key'), Constant(value='preferredcodec'), Constant(value='preferredquality')], values=[Constant(value='FFmpegExtractAudio'), Constant(value='mp3'), Constant(value='192')])], ctx=Load())])), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='youtube_dl', ctx=Load()), attr='YoutubeDL', ctx=Load()), args=[Name(id='ydl_opts', ctx=Load())], keywords=[]), optional_vars=Name(id='ydl', ctx=Store()))], body=[Assign(targets=[Name(id='info_dict', ctx=Store())], value=Call(func=Attribute(value=Name(id='ydl', ctx=Load()), attr='extract_info', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[keyword(arg='download', value=Constant(value=False))])), Assign(targets=[Name(id='video_title', ctx=Store())], value=Call(func=Attribute(value=Name(id='info_dict', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='title'), Constant(value='Unknown Title')], keywords=[])), Assign(targets=[Name(id='video_duration', ctx=Store())], value=Call(func=Attribute(value=Name(id='info_dict', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='duration'), Constant(value=0)], keywords=[])), Assign(targets=[Name(id='video_length', ctx=Store())], value=Call(func=Name(id='tune_timestamp', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='timedelta', ctx=Load()), args=[], keywords=[keyword(arg='seconds', value=Name(id='video_duration', ctx=Load()))])], keywords=[])], keywords=[])), Return(value=Tuple(elts=[Name(id='video_title', ctx=Load()), Name(id='video_length', ctx=Load())], ctx=Load()))])], decorator_list=[]), FunctionDef(name='download_link_list_to_mp3s', args=arguments(posonlyargs=[], args=[arg(arg='links'), arg(arg='audio_inbox_path')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='data/audio_inbox')]), body=[Expr(value=Constant(value='\n    Downloads a list of youtube links as mp3 files to a specified directory and stores the link-title pairs. Uses yt_dlp package.\n    Calls download_mp3_from_youtube\n\n    :param links: list of youtube links to be downloaded.\n    :param audio_inbox_path: string of the directory path where the audio files will be saved.\n    :return: dictionary mapping each youtube link to its corresponding title.\n    ')), Assign(targets=[Name(id='link_title_pairs', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='link', ctx=Store()), iter=Name(id='links', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='title', ctx=Store()), Name(id='length', ctx=Store())], ctx=Store())], value=Call(func=Name(id='get_youtube_title_length', ctx=Load()), args=[Name(id='link', ctx=Load())], keywords=[])), Assign(targets=[Name(id='title', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='title', ctx=Load()), attr='rsplit', ctx=Load()), args=[Constant(value='.'), Constant(value=1)], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Subscript(value=Name(id='link_title_pairs', ctx=Load()), slice=Name(id='link', ctx=Load()), ctx=Store())], value=Name(id='title', ctx=Load())), Expr(value=Call(func=Name(id='download_mp3_from_youtube', ctx=Load()), args=[Name(id='link', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='audio_inbox_path', ctx=Load()), Name(id='title', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=Name(id='link_title_pairs', ctx=Load()))], decorator_list=[]), FunctionDef(name='download_youtube_subtitles_url', args=arguments(posonlyargs=[], args=[arg(arg='subtitle_url')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Downloads and extracts subtitle text from a given YouTube subtitle URL.\n    Helper function to that is called from get_youtube_subtitles\n    \n    :param subtitle_url: string of the url from which subtitles are to be downloaded.\n    :return: string of the extracted subtitle text, spaces between segments and stripped of new lines.\n    ')), Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Attribute(value=Name(id='requests', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='subtitle_url', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='response', ctx=Load()), attr='raise_for_status', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='subtitle_data', ctx=Store())], value=Call(func=Attribute(value=Name(id='response', ctx=Load()), attr='json', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='subtitle_text', ctx=Store())], value=Constant(value='')), For(target=Name(id='event', ctx=Store()), iter=Subscript(value=Name(id='subtitle_data', ctx=Load()), slice=Constant(value='events'), ctx=Load()), body=[If(test=Compare(left=Constant(value='segs'), ops=[In()], comparators=[Name(id='event', ctx=Load())]), body=[For(target=Name(id='seg', ctx=Store()), iter=Subscript(value=Name(id='event', ctx=Load()), slice=Constant(value='segs'), ctx=Load()), body=[If(test=Compare(left=Constant(value='utf8'), ops=[In()], comparators=[Name(id='seg', ctx=Load())]), body=[AugAssign(target=Name(id='subtitle_text', ctx=Store()), op=Add(), value=BinOp(left=Subscript(value=Name(id='seg', ctx=Load()), slice=Constant(value='utf8'), ctx=Load()), op=Add(), right=Constant(value=' ')))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='subtitle_text', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='\n'), Constant(value=' ')], keywords=[]), attr='strip', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='get_youtube_subtitles', args=arguments(posonlyargs=[], args=[arg(arg='url')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Retrieves English subtitles for a given YouTube video URL if available. Uses yt_dlp package.\n    \n    :param url: string of the youtube video url.\n    :return: subtitles as a string if found, otherwise None.\n    ')), Assign(targets=[Name(id='ydl_opts', ctx=Store())], value=Dict(keys=[Constant(value='quiet'), Constant(value='skip_download'), Constant(value='writesubtitles'), Constant(value='writeautomaticsub'), Constant(value='subtitleslangs')], values=[Constant(value=True), Constant(value=True), Constant(value=True), Constant(value=True), List(elts=[Constant(value='en')], ctx=Load())])), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='youtube_dl', ctx=Load()), attr='YoutubeDL', ctx=Load()), args=[Name(id='ydl_opts', ctx=Load())], keywords=[]), optional_vars=Name(id='ydl', ctx=Store()))], body=[Assign(targets=[Name(id='info_dict', ctx=Store())], value=Call(func=Attribute(value=Name(id='ydl', ctx=Load()), attr='extract_info', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[keyword(arg='download', value=Constant(value=False))])), Assign(targets=[Name(id='subtitles', ctx=Store())], value=Call(func=Attribute(value=Name(id='info_dict', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='subtitles'), Dict(keys=[], values=[])], keywords=[])), Assign(targets=[Name(id='auto_captions', ctx=Store())], value=Call(func=Attribute(value=Name(id='info_dict', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='automatic_captions'), Dict(keys=[], values=[])], keywords=[])), Assign(targets=[Name(id='transcript_info', ctx=Store())], value=IfExp(test=Name(id='subtitles', ctx=Load()), body=Name(id='subtitles', ctx=Load()), orelse=Name(id='auto_captions', ctx=Load()))), If(test=Call(func=Attribute(value=Name(id='transcript_info', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='en')], keywords=[]), body=[Assign(targets=[Name(id='subtitles_url', ctx=Store())], value=Subscript(value=Subscript(value=Subscript(value=Name(id='transcript_info', ctx=Load()), slice=Constant(value='en'), ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Constant(value='url'), ctx=Load())), Return(value=Call(func=Name(id='download_youtube_subtitles_url', ctx=Load()), args=[Name(id='subtitles_url', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='No English subtitles found.')], keywords=[])), Return(value=Constant(value=None))])])], decorator_list=[]), FunctionDef(name='get_youtube_all', args=arguments(posonlyargs=[], args=[arg(arg='url')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Retrieves all available information from a YouTube video URL, including title, length, chapters, description, and transcript. Uses yt_dlp package.\n    \n    :param url: string of the youtube video url.\n    :return: dictionary with video details or None if the URL is invalid.\n    ')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='is_valid_youtube_url', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Invalid YouTube URL: '), FormattedValue(value=Name(id='url', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='ydl_opts', ctx=Store())], value=Dict(keys=[Constant(value='quiet'), Constant(value='skip_download'), Constant(value='writesubtitles'), Constant(value='writeautomaticsub'), Constant(value='subtitleslangs')], values=[Constant(value=True), Constant(value=True), Constant(value=True), Constant(value=True), List(elts=[Constant(value='en')], ctx=Load())])), Assign(targets=[Name(id='transcript_text', ctx=Store())], value=Constant(value=None)), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='youtube_dl', ctx=Load()), attr='YoutubeDL', ctx=Load()), args=[Name(id='ydl_opts', ctx=Load())], keywords=[]), optional_vars=Name(id='ydl', ctx=Store()))], body=[Assign(targets=[Name(id='info_dict', ctx=Store())], value=Call(func=Attribute(value=Name(id='ydl', ctx=Load()), attr='extract_info', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[keyword(arg='download', value=Constant(value=False))])), Assign(targets=[Name(id='video_title', ctx=Store())], value=Call(func=Attribute(value=Name(id='info_dict', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='title'), Constant(value='Unknown Title')], keywords=[])), Assign(targets=[Name(id='video_channel', ctx=Store())], value=Call(func=Attribute(value=Name(id='info_dict', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='uploader'), Constant(value='Unknown Channel')], keywords=[])), Assign(targets=[Name(id='video_date', ctx=Store())], value=Call(func=Attribute(value=Name(id='info_dict', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='upload_date'), Constant(value='Unknown Date')], keywords=[])), Assign(targets=[Name(id='video_duration', ctx=Store())], value=Call(func=Attribute(value=Name(id='info_dict', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='duration'), Constant(value=0)], keywords=[])), Assign(targets=[Name(id='video_length', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='timedelta', ctx=Load()), args=[], keywords=[keyword(arg='seconds', value=Name(id='video_duration', ctx=Load()))])], keywords=[])), Assign(targets=[Name(id='chapters', ctx=Store())], value=Call(func=Attribute(value=Name(id='info_dict', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='chapters'), List(elts=[], ctx=Load())], keywords=[])), If(test=Name(id='chapters', ctx=Load()), body=[Assign(targets=[Name(id='formatted_chapters', ctx=Store())], value=ListComp(elt=Dict(keys=[Constant(value='start_time'), Constant(value='title')], values=[Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='timedelta', ctx=Load()), args=[], keywords=[keyword(arg='seconds', value=Subscript(value=Name(id='chap', ctx=Load()), slice=Constant(value='start_time'), ctx=Load()))])], keywords=[]), Subscript(value=Name(id='chap', ctx=Load()), slice=Constant(value='title'), ctx=Load())]), generators=[comprehension(target=Name(id='chap', ctx=Store()), iter=Name(id='chapters', ctx=Load()), ifs=[], is_async=0)]))], orelse=[Assign(targets=[Name(id='formatted_chapters', ctx=Store())], value=Constant(value=''))]), Assign(targets=[Name(id='description', ctx=Store())], value=Call(func=Attribute(value=Name(id='info_dict', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='description'), Constant(value='')], keywords=[])), Assign(targets=[Name(id='subtitles', ctx=Store())], value=Call(func=Attribute(value=Name(id='info_dict', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='subtitles'), Dict(keys=[], values=[])], keywords=[])), Assign(targets=[Name(id='auto_captions', ctx=Store())], value=Call(func=Attribute(value=Name(id='info_dict', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='automatic_captions'), Dict(keys=[], values=[])], keywords=[])), If(test=Name(id='subtitles', ctx=Load()), body=[Assign(targets=[Name(id='transcript_info', ctx=Store())], value=Name(id='subtitles', ctx=Load())), Assign(targets=[Name(id='transcript_source', ctx=Store())], value=Constant(value='subtitles'))], orelse=[Assign(targets=[Name(id='transcript_info', ctx=Store())], value=Name(id='auto_captions', ctx=Load())), Assign(targets=[Name(id='transcript_source', ctx=Store())], value=Constant(value='auto-captions'))]), If(test=Call(func=Attribute(value=Name(id='transcript_info', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='en')], keywords=[]), body=[Assign(targets=[Name(id='subtitles_url', ctx=Store())], value=Subscript(value=Subscript(value=Subscript(value=Name(id='transcript_info', ctx=Load()), slice=Constant(value='en'), ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Constant(value='url'), ctx=Load())), Assign(targets=[Name(id='transcript_text', ctx=Store())], value=Call(func=Name(id='download_youtube_subtitles_url', ctx=Load()), args=[Name(id='subtitles_url', ctx=Load())], keywords=[])), Assign(targets=[Name(id='transcript_text', ctx=Store())], value=Call(func=Attribute(value=Constant(value=' '), attr='join', ctx=Load()), args=[Call(func=Attribute(value=Name(id='transcript_text', ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[])], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='No English subtitles found.')], keywords=[]))]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='For YouTube video title: '), FormattedValue(value=Name(id='video_title', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='extracted_features', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Name(id='formatted_chapters', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='extracted_features', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='chapters')], keywords=[]))], orelse=[]), If(test=Name(id='description', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='extracted_features', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='description')], keywords=[]))], orelse=[]), If(test=Name(id='transcript_source', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='extracted_features', ctx=Load()), attr='append', ctx=Load()), args=[JoinedStr(values=[Constant(value='transcript from '), FormattedValue(value=Name(id='transcript_source', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='  extracted the following features: '), FormattedValue(value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Name(id='extracted_features', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[])), Return(value=Dict(keys=[Constant(value='title'), Constant(value='channel'), Constant(value='date'), Constant(value='length'), Constant(value='chapters'), Constant(value='description'), Constant(value='transcript'), Constant(value='transcript source')], values=[Name(id='video_title', ctx=Load()), Name(id='video_channel', ctx=Load()), Name(id='video_date', ctx=Load()), Name(id='video_length', ctx=Load()), Name(id='formatted_chapters', ctx=Load()), Name(id='description', ctx=Load()), BoolOp(op=Or(), values=[Name(id='transcript_text', ctx=Load()), Constant(value='No transcript found')]), Name(id='transcript_source', ctx=Load())]))])], decorator_list=[]), FunctionDef(name='is_valid_youtube_url', args=arguments(posonlyargs=[], args=[arg(arg='url')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=' \n    Determine if a string of url is a valid YouTube URL by attempting to fetch video info using the yt_dlp package.\n\n    :param url: string of url to be validated.\n    :return: boolean where true if the url is valid, false otherwise.\n    ')), Assign(targets=[Name(id='ydl_opts', ctx=Store())], value=Dict(keys=[Constant(value='quiet'), Constant(value='skip_download')], values=[Constant(value=True), Constant(value=True)])), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='youtube_dl', ctx=Load()), attr='YoutubeDL', ctx=Load()), args=[Name(id='ydl_opts', ctx=Load())], keywords=[]), optional_vars=Name(id='ydl', ctx=Store()))], body=[Try(body=[Expr(value=Call(func=Attribute(value=Name(id='ydl', ctx=Load()), attr='extract_info', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[keyword(arg='download', value=Constant(value=False))])), Return(value=Constant(value=True))], handlers=[ExceptHandler(type=Attribute(value=Attribute(value=Name(id='youtube_dl', ctx=Load()), attr='utils', ctx=Load()), attr='DownloadError', ctx=Load()), body=[Return(value=Constant(value=False))]), ExceptHandler(type=Attribute(value=Attribute(value=Name(id='youtube_dl', ctx=Load()), attr='utils', ctx=Load()), attr='ExtractorError', ctx=Load()), body=[Return(value=Constant(value=False))]), ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='ERROR in is_valid_youtube_url occurred: '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Constant(value=False))])], orelse=[], finalbody=[])])], decorator_list=[]), FunctionDef(name='create_youtube_md', args=arguments(posonlyargs=[], args=[arg(arg='url'), arg(arg='title_or_path')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n    Generates a markdown file containing metadata, chapters, description, and transcript from a YouTube video.\n\n    :param url: string of the url to be processed.\n    :param title_or_path: string of the title or path for the markdown file, defaults to None.\n    :return: string of the path to the created markdown file.\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='create_full_path'), alias(name='set_metadata_field')], level=0), ImportFrom(module='primary.fileops', names=[alias(name='write_metadata_and_content'), alias(name='add_timestamp_links')], level=0), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='is_valid_youtube_url', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='VALUE ERROR - invalid YouTube URL: '), FormattedValue(value=Name(id='url', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='title_or_path', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Tuple(elts=[Name(id='title_or_path', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Name(id='get_youtube_title_length', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='default_folder', ctx=Store())], value=Constant(value='data/audio_inbox')), Assign(targets=[Name(id='suffix_ext', ctx=Store())], value=Constant(value='_yt.md')), Assign(targets=[Name(id='yt_md_file_path', ctx=Store())], value=Call(func=Name(id='create_full_path', ctx=Load()), args=[Name(id='title_or_path', ctx=Load()), Name(id='suffix_ext', ctx=Load()), Name(id='default_folder', ctx=Load())], keywords=[])), Assign(targets=[Name(id='yt_info_dict', ctx=Store())], value=Call(func=Name(id='get_youtube_all', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[])), Assign(targets=[Name(id='yt_content', ctx=Store())], value=Constant(value='## content\n\n')), If(test=Subscript(value=Name(id='yt_info_dict', ctx=Load()), slice=Constant(value='chapters'), ctx=Load()), body=[AugAssign(target=Name(id='yt_content', ctx=Store()), op=Add(), value=BinOp(left=Constant(value='### chapters (youtube)\n\n'), op=Add(), right=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[ListComp(elt=JoinedStr(values=[FormattedValue(value=Subscript(value=Name(id='chap', ctx=Load()), slice=Constant(value='start_time'), ctx=Load()), conversion=-1), Constant(value=' - '), FormattedValue(value=Subscript(value=Name(id='chap', ctx=Load()), slice=Constant(value='title'), ctx=Load()), conversion=-1)]), generators=[comprehension(target=Name(id='chap', ctx=Store()), iter=Subscript(value=Name(id='yt_info_dict', ctx=Load()), slice=Constant(value='chapters'), ctx=Load()), ifs=[], is_async=0)])], keywords=[]))), AugAssign(target=Name(id='yt_content', ctx=Store()), op=Add(), value=Constant(value='\n\n'))], orelse=[]), AugAssign(target=Name(id='yt_content', ctx=Store()), op=Add(), value=BinOp(left=BinOp(left=Constant(value='### description (youtube)\n\n'), op=Add(), right=Subscript(value=Name(id='yt_info_dict', ctx=Load()), slice=Constant(value='description'), ctx=Load())), op=Add(), right=Constant(value='\n\n'))), AugAssign(target=Name(id='yt_content', ctx=Store()), op=Add(), value=BinOp(left=Constant(value='### transcript (youtube)\n\n'), op=Add(), right=Subscript(value=Name(id='yt_info_dict', ctx=Load()), slice=Constant(value='transcript'), ctx=Load()))), Assign(targets=[Name(id='yt_metadata', ctx=Store())], value=Constant(value='## metadata\n')), Assign(targets=[Name(id='date_today', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='datetime', ctx=Load()), attr='now', ctx=Load()), args=[], keywords=[]), attr='strftime', ctx=Load()), args=[Constant(value='%m-%d-%Y')], keywords=[])), Assign(targets=[Name(id='yt_metadata', ctx=Store())], value=Call(func=Name(id='set_metadata_field', ctx=Load()), args=[Name(id='yt_metadata', ctx=Load()), Constant(value='last updated'), BinOp(left=Name(id='date_today', ctx=Load()), op=Add(), right=Constant(value=' Created'))], keywords=[])), Assign(targets=[Name(id='yt_metadata', ctx=Store())], value=Call(func=Name(id='set_metadata_field', ctx=Load()), args=[Name(id='yt_metadata', ctx=Load()), Constant(value='link'), Name(id='url', ctx=Load())], keywords=[])), Assign(targets=[Name(id='yt_metadata', ctx=Store())], value=Call(func=Name(id='set_metadata_field', ctx=Load()), args=[Name(id='yt_metadata', ctx=Load()), Constant(value='youtube title'), Subscript(value=Name(id='yt_info_dict', ctx=Load()), slice=Constant(value='title'), ctx=Load())], keywords=[])), Assign(targets=[Name(id='yt_metadata', ctx=Store())], value=Call(func=Name(id='set_metadata_field', ctx=Load()), args=[Name(id='yt_metadata', ctx=Load()), Constant(value='youtube transcript source'), Subscript(value=Name(id='yt_info_dict', ctx=Load()), slice=Constant(value='transcript source'), ctx=Load())], keywords=[])), Assign(targets=[Name(id='yt_metadata', ctx=Store())], value=Call(func=Name(id='set_metadata_field', ctx=Load()), args=[Name(id='yt_metadata', ctx=Load()), Constant(value='length'), Subscript(value=Name(id='yt_info_dict', ctx=Load()), slice=Constant(value='length'), ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='write_metadata_and_content', ctx=Load()), args=[Name(id='yt_md_file_path', ctx=Load()), Name(id='yt_metadata', ctx=Load()), Name(id='yt_content', ctx=Load())], keywords=[keyword(arg='overwrite', value=Constant(value='yes'))])), Expr(value=Call(func=Name(id='add_timestamp_links', ctx=Load()), args=[Name(id='yt_md_file_path', ctx=Load())], keywords=[])), Return(value=Name(id='yt_md_file_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='create_youtube_md_from_file_link', args=arguments(posonlyargs=[], args=[arg(arg='md_file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Creates a YouTube markdown file from a given file path by extracting the YouTube link from the file's metadata.\n    \n    :param md_file_path: string of the path to the markdown file containing the YouTube link in its metadata.\n    :return: string of the path to the created YouTube markdown file.\n    ")), ImportFrom(module='primary.fileops', names=[alias(name='sub_suffix_in_str'), alias(name='read_metadata_and_content'), alias(name='read_metadata_field_from_file')], level=0), Assign(targets=[Name(id='suffix_new', ctx=Store())], value=Constant(value='_yt')), Assign(targets=[Tuple(elts=[Name(id='metadata', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Name(id='read_metadata_and_content', ctx=Load()), args=[Name(id='md_file_path', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='metadata', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='VALUE ERROR - metadata is None')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='metadata_result', ctx=Store())], value=Call(func=Name(id='read_metadata_field_from_file', ctx=Load()), args=[Name(id='md_file_path', ctx=Load()), Constant(value='link')], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='metadata_result', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Subscript(value=Name(id='metadata_result', ctx=Load()), slice=Constant(value=1), ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value="VALUE ERROR - 'link' metadata field is missing or None in the file: "), FormattedValue(value=Name(id='md_file_path', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='_', ctx=Store()), Name(id='link', ctx=Store())], ctx=Store())], value=Name(id='metadata_result', ctx=Load())), Assign(targets=[Name(id='yt_file_path', ctx=Store())], value=Call(func=Name(id='sub_suffix_in_str', ctx=Load()), args=[Name(id='md_file_path', ctx=Load())], keywords=[keyword(arg='suffix_sub', value=Name(id='suffix_new', ctx=Load()))])), Assign(targets=[Name(id='yt_file_path', ctx=Store())], value=Call(func=Name(id='create_youtube_md', ctx=Load()), args=[Name(id='link', ctx=Load()), Name(id='yt_file_path', ctx=Load())], keywords=[])), Return(value=Name(id='yt_file_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='extract_feature_from_youtube_md', args=arguments(posonlyargs=[], args=[arg(arg='yt_md_file_path'), arg(arg='feature')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Extracts a specified feature from a YouTube markdown file and returns it as a string.\n\n    :param yt_md_file_path: string of the path to the markdown file from which the feature is to be extracted.\n    :param feature: string of the feature to be extracted (e.g., 'chapters', 'description', 'transcript').\n    :return: string of the extracted text under the specified feature\n    ")), Try(body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='yt_md_file_path', ctx=Load()), Constant(value='r')], keywords=[keyword(arg='encoding', value=Constant(value='utf-8'))]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='lines', ctx=Store())], value=Call(func=Attribute(value=Name(id='file', ctx=Load()), attr='readlines', ctx=Load()), args=[], keywords=[]))]), Assign(targets=[Name(id='feature_section_found', ctx=Store())], value=Constant(value=False)), Assign(targets=[Name(id='extracted_feature', ctx=Store())], value=Constant(value='')), Assign(targets=[Name(id='feature_heading_pattern', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[BinOp(left=Constant(value='^#+\\s*'), op=Add(), right=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='feature', ctx=Load())], keywords=[])), Attribute(value=Name(id='re', ctx=Load()), attr='IGNORECASE', ctx=Load())], keywords=[])), For(target=Name(id='line', ctx=Store()), iter=Name(id='lines', ctx=Load()), body=[If(test=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='feature_heading_pattern', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[]), Name(id='feature_section_found', ctx=Load())]), body=[If(test=BoolOp(op=And(), values=[Call(func=Attribute(value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), attr='startswith', ctx=Load()), args=[Constant(value='#')], keywords=[]), Name(id='feature_section_found', ctx=Load())]), body=[Break()], orelse=[]), Assign(targets=[Name(id='feature_section_found', ctx=Store())], value=Constant(value=True)), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='feature_heading_pattern', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])), body=[AugAssign(target=Name(id='extracted_feature', ctx=Store()), op=Add(), value=Name(id='line', ctx=Load()))], orelse=[])], orelse=[])], orelse=[]), If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Name(id='feature_section_found', ctx=Load())), Compare(left=Name(id='extracted_feature', ctx=Load()), ops=[Eq()], comparators=[Constant(value='')])]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value="Feature '"), FormattedValue(value=Name(id='feature', ctx=Load()), conversion=-1), Constant(value="' not found in YouTube markdown file.")])], keywords=[])), Return(value=Constant(value=None))], orelse=[Return(value=BinOp(left=Call(func=Attribute(value=Name(id='extracted_feature', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), op=Add(), right=Constant(value='\n\n')))])], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Error extracting '), FormattedValue(value=Name(id='feature', ctx=Load()), conversion=-1), Constant(value=' from '), FormattedValue(value=Name(id='yt_md_file_path', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), ImportFrom(module='deepgram', names=[alias(name='DeepgramClient'), alias(name='PrerecordedOptions')], level=0), FunctionDef(name='test_deepgram_client', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Tests the Deepgram client initialization with the provided API key and prints a success or failure message.\n    Raises ValueError if test fails.\n    ')), Try(body=[Assign(targets=[Name(id='test_deepgram_client', ctx=Store())], value=Call(func=Name(id='DeepgramClient', ctx=Load()), args=[Name(id='DEEPGRAM_API_KEY', ctx=Load())], keywords=[])), If(test=Name(id='test_deepgram_client', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Successfully created Deepgram Client and accessed the DeepGram API key.')], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Failed to create the Deepgram Client and/or access the DeepGram API key.')], keywords=[]))])], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='VALUE ERROR in test of Deepgram client: '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='get_media_length', args=arguments(posonlyargs=[], args=[arg(arg='file_path_or_url')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Retrieves the length (duration) of a media file or a YouTube video.\n    For a local file, it returns the duration in seconds.\n    For a YouTube video, it returns the duration in our tuned timestamp format.\n\n    :param file_path_or_url: Path to a local media file or a URL to a YouTube video.\n    :return: length (duration) of the media in seconds (for local files) or in our tuned timestamp format (for YouTube videos).\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='tune_timestamp')], level=0), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='catch_warnings', ctx=Load()), args=[], keywords=[]))], body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='simplefilter', ctx=Load()), args=[Constant(value='ignore')], keywords=[])), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Attribute(value=Name(id='os', ctx=Load()), attr='devnull', ctx=Load()), Constant(value='w')], keywords=[]), optional_vars=Name(id='fnull', ctx=Store()))], body=[Assign(targets=[Attribute(value=Name(id='sys', ctx=Load()), attr='stderr', ctx=Store())], value=Name(id='fnull', ctx=Load())), Try(body=[If(test=Call(func=Name(id='is_valid_youtube_url', ctx=Load()), args=[Name(id='file_path_or_url', ctx=Load())], keywords=[]), body=[Assign(targets=[Tuple(elts=[Name(id='_', ctx=Store()), Name(id='video_length', ctx=Store())], ctx=Store())], value=Call(func=Name(id='get_youtube_title_length', ctx=Load()), args=[Name(id='file_path_or_url', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='tune_timestamp', ctx=Load()), args=[Name(id='video_length', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='file_path_or_url', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='audio', ctx=Store())], value=Call(func=Attribute(value=Name(id='mutagen', ctx=Load()), attr='File', ctx=Load()), args=[Name(id='file_path_or_url', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='audio', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Call(func=Name(id='hasattr', ctx=Load()), args=[Attribute(value=Name(id='audio', ctx=Load()), attr='info', ctx=Load()), Constant(value='length')], keywords=[])]), body=[Return(value=Call(func=Name(id='tune_timestamp', ctx=Load()), args=[Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='timedelta', ctx=Load()), args=[], keywords=[keyword(arg='seconds', value=Call(func=Name(id='int', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='audio', ctx=Load()), attr='info', ctx=Load()), attr='length', ctx=Load())], keywords=[]))])], keywords=[])], keywords=[]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Could not determine the length of the audio file.')], keywords=[]))])], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Invalid YouTube URL or file path.')], keywords=[]))])])], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='An error occurred while retrieving media length: '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[]))])], orelse=[], finalbody=[Assign(targets=[Attribute(value=Name(id='sys', ctx=Load()), attr='stderr', ctx=Store())], value=Attribute(value=Name(id='sys', ctx=Load()), attr='__stderr__', ctx=Load()))])])])], decorator_list=[]), FunctionDef(name='add_link_to_json', args=arguments(posonlyargs=[], args=[arg(arg='json_file_path'), arg(arg='link')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=" \n    Add a hyperlink to the JSON file under the 'metadata' section.\n\n    :param json_file_path: string, the path to the JSON file to be modified.\n    :param link: string, the hyperlink to be added to the JSON file.\n    :return: tuple, the path to the modified JSON file and None if successful, or None and an exception if an error occurs.\n    ")), Try(body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='json_file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='data', ctx=Store())], value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='load', ctx=Load()), args=[Name(id='file', ctx=Load())], keywords=[]))]), If(test=Compare(left=Constant(value='metadata'), ops=[In()], comparators=[Name(id='data', ctx=Load())]), body=[Assign(targets=[Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='metadata'), ctx=Store())], value=Dict(keys=[Constant(value='link'), None], values=[Name(id='link', ctx=Load()), Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='metadata'), ctx=Load())]))], orelse=[Assign(targets=[Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='metadata'), ctx=Store())], value=Dict(keys=[Constant(value='link')], values=[Name(id='link', ctx=Load())]))]), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='json_file_path', ctx=Load()), Constant(value='w')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Expr(value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='dump', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='file', ctx=Load())], keywords=[keyword(arg='indent', value=Constant(value=4))]))]), Return(value=Tuple(elts=[Name(id='json_file_path', ctx=Load()), Constant(value=None)], ctx=Load()))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Error processing file '), FormattedValue(value=Name(id='json_file_path', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Tuple(elts=[Constant(value=None), Name(id='e', ctx=Load())], ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='get_link_from_json', args=arguments(posonlyargs=[], args=[arg(arg='json_file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=" \n    Retrieve the hyperlink from the 'metadata' section of a JSON file.\n\n    :param json_file_path: string, the path to the JSON file from which the hyperlink is to be retrieved.\n    :return: string or None, the hyperlink if found in the JSON file's 'metadata' section, otherwise None.\n    ")), Try(body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='json_file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='data', ctx=Store())], value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='load', ctx=Load()), args=[Name(id='file', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='link', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='metadata'), Dict(keys=[], values=[])], keywords=[]), attr='get', ctx=Load()), args=[Constant(value='link'), Constant(value=None)], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Error extracting link from '), FormattedValue(value=Name(id='json_file_path', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='link', ctx=Store())], value=Constant(value=None))])], orelse=[], finalbody=[]), Return(value=Name(id='link', ctx=Load()))], decorator_list=[]), FunctionDef(name='transcribe_deepgram', args=arguments(posonlyargs=[], args=[arg(arg='audio_file_path'), arg(arg='model')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=' \n    Calls the Deepgram API to transcribe the given audio file using the specified Deepgram model.\n\n    :param audio_file_path: path to the audio file to be transcribed.\n    :param model: the Deepgram model to use for transcription, accpets deepgram api call model or our suffix version (see below).\n    :return: a dictionary containing the transcription results.\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='get_current_datetime_humanfriendly'), alias(name='convert_to_epoch_seconds'), alias(name='get_elapsed_seconds'), alias(name='convert_seconds_to_timestamp'), alias(name='convert_timestamp_to_seconds')], level=0), Assign(targets=[Name(id='MIMETYPES', ctx=Store())], value=List(elts=[Constant(value='mp3'), Constant(value='mp4'), Constant(value='mp2'), Constant(value='aac'), Constant(value='wav'), Constant(value='flac'), Constant(value='pcm'), Constant(value='m4a'), Constant(value='ogg'), Constant(value='opus'), Constant(value='webm')], ctx=Load())), Assign(targets=[Name(id='deepgram', ctx=Store())], value=Call(func=Name(id='DeepgramClient', ctx=Load()), args=[Name(id='DEEPGRAM_API_KEY', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='audio_file_path', ctx=Load()), attr='endswith', ctx=Load()), args=[Name(id='ext', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='ext', ctx=Store()), iter=Name(id='MIMETYPES', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='File '), FormattedValue(value=Name(id='audio_file_path', ctx=Load()), conversion=-1), Constant(value=' does not have a supported MIME type.')])], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='model', ctx=Load()), ops=[Eq()], comparators=[Constant(value='nova-2-general')]), body=[Assign(targets=[Name(id='suffix', ctx=Store())], value=Constant(value='_nova2gen'))], orelse=[If(test=Compare(left=Name(id='model', ctx=Load()), ops=[Eq()], comparators=[Constant(value='nova-2-meeting')]), body=[Assign(targets=[Name(id='suffix', ctx=Store())], value=Constant(value='_nova2meet'))], orelse=[If(test=Compare(left=Name(id='model', ctx=Load()), ops=[Eq()], comparators=[Constant(value='enhanced-meeting')]), body=[Assign(targets=[Name(id='suffix', ctx=Store())], value=Constant(value='_enhmeet'))], orelse=[If(test=Compare(left=Name(id='model', ctx=Load()), ops=[Eq()], comparators=[Constant(value='whisper-medium')]), body=[Assign(targets=[Name(id='suffix', ctx=Store())], value=Constant(value='_dgwhspm'))], orelse=[If(test=Compare(left=Name(id='model', ctx=Load()), ops=[Eq()], comparators=[Constant(value='whisper-large')]), body=[Assign(targets=[Name(id='suffix', ctx=Store())], value=Constant(value='_dgwhspl'))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value="Invalid or absent DeepGram model ('nova-2-general' 'nova-2-meeting' 'enhanced-meeting' 'whisper-medium' 'whisper-large').")], keywords=[]))])])])])]), Assign(targets=[Name(id='json_file_path', ctx=Store())], value=Constant(value=None)), Try(body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Deepgram transcribing model: '), FormattedValue(value=Name(id='model', ctx=Load()), conversion=-1), Constant(value='  file : '), FormattedValue(value=Name(id='audio_file_path', ctx=Load()), conversion=-1)])], keywords=[])), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='audio_file_path', ctx=Load()), Constant(value='rb')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='buffer_data', ctx=Store())], value=Call(func=Attribute(value=Name(id='file', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))]), Assign(targets=[Name(id='file_extension', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='audio_file_path', ctx=Load()), attr='rsplit', ctx=Load()), args=[Constant(value='.'), Constant(value=1)], keywords=[]), slice=Constant(value=1), ctx=Load())), Assign(targets=[Name(id='mimetype', ctx=Store())], value=JoinedStr(values=[Constant(value='audio/'), FormattedValue(value=Name(id='file_extension', ctx=Load()), conversion=-1)])), AnnAssign(target=Name(id='payload', ctx=Store()), annotation=Name(id='FileSource', ctx=Load()), value=Dict(keys=[Constant(value='buffer'), Constant(value='mimetype')], values=[Name(id='buffer_data', ctx=Load()), Name(id='mimetype', ctx=Load())]), simple=1), Assign(targets=[Name(id='options', ctx=Store())], value=Dict(keys=[Constant(value='punctuate'), Constant(value='diarize'), Constant(value='model'), Constant(value='intents'), Constant(value='sentiment'), Constant(value='summarize'), Constant(value='measurements'), Constant(value='smart_format'), Constant(value='topics')], values=[Constant(value=True), Constant(value=True), Name(id='model', ctx=Load()), Constant(value=True), Constant(value=True), Constant(value=True), Constant(value=True), Constant(value=True), Constant(value=True)])), Assign(targets=[Name(id='audio_length', ctx=Store())], value=Call(func=Name(id='get_media_length', ctx=Load()), args=[Name(id='audio_file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='get_current_datetime_humanfriendly', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Start Syncronous Deepgram Transcription at '), FormattedValue(value=Name(id='start_time', ctx=Load()), conversion=-1), Constant(value=' for audio length of '), FormattedValue(value=Name(id='audio_length', ctx=Load()), conversion=-1)])], keywords=[])), Try(body=[Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='deepgram', ctx=Load()), attr='listen', ctx=Load()), attr='prerecorded', ctx=Load()), attr='v', ctx=Load()), args=[Constant(value='1')], keywords=[]), attr='transcribe_file', ctx=Load()), args=[Name(id='payload', ctx=Load()), Name(id='options', ctx=Load())], keywords=[keyword(arg='timeout', value=BinOp(left=Constant(value=30), op=Mult(), right=Constant(value=60)))])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Response received successfully.')], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Subscript(value=Call(func=Attribute(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='response', ctx=Load())], keywords=[]), attr='splitlines', ctx=Load()), args=[], keywords=[]), slice=Slice(upper=Constant(value=5)), ctx=Load())], keywords=[])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='An error occurred: '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[]))])], orelse=[], finalbody=[]), Assign(targets=[Name(id='elapsed_time', ctx=Store())], value=Call(func=Name(id='get_elapsed_seconds', ctx=Load()), args=[Call(func=Name(id='convert_to_epoch_seconds', ctx=Load()), args=[Name(id='start_time', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='transcribe_time_ratio', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='elapsed_time', ctx=Load()), op=Div(), right=Call(func=Name(id='convert_timestamp_to_seconds', ctx=Load()), args=[Name(id='audio_length', ctx=Load())], keywords=[])), op=Mult(), right=Constant(value=100))], keywords=[])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Elapsed time is '), FormattedValue(value=Call(func=Name(id='convert_seconds_to_timestamp', ctx=Load()), args=[Name(id='elapsed_time', ctx=Load())], keywords=[]), conversion=-1), Constant(value=' which is '), FormattedValue(value=Name(id='transcribe_time_ratio', ctx=Load()), conversion=-1), Constant(value='% of the audio length')])], keywords=[])), Assign(targets=[Name(id='response_json', ctx=Store())], value=Call(func=Attribute(value=Name(id='response', ctx=Load()), attr='to_json', ctx=Load()), args=[], keywords=[keyword(arg='indent', value=Constant(value=4))])), Assign(targets=[Name(id='json_file_path', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Call(func=Attribute(value=Name(id='audio_file_path', ctx=Load()), attr='rsplit', ctx=Load()), args=[Constant(value='.'), Constant(value=1)], keywords=[]), slice=Constant(value=0), ctx=Load()), op=Add(), right=Name(id='suffix', ctx=Load())), op=Add(), right=Constant(value='.json'))), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='json_file_path', ctx=Load()), Constant(value='w')], keywords=[]), optional_vars=Name(id='json_file', ctx=Store()))], body=[Expr(value=Call(func=Attribute(value=Name(id='json_file', ctx=Load()), attr='write', ctx=Load()), args=[Name(id='response_json', ctx=Load())], keywords=[]))]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Transcription saved to '), FormattedValue(value=Name(id='json_file_path', ctx=Load()), conversion=-1)])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Error during transcription: '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[]))])], orelse=[], finalbody=[]), Return(value=Name(id='json_file_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='transcribe_deepgram_sdk_prerecorded', args=arguments(posonlyargs=[], args=[arg(arg='audio_file_path'), arg(arg='model')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Calls the Deepgram API to transcribe the given audio file using the specified Deepgram model, utilizing the SDK.\n\n    :param audio_file_path: path to the audio file to be transcribed.\n    :param model: the Deepgram model to use for transcription.\n    :return: path to the JSON file containing the transcription results.\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='get_current_datetime_humanfriendly'), alias(name='convert_to_epoch_seconds'), alias(name='get_elapsed_seconds'), alias(name='convert_seconds_to_timestamp'), alias(name='convert_timestamp_to_seconds')], level=0), Assign(targets=[Name(id='MIMETYPES', ctx=Store())], value=List(elts=[Constant(value='mp3'), Constant(value='mp4'), Constant(value='mp2'), Constant(value='aac'), Constant(value='wav'), Constant(value='flac'), Constant(value='pcm'), Constant(value='m4a'), Constant(value='ogg'), Constant(value='opus'), Constant(value='webm')], ctx=Load())), Assign(targets=[Name(id='deepgram', ctx=Store())], value=Call(func=Name(id='DeepgramClient', ctx=Load()), args=[Name(id='DEEPGRAM_API_KEY', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='audio_file_path', ctx=Load()), attr='endswith', ctx=Load()), args=[Name(id='ext', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='ext', ctx=Store()), iter=Name(id='MIMETYPES', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='File '), FormattedValue(value=Name(id='audio_file_path', ctx=Load()), conversion=-1), Constant(value=' does not have a supported MIME type.')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='model_suffix_map', ctx=Store())], value=Dict(keys=[Constant(value='nova-2-general'), Constant(value='nova-2-meeting'), Constant(value='enhanced-meeting'), Constant(value='whisper-medium'), Constant(value='whisper-large')], values=[Constant(value='_nova2gen'), Constant(value='_nova2meet'), Constant(value='_enhmeet'), Constant(value='_dgwhspm'), Constant(value='_dgwhspl')])), If(test=Compare(left=Name(id='model', ctx=Load()), ops=[NotIn()], comparators=[Name(id='model_suffix_map', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Invalid or absent DeepGram model.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='suffix', ctx=Store())], value=Subscript(value=Name(id='model_suffix_map', ctx=Load()), slice=Name(id='model', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='json_file_path', ctx=Store())], value=Constant(value=None)), Try(body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Deepgram transcribing model: '), FormattedValue(value=Name(id='model', ctx=Load()), conversion=-1), Constant(value='  file : '), FormattedValue(value=Name(id='audio_file_path', ctx=Load()), conversion=-1)])], keywords=[])), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='audio_file_path', ctx=Load()), Constant(value='rb')], keywords=[]), optional_vars=Name(id='audio', ctx=Store()))], body=[Assign(targets=[Name(id='source', ctx=Store())], value=Dict(keys=[Constant(value='buffer'), Constant(value='mimetype')], values=[Name(id='audio', ctx=Load()), JoinedStr(values=[Constant(value='audio/'), FormattedValue(value=Subscript(value=Call(func=Attribute(value=Name(id='audio_file_path', ctx=Load()), attr='rsplit', ctx=Load()), args=[Constant(value='.'), Constant(value=1)], keywords=[]), slice=Constant(value=1), ctx=Load()), conversion=-1)])]))]), Assign(targets=[Name(id='options', ctx=Store())], value=Call(func=Name(id='PrerecordedOptions', ctx=Load()), args=[], keywords=[keyword(arg='model', value=Name(id='model', ctx=Load())), keyword(arg='punctuate', value=Constant(value=True)), keyword(arg='diarize', value=Constant(value=True)), keyword(arg='intents', value=Constant(value=True)), keyword(arg='sentiment', value=Constant(value=True)), keyword(arg='summarize', value=Constant(value=True)), keyword(arg='measurements', value=Constant(value=True)), keyword(arg='smart_format', value=Constant(value=True)), keyword(arg='topics', value=Constant(value=True))])), Assign(targets=[Name(id='audio_length', ctx=Store())], value=Call(func=Name(id='get_media_length', ctx=Load()), args=[Name(id='audio_file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='get_current_datetime_humanfriendly', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Start Synchronous Deepgram Transcription at '), FormattedValue(value=Name(id='start_time', ctx=Load()), conversion=-1), Constant(value=' for audio length of '), FormattedValue(value=Name(id='audio_length', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='deepgram', ctx=Load()), attr='transcription', ctx=Load()), attr='sync_prerecorded', ctx=Load()), args=[Name(id='source', ctx=Load()), Name(id='options', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Response received successfully.')], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Subscript(value=Call(func=Attribute(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='response', ctx=Load())], keywords=[]), attr='splitlines', ctx=Load()), args=[], keywords=[]), slice=Slice(upper=Constant(value=5)), ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='elapsed_time', ctx=Store())], value=Call(func=Name(id='get_elapsed_seconds', ctx=Load()), args=[Call(func=Name(id='convert_to_epoch_seconds', ctx=Load()), args=[Name(id='start_time', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='transcribe_time_ratio', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='elapsed_time', ctx=Load()), op=Div(), right=Call(func=Name(id='convert_timestamp_to_seconds', ctx=Load()), args=[Name(id='audio_length', ctx=Load())], keywords=[])), op=Mult(), right=Constant(value=100))], keywords=[])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Elapsed time is '), FormattedValue(value=Call(func=Name(id='convert_seconds_to_timestamp', ctx=Load()), args=[Name(id='elapsed_time', ctx=Load())], keywords=[]), conversion=-1), Constant(value=' which is '), FormattedValue(value=Name(id='transcribe_time_ratio', ctx=Load()), conversion=-1), Constant(value='% of the audio length')])], keywords=[])), Assign(targets=[Name(id='json_file_path', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Call(func=Attribute(value=Name(id='audio_file_path', ctx=Load()), attr='rsplit', ctx=Load()), args=[Constant(value='.'), Constant(value=1)], keywords=[]), slice=Constant(value=0), ctx=Load()), op=Add(), right=Name(id='suffix', ctx=Load())), op=Add(), right=Constant(value='.json'))), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='json_file_path', ctx=Load()), Constant(value='w')], keywords=[]), optional_vars=Name(id='json_file', ctx=Store()))], body=[Expr(value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='dump', ctx=Load()), args=[Name(id='response', ctx=Load()), Name(id='json_file', ctx=Load())], keywords=[keyword(arg='indent', value=Constant(value=4))]))]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Transcription saved to '), FormattedValue(value=Name(id='json_file_path', ctx=Load()), conversion=-1)])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Error during transcription: '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[]))])], orelse=[], finalbody=[]), Return(value=Name(id='json_file_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='transcribe_deepgram_callback', args=arguments(posonlyargs=[], args=[arg(arg='audio_file_path'), arg(arg='model'), arg(arg='callback_url')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Transcribes the given audio file using the specified Deepgram model asynchronously with a callback URL.\n\n    :param audio_file_path: path to the audio file to be transcribed.\n    :param model: the Deepgram model to use for transcription.\n    :param callback_url: URL to which Deepgram will send the transcription results.\n    :return: Request ID from Deepgram indicating that the file has been accepted for processing.\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='get_current_datetime_humanfriendly')], level=0), Assign(targets=[Name(id='MIMETYPES', ctx=Store())], value=Dict(keys=[Constant(value='mp3'), Constant(value='mp4'), Constant(value='wav'), Constant(value='flac')], values=[Constant(value='audio/mpeg'), Constant(value='audio/mp4'), Constant(value='audio/wav'), Constant(value='audio/flac')])), Assign(targets=[Name(id='file_extension', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='audio_file_path', ctx=Load()), attr='rsplit', ctx=Load()), args=[Constant(value='.'), Constant(value=1)], keywords=[]), slice=Constant(value=1), ctx=Load())), If(test=Compare(left=Name(id='file_extension', ctx=Load()), ops=[NotIn()], comparators=[Name(id='MIMETYPES', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='File '), FormattedValue(value=Name(id='audio_file_path', ctx=Load()), conversion=-1), Constant(value=' does not have a supported MIME type.')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='mimetype', ctx=Store())], value=Subscript(value=Name(id='MIMETYPES', ctx=Load()), slice=Name(id='file_extension', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='headers', ctx=Store())], value=Dict(keys=[Constant(value='Authorization'), Constant(value='Content-Type')], values=[JoinedStr(values=[Constant(value='Token '), FormattedValue(value=Name(id='DEEPGRAM_API_KEY', ctx=Load()), conversion=-1)]), Name(id='mimetype', ctx=Load())])), Assign(targets=[Name(id='params', ctx=Store())], value=Dict(keys=[Constant(value='callback'), Constant(value='model')], values=[Name(id='callback_url', ctx=Load()), Name(id='model', ctx=Load())])), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='audio_file_path', ctx=Load()), Constant(value='rb')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='audio_data', ctx=Store())], value=Call(func=Attribute(value=Name(id='file', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))]), Assign(targets=[Name(id='audio_length', ctx=Store())], value=Call(func=Name(id='get_media_length', ctx=Load()), args=[Name(id='audio_file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='get_current_datetime_humanfriendly', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Start Callback Deepgram Transcription at '), FormattedValue(value=Name(id='start_time', ctx=Load()), conversion=-1), Constant(value=' for audio length of '), FormattedValue(value=Name(id='audio_length', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Name(id='post', ctx=Load()), args=[], keywords=[keyword(arg='url', value=Constant(value='https://api.deepgram.com/v1/listen')), keyword(arg='headers', value=Name(id='headers', ctx=Load())), keyword(arg='params', value=Name(id='params', ctx=Load())), keyword(arg='data', value=Name(id='audio_data', ctx=Load()))])), If(test=Compare(left=Attribute(value=Name(id='response', ctx=Load()), attr='status_code', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Constant(value=200), Constant(value=202)], ctx=Load())]), body=[Assign(targets=[Name(id='callback_response', ctx=Store())], value=Call(func=Attribute(value=Name(id='response', ctx=Load()), attr='json', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='request_id', ctx=Store())], value=Call(func=Attribute(value=Name(id='callback_response', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='request_id'), Constant(value='NO REQUEST_ID FIELD FOUND IN JSON')], keywords=[])), If(test=Compare(left=Name(id='request_id', ctx=Load()), ops=[Eq()], comparators=[Constant(value='NO REQUEST_ID FIELD FOUND IN JSON')]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Deepgram Callback FAIL - '), FormattedValue(value=Name(id='request_id', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Deepgram Callback SUCCESS - request_id: '), FormattedValue(value=Name(id='request_id', ctx=Load()), conversion=-1)])], keywords=[]))]), Assign(targets=[Name(id='base_audio_file_name', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='audio_file_path', ctx=Load())], keywords=[])], keywords=[]), slice=Constant(value=0), ctx=Load())), Return(value=Tuple(elts=[Name(id='request_id', ctx=Load()), Name(id='base_audio_file_name', ctx=Load()), Name(id='model', ctx=Load())], ctx=Load()))], orelse=[Raise(exc=Call(func=Name(id='Exception', ctx=Load()), args=[JoinedStr(values=[Constant(value='Failed to submit audio: '), FormattedValue(value=Attribute(value=Name(id='response', ctx=Load()), attr='text', ctx=Load()), conversion=-1), Constant(value=', Status Code: '), FormattedValue(value=Attribute(value=Name(id='response', ctx=Load()), attr='status_code', ctx=Load()), conversion=-1)])], keywords=[]))])], decorator_list=[]), FunctionDef(name='transcribe_deepgram_callback2', args=arguments(posonlyargs=[], args=[arg(arg='audio_file_path'), arg(arg='model'), arg(arg='callback_url')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Transcribes the given audio file using the specified Deepgram model asynchronously with a callback URL.\n\n    :param audio_file_path: path to the audio file to be transcribed.\n    :param model: the Deepgram model to use for transcription.\n    :param callback_url: URL to which Deepgram will send the transcription results.\n    :return: Request ID from Deepgram indicating that the file has been accepted for processing.\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='get_current_datetime_humanfriendly')], level=0), Import(names=[alias(name='os')]), Assign(targets=[Name(id='MIMETYPES', ctx=Store())], value=Dict(keys=[Constant(value='mp3'), Constant(value='mp4'), Constant(value='wav'), Constant(value='flac')], values=[Constant(value='audio/mpeg'), Constant(value='audio/mp4'), Constant(value='audio/wav'), Constant(value='audio/flac')])), Assign(targets=[Name(id='file_extension', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='audio_file_path', ctx=Load()), attr='rsplit', ctx=Load()), args=[Constant(value='.'), Constant(value=1)], keywords=[]), slice=Constant(value=1), ctx=Load())), If(test=Compare(left=Name(id='file_extension', ctx=Load()), ops=[NotIn()], comparators=[Name(id='MIMETYPES', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='File '), FormattedValue(value=Name(id='audio_file_path', ctx=Load()), conversion=-1), Constant(value=' does not have a supported MIME type.')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='mimetype', ctx=Store())], value=Subscript(value=Name(id='MIMETYPES', ctx=Load()), slice=Name(id='file_extension', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='headers', ctx=Store())], value=Dict(keys=[Constant(value='Authorization'), Constant(value='Content-Type')], values=[JoinedStr(values=[Constant(value='Token '), FormattedValue(value=Name(id='DEEPGRAM_API_KEY', ctx=Load()), conversion=-1)]), Name(id='mimetype', ctx=Load())])), Assign(targets=[Name(id='params', ctx=Store())], value=Dict(keys=[Constant(value='callback'), Constant(value='model')], values=[Name(id='callback_url', ctx=Load()), Name(id='model', ctx=Load())])), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='audio_file_path', ctx=Load()), Constant(value='rb')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='audio_data', ctx=Store())], value=Call(func=Attribute(value=Name(id='file', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))]), Assign(targets=[Name(id='audio_length', ctx=Store())], value=Call(func=Name(id='get_media_length', ctx=Load()), args=[Name(id='audio_file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='get_current_datetime_humanfriendly', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Start Callback Deepgram Transcription at '), FormattedValue(value=Name(id='start_time', ctx=Load()), conversion=-1), Constant(value=' for audio length of '), FormattedValue(value=Name(id='audio_length', ctx=Load()), conversion=-1)])], keywords=[])), Try(body=[Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Name(id='post', ctx=Load()), args=[], keywords=[keyword(arg='url', value=Constant(value='https://api.deepgram.com/v1/listen')), keyword(arg='headers', value=Name(id='headers', ctx=Load())), keyword(arg='params', value=Name(id='params', ctx=Load())), keyword(arg='data', value=Name(id='audio_data', ctx=Load()))]))], handlers=[ExceptHandler(type=Attribute(value=Name(id='exceptions', ctx=Load()), attr='SSLError', ctx=Load()), name='ssl_err', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='SSL error: '), FormattedValue(value=Name(id='ssl_err', ctx=Load()), conversion=-1)])], keywords=[])), Raise()]), ExceptHandler(type=Attribute(value=Name(id='exceptions', ctx=Load()), attr='RequestException', ctx=Load()), name='req_err', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Request error: '), FormattedValue(value=Name(id='req_err', ctx=Load()), conversion=-1)])], keywords=[])), Raise()])], orelse=[], finalbody=[]), If(test=Compare(left=Attribute(value=Name(id='response', ctx=Load()), attr='status_code', ctx=Load()), ops=[In()], comparators=[Tuple(elts=[Constant(value=200), Constant(value=202)], ctx=Load())]), body=[Assign(targets=[Name(id='callback_response', ctx=Store())], value=Call(func=Attribute(value=Name(id='response', ctx=Load()), attr='json', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='request_id', ctx=Store())], value=Call(func=Attribute(value=Name(id='callback_response', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='request_id'), Constant(value='NO REQUEST_ID FIELD FOUND IN JSON')], keywords=[])), If(test=Compare(left=Name(id='request_id', ctx=Load()), ops=[Eq()], comparators=[Constant(value='NO REQUEST_ID FIELD FOUND IN JSON')]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Deepgram Callback FAIL - '), FormattedValue(value=Name(id='request_id', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Deepgram Callback SUCCESS - request_id: '), FormattedValue(value=Name(id='request_id', ctx=Load()), conversion=-1)])], keywords=[]))]), Assign(targets=[Name(id='base_audio_file_name', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='audio_file_path', ctx=Load())], keywords=[])], keywords=[]), slice=Constant(value=0), ctx=Load())), Return(value=Tuple(elts=[Name(id='request_id', ctx=Load()), Name(id='base_audio_file_name', ctx=Load()), Name(id='model', ctx=Load())], ctx=Load()))], orelse=[Raise(exc=Call(func=Name(id='Exception', ctx=Load()), args=[JoinedStr(values=[Constant(value='Failed to submit audio: '), FormattedValue(value=Attribute(value=Name(id='response', ctx=Load()), attr='text', ctx=Load()), conversion=-1), Constant(value=', Status Code: '), FormattedValue(value=Attribute(value=Name(id='response', ctx=Load()), attr='status_code', ctx=Load()), conversion=-1)])], keywords=[]))])], decorator_list=[]), FunctionDef(name='transcribe_deepgram_OLD_fixhang', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='timeout_duration')], kwonlyargs=[], kw_defaults=[], defaults=[BinOp(left=BinOp(left=Constant(value=1), op=Mult(), right=Constant(value=60)), op=Mult(), right=Constant(value=60))]), body=[Assign(targets=[Name(id='json_file_path', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='progress_thread', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='stop_event', ctx=Store())], value=Call(func=Attribute(value=Name(id='threading', ctx=Load()), attr='Event', ctx=Load()), args=[], keywords=[])), Try(body=[If(test=Call(func=Attribute(value=Name(id='file_path', ctx=Load()), attr='endswith', ctx=Load()), args=[Name(id='MIMETYPE', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Starting Deepgram transcription at '), FormattedValue(value=Call(func=Name(id='get_current_time_str', ctx=Load()), args=[], keywords=[]), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='file_size_mb', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='getsize', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Constant(value=1024), op=Mult(), right=Constant(value=1024)))), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='File size: '), FormattedValue(value=Name(id='file_size_mb', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.2f')])), Constant(value=' MB')])], keywords=[])), Assign(targets=[Name(id='progress_thread', ctx=Store())], value=Call(func=Attribute(value=Name(id='threading', ctx=Load()), attr='Thread', ctx=Load()), args=[], keywords=[keyword(arg='target', value=Name(id='print_progress', ctx=Load())), keyword(arg='args', value=Tuple(elts=[Name(id='timeout_duration', ctx=Load()), Name(id='stop_event', ctx=Load())], ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='progress_thread', ctx=Load()), attr='start', ctx=Load()), args=[], keywords=[])), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='rb')], keywords=[]), optional_vars=Name(id='f', ctx=Store()))], body=[Assign(targets=[Name(id='source', ctx=Store())], value=Dict(keys=[Constant(value='buffer'), Constant(value='mimetype')], values=[Name(id='f', ctx=Load()), BinOp(left=Constant(value='audio/'), op=Add(), right=Name(id='MIMETYPE', ctx=Load()))])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Deepgram transcribing file: '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1)])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Progress: ')], keywords=[keyword(arg='end', value=Constant(value=''))])), Assign(targets=[Name(id='res', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='dg', ctx=Load()), attr='transcription', ctx=Load()), attr='sync_prerecorded', ctx=Load()), args=[Name(id='source', ctx=Load()), Name(id='dg_options', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='stop_event', ctx=Load()), attr='set', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='json_file_path', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Name(id='file_path', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=4))), ctx=Load()), op=Add(), right=Name(id='dg_suffix', ctx=Load())), op=Add(), right=Constant(value='.json'))), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='json_file_path', ctx=Load()), Constant(value='w')], keywords=[]), optional_vars=Name(id='transcript', ctx=Store()))], body=[Expr(value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='dump', ctx=Load()), args=[Name(id='res', ctx=Load()), Name(id='transcript', ctx=Load())], keywords=[keyword(arg='indent', value=Constant(value=4))]))]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='\nDeepgram transcribe successful on file: '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1)])], keywords=[]))])], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='File '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value=' does not end with '), FormattedValue(value=Name(id='MIMETYPE', ctx=Load()), conversion=-1)])], keywords=[]))])], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Error during transcription: '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[]))])], orelse=[], finalbody=[If(test=Compare(left=Name(id='progress_thread', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='stop_event', ctx=Load()), attr='set', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='progress_thread', ctx=Load()), attr='join', ctx=Load()), args=[], keywords=[keyword(arg='timeout', value=Constant(value=0))]))], orelse=[])]), Return(value=Name(id='json_file_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_summary_start_seconds', args=arguments(posonlyargs=[], args=[arg(arg='data'), arg(arg='index')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=' \n    Retrieves the start time in seconds of a word from the transcription data at the given index.\n\n    :param data: dictionary of the transcription data.\n    :param index: integer of the index of the word to find the start time for.\n    :return: integer of the start time in seconds of the specified word, rounded down to the nearest whole number.\n    ')), Assign(targets=[Name(id='words_list', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='results'), Dict(keys=[], values=[])], keywords=[]), attr='get', ctx=Load()), args=[Constant(value='channels'), List(elts=[], ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='alternatives'), List(elts=[], ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='words'), List(elts=[], ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='index', ctx=Load()), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='words_list', ctx=Load())], keywords=[])]), body=[Return(value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[Call(func=Attribute(value=Subscript(value=Name(id='words_list', ctx=Load()), slice=Name(id='index', ctx=Load()), ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='start'), Constant(value=0)], keywords=[])], keywords=[]))], orelse=[]), Return(value=Constant(value=0))], decorator_list=[]), FunctionDef(name='format_feature_segment', args=arguments(posonlyargs=[], args=[arg(arg='feature'), arg(arg='segment'), arg(arg='data')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Formats a segment of a feature with a timestamp and additional info.\n\n    :param feature: string, the feature being extracted.\n    :param segment: dict, the segment of the feature to be formatted.\n    :param data: dict, the JSON data from the Deepgram file.\n    :return: string, the formatted segment.\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='convert_seconds_to_timestamp')], level=0), Assign(targets=[Name(id='singular_feature_json', ctx=Store())], value=Subscript(value=Name(id='feature', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load())), Assign(targets=[Name(id='singular_feature_print', ctx=Store())], value=Call(func=Attribute(value=Name(id='singular_feature_json', ctx=Load()), attr='capitalize', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='segment_text', ctx=Store())], value=Call(func=Attribute(value=Name(id='segment', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='text'), Constant(value='')], keywords=[])), Assign(targets=[Name(id='segment_start_index', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='segment', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='start_word'), Constant(value=0)], keywords=[])], keywords=[])), Assign(targets=[Name(id='segment_start_secs', ctx=Store())], value=Call(func=Name(id='get_summary_start_seconds', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='segment_start_index', ctx=Load())], keywords=[])), Assign(targets=[Name(id='segment_timestamp', ctx=Store())], value=Call(func=Name(id='convert_seconds_to_timestamp', ctx=Load()), args=[Name(id='segment_start_secs', ctx=Load())], keywords=[])), Assign(targets=[Name(id='segment_midline', ctx=Store())], value=Constant(value='')), If(test=Compare(left=Call(func=Attribute(value=Name(id='feature', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Constant(value='summaries')]), body=[Assign(targets=[Name(id='singular_feature_json', ctx=Store())], value=Constant(value='summary')), Assign(targets=[Name(id='singular_feature_print', ctx=Store())], value=Call(func=Attribute(value=Name(id='singular_feature_json', ctx=Load()), attr='capitalize', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='segment_text', ctx=Store())], value=Call(func=Attribute(value=Name(id='segment', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='singular_feature_json', ctx=Load()), Constant(value='')], keywords=[]))], orelse=[If(test=Compare(left=Call(func=Attribute(value=Name(id='feature', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Constant(value='sentiments')]), body=[Assign(targets=[Name(id='sentiment', ctx=Store())], value=Call(func=Attribute(value=Name(id='segment', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='sentiment')], keywords=[])), Assign(targets=[Name(id='sentiment_score', ctx=Store())], value=Call(func=Attribute(value=Name(id='segment', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='sentiment_score')], keywords=[])), Assign(targets=[Name(id='segment_midline', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='sentiment', ctx=Load()), conversion=-1), Constant(value=' - sentiment_score = '), FormattedValue(value=Name(id='sentiment_score', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.2f')]))]))], orelse=[If(test=Compare(left=Call(func=Attribute(value=Name(id='feature', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Constant(value='topics')]), body=[Assign(targets=[Name(id='topic_info', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='segment', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='topics'), List(elts=[Dict(keys=[], values=[])], ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='topic_name', ctx=Store())], value=Call(func=Attribute(value=Name(id='topic_info', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='topic')], keywords=[])), Assign(targets=[Name(id='confidence_score', ctx=Store())], value=Call(func=Attribute(value=Name(id='topic_info', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='confidence_score')], keywords=[])), Assign(targets=[Name(id='segment_midline', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='topic_name', ctx=Load()), conversion=-1), Constant(value=' - confidence_score = '), FormattedValue(value=Name(id='confidence_score', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.2f')]))]))], orelse=[If(test=Compare(left=Call(func=Attribute(value=Name(id='feature', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Constant(value='intents')]), body=[Assign(targets=[Name(id='intent_info', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='segment', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='intents'), List(elts=[Dict(keys=[], values=[])], ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='intent_name', ctx=Store())], value=Call(func=Attribute(value=Name(id='intent_info', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='intent')], keywords=[])), Assign(targets=[Name(id='confidence_score', ctx=Store())], value=Call(func=Attribute(value=Name(id='intent_info', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='confidence_score')], keywords=[])), Assign(targets=[Name(id='segment_midline', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='intent_name', ctx=Load()), conversion=-1), Constant(value=' - confidence_score = '), FormattedValue(value=Name(id='confidence_score', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.2f')]))]))], orelse=[])])])]), Assign(targets=[Name(id='formatted_segment', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='singular_feature_print', ctx=Load()), conversion=-1), Constant(value='  '), FormattedValue(value=Name(id='segment_timestamp', ctx=Load()), conversion=-1), Constant(value='\n')])), If(test=Name(id='segment_midline', ctx=Load()), body=[AugAssign(target=Name(id='formatted_segment', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Name(id='segment_midline', ctx=Load()), conversion=-1), Constant(value='\n')]))], orelse=[]), AugAssign(target=Name(id='formatted_segment', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Name(id='segment_text', ctx=Load()), conversion=-1), Constant(value='\n\n')])), Return(value=Name(id='formatted_segment', ctx=Load()))], decorator_list=[]), FunctionDef(name='extract_feature_from_deepgram_json', args=arguments(posonlyargs=[], args=[arg(arg='json_file_path'), arg(arg='feature')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Extract a specific feature section from a Deepgram JSON file and return it as a string.\n\n    :param json_file_path: string of the path to the JSON file from which the feature is to be extracted.\n    :param feature: string of the feature of the section to be extracted.\n    :return: string of the extracted text under the specified feature, preceded by the feature itself (no pound signs) and a blank line.\n    ')), Try(body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='json_file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='data', ctx=Store())], value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='load', ctx=Load()), args=[Name(id='file', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='extracted_text', ctx=Store())], value=Constant(value='')), If(test=Compare(left=Name(id='feature', ctx=Load()), ops=[Eq()], comparators=[Constant(value='summaries')]), body=[Assign(targets=[Name(id='summaries', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='results'), Dict(keys=[], values=[])], keywords=[]), attr='get', ctx=Load()), args=[Constant(value='channels'), List(elts=[], ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='alternatives'), List(elts=[], ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load()), attr='get', ctx=Load()), args=[Name(id='feature', ctx=Load()), List(elts=[], ctx=Load())], keywords=[])), For(target=Name(id='summary', ctx=Store()), iter=Name(id='summaries', ctx=Load()), body=[AugAssign(target=Name(id='extracted_text', ctx=Store()), op=Add(), value=Call(func=Name(id='format_feature_segment', ctx=Load()), args=[Name(id='feature', ctx=Load()), Name(id='summary', ctx=Load()), Name(id='data', ctx=Load())], keywords=[]))], orelse=[])], orelse=[If(test=Compare(left=Name(id='feature', ctx=Load()), ops=[In()], comparators=[List(elts=[Constant(value='sentiments'), Constant(value='topics'), Constant(value='intents')], ctx=Load())]), body=[Assign(targets=[Name(id='segments', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='results'), Dict(keys=[], values=[])], keywords=[]), attr='get', ctx=Load()), args=[Name(id='feature', ctx=Load()), Dict(keys=[], values=[])], keywords=[]), attr='get', ctx=Load()), args=[Constant(value='segments'), List(elts=[], ctx=Load())], keywords=[])), For(target=Name(id='segment', ctx=Store()), iter=Name(id='segments', ctx=Load()), body=[AugAssign(target=Name(id='extracted_text', ctx=Store()), op=Add(), value=Call(func=Name(id='format_feature_segment', ctx=Load()), args=[Name(id='feature', ctx=Load()), Name(id='segment', ctx=Load()), Name(id='data', ctx=Load())], keywords=[]))], orelse=[])], orelse=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value="in extract_feature_from_deepgram_json - Feature '"), FormattedValue(value=Name(id='feature', ctx=Load()), conversion=-1), Constant(value="' not found in Deepgram JSON")])], keywords=[])), Return(value=Constant(value=None))])]), If(test=Name(id='extracted_text', ctx=Load()), body=[Return(value=JoinedStr(values=[FormattedValue(value=Call(func=Attribute(value=Name(id='extracted_text', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), conversion=-1), Constant(value='\n\n')]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value="in extract_feature_from_deepgram_json - Feature '"), FormattedValue(value=Name(id='feature', ctx=Load()), conversion=-1), Constant(value="' was found in Deepgram JSON but extracted text is None or empty string (should not get this warning!)")])], keywords=[])), Return(value=Constant(value=None))])], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Error extracting '), FormattedValue(value=Name(id='feature', ctx=Load()), conversion=-1), Constant(value=' from '), FormattedValue(value=Name(id='json_file_path', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='validate_transcript_json', args=arguments(posonlyargs=[], args=[arg(arg='json_file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Validates the structure of a JSON file to ensure it contains specific keys and types.\n\n    :param json_file_path: string of the path to the JSON file to be validated.\n    :return: boolean, True if the JSON structure is as expected, False otherwise.\n    ')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='json_file_path', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='The file path does not exist for '), FormattedValue(value=Name(id='json_file_path', ctx=Load()), conversion=-1), Constant(value='.')])], keywords=[]))], orelse=[]), Try(body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='json_file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='data', ctx=Store())], value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='load', ctx=Load()), args=[Name(id='file', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='results', ctx=Store())], value=Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='results')], keywords=[])), If(test=Compare(left=Name(id='results', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='KeyError', ctx=Load()), args=[Constant(value='results key not found')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='channels', ctx=Store())], value=Call(func=Attribute(value=Name(id='results', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='channels')], keywords=[])), If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='channels', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])), UnaryOp(op=Not(), operand=Name(id='channels', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='channels is not a non-empty list')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='alternatives', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='channels', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='alternatives')], keywords=[])), If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='alternatives', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])), UnaryOp(op=Not(), operand=Name(id='alternatives', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='alternatives is not a non-empty list')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='words_data', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='alternatives', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='words')], keywords=[])), If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='words_data', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])), Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='words_data', ctx=Load())], keywords=[]), ops=[LtE()], comparators=[Constant(value=1)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='The list of words is empty or has only one word.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='paragraphs_data', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='alternatives', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='paragraphs')], keywords=[])), If(test=Compare(left=Name(id='paragraphs_data', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='KeyError', ctx=Load()), args=[Constant(value='paragraphs key not found')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='transcript', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='paragraphs_data', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='transcript'), Constant(value='')], keywords=[]), attr='strip', ctx=Load()), args=[], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='transcript', ctx=Load())), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='The transcript in paragraphs is empty.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='paragraphs_list', ctx=Store())], value=Call(func=Attribute(value=Name(id='paragraphs_data', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='paragraphs')], keywords=[])), If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='paragraphs_list', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])), UnaryOp(op=Not(), operand=Name(id='paragraphs_list', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='There are no paragraphs in paragraphs.')], keywords=[]))], orelse=[])], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='KeyError', ctx=Load()), Name(id='TypeError', ctx=Load()), Name(id='ValueError', ctx=Load())], ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Error occurred with file '), FormattedValue(value=Name(id='json_file_path', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[])), Return(value=Constant(value=False))])], orelse=[], finalbody=[]), Return(value=Constant(value=True))], decorator_list=[]), FunctionDef(name='set_various_transcript_headings', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='feature'), arg(arg='source')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Sets the transcript heading in a file based on the extracted feature from a specified source.\n\n    :param file_path: string of the path to the file where the heading is to be set.\n    :param feature: string of the feature to extract and use as the heading.\n    :param source: string of the source from which to extract the feature ('deepgram' or 'youtube').\n    :return: None.\n    ")), ImportFrom(module='primary.fileops', names=[alias(name='set_heading'), alias(name='add_suffix_in_str'), alias(name='remove_all_suffixes_in_str'), alias(name='find_file_in_folders')], level=0), Assign(targets=[Name(id='folder_paths', ctx=Store())], value=List(elts=[Constant(value='data/f_c9_done_json_yt_host')], ctx=Load())), If(test=Compare(left=Name(id='source', ctx=Load()), ops=[Eq()], comparators=[Constant(value='deepgram')]), body=[Assign(targets=[Name(id='dg_json_file_path', ctx=Store())], value=Call(func=Attribute(value=Name(id='file_path', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='.md'), Constant(value='.json')], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='dg_json_file_path', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='dg_json_file_path', ctx=Store())], value=Call(func=Name(id='find_file_in_folders', ctx=Load()), args=[Name(id='dg_json_file_path', ctx=Load()), Name(id='folder_paths', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='dg_json_file_path', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='No companion deepgram json file found for '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='extracted_feature_text', ctx=Store())], value=Call(func=Name(id='extract_feature_from_deepgram_json', ctx=Load()), args=[Name(id='dg_json_file_path', ctx=Load()), Name(id='feature', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='source', ctx=Load()), ops=[Eq()], comparators=[Constant(value='youtube')]), body=[Assign(targets=[Name(id='yt_md_file_path', ctx=Store())], value=Call(func=Name(id='add_suffix_in_str', ctx=Load()), args=[Call(func=Name(id='remove_all_suffixes_in_str', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[]), Constant(value='_yt')], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='yt_md_file_path', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='yt_md_file_path', ctx=Store())], value=Call(func=Name(id='find_file_in_folders', ctx=Load()), args=[Name(id='yt_md_file_path', ctx=Load()), Name(id='folder_paths', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='yt_md_file_path', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='No companion youtube md file found for '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='extracted_feature_text', ctx=Store())], value=Call(func=Name(id='extract_feature_from_youtube_md', ctx=Load()), args=[Name(id='yt_md_file_path', ctx=Load()), Name(id='feature', ctx=Load())], keywords=[]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='source invalid')], keywords=[]))])]), If(test=Compare(left=Name(id='extracted_feature_text', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return()], orelse=[]), Expr(value=Call(func=Name(id='set_heading', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='extracted_feature_text', ctx=Load()), BinOp(left=Constant(value='### '), op=Add(), right=Name(id='feature', ctx=Load()))], keywords=[]))], decorator_list=[]), FunctionDef(name='extract_context', args=arguments(posonlyargs=[], args=[arg(arg='line'), arg(arg='match'), arg(arg='context_radius')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=' \n    Extracts a context window around a regex match within a string of text.\n\n    :param line: string of text containing the match.\n    :param match: regex match object containing the start and end positions of the match within the line.\n    :param context_radius: integer specifying the number of words around the match to include in the context window.\n    :return: string of text representing the context window around the match.\n    ')), If(test=Compare(left=Name(id='match', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Match not found')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='words', ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='match_word_index', ctx=Store())], value=Constant(value=None)), For(target=Tuple(elts=[Name(id='index', ctx=Store()), Name(id='word', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='words', ctx=Load())], keywords=[]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='start', ctx=Load()), args=[], keywords=[]), ops=[GtE()], comparators=[Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='find', ctx=Load()), args=[Name(id='word', ctx=Load())], keywords=[])]), Compare(left=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='end', ctx=Load()), args=[], keywords=[]), ops=[LtE()], comparators=[BinOp(left=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='find', ctx=Load()), args=[Name(id='word', ctx=Load())], keywords=[]), op=Add(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='word', ctx=Load())], keywords=[]))])]), body=[Assign(targets=[Name(id='match_word_index', ctx=Store())], value=Name(id='index', ctx=Load())), Break()], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='match_word_index', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Match not found within the words of the line')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='context_start', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[BinOp(left=Name(id='match_word_index', ctx=Load()), op=Sub(), right=Name(id='context_radius', ctx=Load())), Constant(value=0)], keywords=[])), Assign(targets=[Name(id='context_end', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='match_word_index', ctx=Load()), op=Add(), right=Name(id='context_radius', ctx=Load())), op=Add(), right=Constant(value=1)), Call(func=Name(id='len', ctx=Load()), args=[Name(id='words', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='context_window', ctx=Store())], value=Call(func=Attribute(value=Constant(value=' '), attr='join', ctx=Load()), args=[Subscript(value=Name(id='words', ctx=Load()), slice=Slice(lower=Name(id='context_start', ctx=Load()), upper=Name(id='context_end', ctx=Load())), ctx=Load())], keywords=[])), Return(value=Name(id='context_window', ctx=Load()))], decorator_list=[]), FunctionDef(name='print_num_exception', args=arguments(posonlyargs=[], args=[arg(arg='match_str'), arg(arg='line_number'), arg(arg='num_metadata_lines'), arg(arg='printed_exceptions'), arg(arg='exception_type'), arg(arg='line')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=" \n    Prints a message for numbers that are excluded from conversion and records the message.\n\n    :param match_str: the string that matches the number to be excluded from conversion.\n    :param line_number: the current line number in the file being processed.\n    :param num_metadata_lines: the number of metadata lines in the file to adjust the actual line number.\n    :param printed_exceptions: a list of exception messages that have already been printed.\n    :param exception_type: the type of exception to be printed.\n    :param line: the current line of text being processed.\n    :return: None, but updates the printed_exceptions list with the new exception message if it hasn't been printed before.\n    ")), Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='search', ctx=Load()), args=[Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='match_str', ctx=Load())], keywords=[]), Name(id='line', ctx=Load())], keywords=[])), If(test=Name(id='match', ctx=Load()), body=[Assign(targets=[Name(id='exception_msg', ctx=Store())], value=JoinedStr(values=[Constant(value='Excluding conversion for '), FormattedValue(value=Name(id='exception_type', ctx=Load()), conversion=-1), Constant(value=' at line '), FormattedValue(value=BinOp(left=BinOp(left=Name(id='line_number', ctx=Load()), op=Add(), right=Constant(value=1)), op=Add(), right=Name(id='num_metadata_lines', ctx=Load())), conversion=-1), Constant(value=': ...'), FormattedValue(value=Call(func=Name(id='extract_context', ctx=Load()), args=[Name(id='line', ctx=Load()), Name(id='match', ctx=Load()), Constant(value=5)], keywords=[]), conversion=-1), Constant(value='...')])), If(test=Compare(left=Name(id='exception_msg', ctx=Load()), ops=[NotIn()], comparators=[Name(id='printed_exceptions', ctx=Load())]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='exception_msg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='printed_exceptions', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='exception_msg', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='get_previous_word', args=arguments(posonlyargs=[], args=[arg(arg='substring'), arg(arg='start_index')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=' \n    Finds the word in a string that precedes the given start index.\n\n    :param substring: the string from which to extract the previous word.\n    :param start_index: the index in the string to start searching backward from.\n    :return: the word found before the start index, or an empty string if no word is found.\n    ')), Assign(targets=[Name(id='word_end', ctx=Store())], value=Name(id='start_index', ctx=Load())), While(test=BoolOp(op=And(), values=[Compare(left=Name(id='word_end', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), Call(func=Attribute(value=Subscript(value=Name(id='substring', ctx=Load()), slice=BinOp(left=Name(id='word_end', ctx=Load()), op=Sub(), right=Constant(value=1)), ctx=Load()), attr='isspace', ctx=Load()), args=[], keywords=[])]), body=[AugAssign(target=Name(id='word_end', ctx=Store()), op=Sub(), value=Constant(value=1))], orelse=[]), Assign(targets=[Name(id='word_start', ctx=Store())], value=Name(id='word_end', ctx=Load())), While(test=BoolOp(op=And(), values=[Compare(left=Name(id='word_start', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Subscript(value=Name(id='substring', ctx=Load()), slice=BinOp(left=Name(id='word_start', ctx=Load()), op=Sub(), right=Constant(value=1)), ctx=Load()), attr='isspace', ctx=Load()), args=[], keywords=[]))]), body=[AugAssign(target=Name(id='word_start', ctx=Store()), op=Sub(), value=Constant(value=1))], orelse=[]), Return(value=IfExp(test=Compare(left=Name(id='word_start', ctx=Load()), ops=[NotEq()], comparators=[Name(id='word_end', ctx=Load())]), body=Subscript(value=Name(id='substring', ctx=Load()), slice=Slice(lower=Name(id='word_start', ctx=Load()), upper=Name(id='word_end', ctx=Load())), ctx=Load()), orelse=Constant(value='')))], decorator_list=[]), FunctionDef(name='previous_word_exception', args=arguments(posonlyargs=[], args=[arg(arg='word'), arg(arg='common_english_vocab'), arg(arg='additional_exception_words')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=' \n    Determines if a word is an exception based on its presence in additional exceptions or English vocabulary.\n\n    :param word: the word to check for exception status.\n    :param common_english_vocab: a set of common English words to compare against.\n    :param additional_exception_words: a set of words that are always considered exceptions.\n    :return: True if the word is an exception, False otherwise.\n    ')), If(test=Compare(left=Call(func=Attribute(value=Name(id='word', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[In()], comparators=[Name(id='additional_exception_words', ctx=Load())]), body=[Return(value=Constant(value=True))], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='word', ctx=Load()), attr='istitle', ctx=Load()), args=[], keywords=[]), Compare(left=Call(func=Attribute(value=Name(id='word', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[NotIn()], comparators=[Name(id='common_english_vocab', ctx=Load())])]), body=[Return(value=Constant(value=True))], orelse=[]), Return(value=Constant(value=False))], decorator_list=[]), FunctionDef(name='convert_num_line_lowercase', args=arguments(posonlyargs=[], args=[arg(arg='line'), arg(arg='num'), arg(arg='num_str'), arg(arg='line_number'), arg(arg='num_metadata_lines'), arg(arg='printed_exceptions'), arg(arg='common_english_vocab')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=' \n    Converts numbers in a line of text to their lowercase word equivalents, skipping exceptions.\n\n    :param line: The line of text in which to convert numbers.\n    :param num: The numerical value to convert to words.\n    :param num_str: The string representation of the number to find in the line.\n    :param line_number: The current line number in the text being processed.\n    :param num_metadata_lines: The number of metadata lines in the text before the content.\n    :param printed_exceptions: A set to record exceptions that have been printed.\n    :param common_english_vocab: A set of common English vocabulary words.\n    :return: A tuple containing the modified line and the total number of substitutions made.\n    ')), Assign(targets=[Name(id='num_subs_total', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='current_index', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='additional_exception_words', ctx=Store())], value=List(elts=[Constant(value='step')], ctx=Load())), While(test=Compare(left=Name(id='current_index', ctx=Load()), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])]), body=[If(test=Call(func=Attribute(value=Subscript(value=Name(id='line', ctx=Load()), slice=Name(id='current_index', ctx=Load()), ctx=Load()), attr='isdigit', ctx=Load()), args=[], keywords=[]), body=[If(test=BoolOp(op=Or(), values=[BoolOp(op=And(), values=[Compare(left=Name(id='current_index', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), UnaryOp(op=Not(), operand=Compare(left=Subscript(value=Name(id='line', ctx=Load()), slice=BinOp(left=Name(id='current_index', ctx=Load()), op=Sub(), right=Constant(value=1)), ctx=Load()), ops=[In()], comparators=[Constant(value='0123456789.,?! \n')]))]), BoolOp(op=And(), values=[Compare(left=Name(id='current_index', ctx=Load()), ops=[Lt()], comparators=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[]), op=Sub(), right=Constant(value=1))]), UnaryOp(op=Not(), operand=Compare(left=Subscript(value=Name(id='line', ctx=Load()), slice=BinOp(left=Name(id='current_index', ctx=Load()), op=Add(), right=Constant(value=1)), ctx=Load()), ops=[In()], comparators=[Constant(value='0123456789.,?! \n')]))])]), body=[While(test=BoolOp(op=And(), values=[Compare(left=Name(id='current_index', ctx=Load()), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])]), UnaryOp(op=Not(), operand=Compare(left=Subscript(value=Name(id='line', ctx=Load()), slice=Name(id='current_index', ctx=Load()), ctx=Load()), ops=[In()], comparators=[Constant(value=' \n')]))]), body=[AugAssign(target=Name(id='current_index', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[]), Continue()], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='current_index', ctx=Load()), ops=[Lt()], comparators=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[]), op=Sub(), right=Constant(value=1))]), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Subscript(value=Name(id='line', ctx=Load()), slice=BinOp(left=Name(id='current_index', ctx=Load()), op=Add(), right=Constant(value=1)), ctx=Load()), attr='isdigit', ctx=Load()), args=[], keywords=[])), Compare(left=BinOp(left=Name(id='current_index', ctx=Load()), op=Add(), right=Constant(value=2)), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])]), Call(func=Attribute(value=Subscript(value=Name(id='line', ctx=Load()), slice=BinOp(left=Name(id='current_index', ctx=Load()), op=Add(), right=Constant(value=2)), ctx=Load()), attr='isdigit', ctx=Load()), args=[], keywords=[])]), body=[AugAssign(target=Name(id='current_index', ctx=Store()), op=Add(), value=Constant(value=3)), While(test=BoolOp(op=And(), values=[Compare(left=Name(id='current_index', ctx=Load()), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])]), BoolOp(op=Or(), values=[Call(func=Attribute(value=Subscript(value=Name(id='line', ctx=Load()), slice=Name(id='current_index', ctx=Load()), ctx=Load()), attr='isdigit', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Subscript(value=Name(id='line', ctx=Load()), slice=Name(id='current_index', ctx=Load()), ctx=Load()), attr='isspace', ctx=Load()), args=[], keywords=[]), Compare(left=Subscript(value=Name(id='line', ctx=Load()), slice=Name(id='current_index', ctx=Load()), ctx=Load()), ops=[In()], comparators=[Constant(value='.,!?')])])]), body=[AugAssign(target=Name(id='current_index', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[]), Continue()], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='current_index', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), Compare(left=Subscript(value=Name(id='line', ctx=Load()), slice=BinOp(left=Name(id='current_index', ctx=Load()), op=Sub(), right=Constant(value=1)), ctx=Load()), ops=[Eq()], comparators=[Constant(value='.')])]), body=[AugAssign(target=Name(id='current_index', ctx=Store()), op=Add(), value=Constant(value=2)), While(test=BoolOp(op=And(), values=[Compare(left=Name(id='current_index', ctx=Load()), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])]), Call(func=Attribute(value=Subscript(value=Name(id='line', ctx=Load()), slice=Name(id='current_index', ctx=Load()), ctx=Load()), attr='isdigit', ctx=Load()), args=[], keywords=[])]), body=[AugAssign(target=Name(id='current_index', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[]), Continue()], orelse=[]), If(test=BoolOp(op=And(), values=[BoolOp(op=Or(), values=[Compare(left=Name(id='current_index', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), BoolOp(op=And(), values=[Compare(left=Name(id='current_index', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), Call(func=Attribute(value=Subscript(value=Name(id='line', ctx=Load()), slice=Slice(upper=Name(id='current_index', ctx=Load())), ctx=Load()), attr='isspace', ctx=Load()), args=[], keywords=[])])]), BoolOp(op=And(), values=[Compare(left=BinOp(left=Name(id='current_index', ctx=Load()), op=Add(), right=Constant(value=1)), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])]), Compare(left=Subscript(value=Name(id='line', ctx=Load()), slice=BinOp(left=Name(id='current_index', ctx=Load()), op=Add(), right=Constant(value=1)), ctx=Load()), ops=[Eq()], comparators=[Constant(value='.')]), BoolOp(op=And(), values=[Compare(left=BinOp(left=Name(id='current_index', ctx=Load()), op=Add(), right=Constant(value=2)), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])]), Compare(left=Subscript(value=Name(id='line', ctx=Load()), slice=BinOp(left=Name(id='current_index', ctx=Load()), op=Add(), right=Constant(value=2)), ctx=Load()), ops=[Eq()], comparators=[Constant(value=' ')])])])]), body=[AugAssign(target=Name(id='current_index', ctx=Store()), op=Add(), value=Constant(value=3)), Continue()], orelse=[]), Assign(targets=[Name(id='end_index', ctx=Store())], value=BinOp(left=Name(id='current_index', ctx=Load()), op=Add(), right=Constant(value=1))), While(test=BoolOp(op=And(), values=[Compare(left=Name(id='end_index', ctx=Load()), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])]), Call(func=Attribute(value=Subscript(value=Name(id='line', ctx=Load()), slice=Name(id='end_index', ctx=Load()), ctx=Load()), attr='isdigit', ctx=Load()), args=[], keywords=[])]), body=[AugAssign(target=Name(id='end_index', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[]), Assign(targets=[Name(id='number_str', ctx=Store())], value=Subscript(value=Name(id='line', ctx=Load()), slice=Slice(lower=Name(id='current_index', ctx=Load()), upper=Name(id='end_index', ctx=Load())), ctx=Load())), If(test=Compare(left=Name(id='number_str', ctx=Load()), ops=[Eq()], comparators=[Name(id='num_str', ctx=Load())]), body=[Assign(targets=[Name(id='previous_word', ctx=Store())], value=Call(func=Name(id='get_previous_word', ctx=Load()), args=[Name(id='line', ctx=Load()), Name(id='current_index', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='previous_word_exception', ctx=Load()), args=[Name(id='previous_word', ctx=Load()), Name(id='common_english_vocab', ctx=Load()), Name(id='additional_exception_words', ctx=Load())], keywords=[])), body=[Assign(targets=[Tuple(elts=[Name(id='new_line', ctx=Store()), Name(id='num_subs', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='subn', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value='\\b'), op=Add(), right=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='num_str', ctx=Load())], keywords=[])), op=Add(), right=Constant(value='\\b')), Call(func=Name(id='num2words', ctx=Load()), args=[Name(id='num', ctx=Load())], keywords=[]), Subscript(value=Name(id='line', ctx=Load()), slice=Slice(lower=Name(id='current_index', ctx=Load())), ctx=Load()), Constant(value=1)], keywords=[])), AugAssign(target=Name(id='num_subs_total', ctx=Store()), op=Add(), value=Name(id='num_subs', ctx=Load())), Assign(targets=[Name(id='line', ctx=Store())], value=BinOp(left=Subscript(value=Name(id='line', ctx=Load()), slice=Slice(upper=Name(id='current_index', ctx=Load())), ctx=Load()), op=Add(), right=Name(id='new_line', ctx=Load()))), Assign(targets=[Name(id='current_index', ctx=Store())], value=Name(id='end_index', ctx=Load()))], orelse=[Expr(value=Call(func=Name(id='print_num_exception', ctx=Load()), args=[Subscript(value=Name(id='line', ctx=Load()), slice=Slice(lower=Name(id='current_index', ctx=Load()), upper=Name(id='end_index', ctx=Load())), ctx=Load()), Name(id='line_number', ctx=Load()), Name(id='num_metadata_lines', ctx=Load()), Name(id='printed_exceptions', ctx=Load()), Constant(value='proper name'), Name(id='line', ctx=Load())], keywords=[]))])], orelse=[]), Assign(targets=[Name(id='current_index', ctx=Store())], value=Name(id='end_index', ctx=Load()))], orelse=[AugAssign(target=Name(id='current_index', ctx=Store()), op=Add(), value=Constant(value=1))])], orelse=[]), Return(value=Tuple(elts=[Name(id='line', ctx=Load()), Name(id='num_subs_total', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='convert_num_line_capitalization', args=arguments(posonlyargs=[], args=[arg(arg='line'), arg(arg='num'), arg(arg='num_str')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=' \n    Capitalize the numeral word at the beginning of a sentence or after punctuation.\n\n    :param line: the line of text in which to perform capitalization.\n    :param num: the numerical value to convert to words.\n    :param num_str: the string representation of the number to find in the line.\n    :return: a tuple containing the modified line and the total number of substitutions made.\n    ')), Assign(targets=[Name(id='num_subs_total', ctx=Store())], value=Constant(value=0)), For(target=Name(id='punctuation', ctx=Store()), iter=List(elts=[Constant(value='.'), Constant(value='?'), Constant(value='!')], ctx=Load()), body=[Assign(targets=[Name(id='pattern', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Constant(value='(^|['), op=Add(), right=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='punctuation', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=']\\s)')), op=Add(), right=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='num_str', ctx=Load())], keywords=[])), op=Add(), right=Constant(value='(?=[\\s,]|$)'))), Assign(targets=[Tuple(elts=[Name(id='new_line', ctx=Store()), Name(id='num_subs', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='subn', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='match')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=BinOp(left=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=1)], keywords=[]), op=Add(), right=Call(func=Attribute(value=Call(func=Name(id='num2words', ctx=Load()), args=[Name(id='num', ctx=Load())], keywords=[]), attr='capitalize', ctx=Load()), args=[], keywords=[]))), Name(id='line', ctx=Load())], keywords=[])), AugAssign(target=Name(id='num_subs_total', ctx=Store()), op=Add(), value=Name(id='num_subs', ctx=Load())), If(test=Compare(left=Name(id='num_subs', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='line', ctx=Store())], value=Name(id='new_line', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Tuple(elts=[Name(id='line', ctx=Load()), Name(id='num_subs_total', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='skip_speaker_line_with_timestamp', args=arguments(posonlyargs=[], args=[arg(arg='line')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=' \n    Determine if a line contains a single timestamp with max_words before the timestamp less that get_timestamp default val (8) and is therefore a speaker line to skip.\n\n    :param line: The line of text to be checked for a timestamp.\n    :return: boolean where True if a timestamp is found, otherwise False.\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='get_timestamp')], level=0), Assign(targets=[Name(id='timestamp_result', ctx=Store())], value=Call(func=Name(id='get_timestamp', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])), Return(value=BoolOp(op=And(), values=[Name(id='timestamp_result', ctx=Load()), Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='value', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='timestamp_result', ctx=Load()), ifs=[], is_async=0)])], keywords=[])]))], decorator_list=[]), FunctionDef(name='convert_num_lines', args=arguments(posonlyargs=[], args=[arg(arg='lines'), arg(arg='num'), arg(arg='num_str'), arg(arg='num_metadata_lines'), arg(arg='verbose'), arg(arg='printed_exceptions')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=' \n    Converts numbers in lines of text to their word equivalents, handles capitalization, and skips lines with timestamps.\n    Takes both num and num_str as separate parameters to provide flexibility in how the function is called.\n    This design allows the caller to specify the string representation of the number 1 that should be searched for within the text lines,\n    which may not always be a straightforward string conversion of num.\n    For example, num could be an integer, but num_str could be a formatted string that represents the number\n    in a specific way within the text (e.g., "001" instead of "1", or "1st" for the ordinal form).\n    \n    :param lines: list of text lines to process.\n    :param num: the numerical value to convert to words.\n    :param num_str: the string representation of the number to find in the lines.\n    :param num_metadata_lines: the number of metadata lines in the document to adjust line numbering for output.\n    :param verbose: boolean indicating whether to print the conversion output.\n    :param printed_exceptions: list to record any exceptions encountered during processing.\n    :return: tuple containing the list of processed lines and the total number of substitutions made.\n    ')), Assign(targets=[Name(id='num_subs_total', ctx=Store())], value=Constant(value=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='line', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='skip_speaker_line_with_timestamp', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[]), body=[Continue()], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='line', ctx=Store()), Name(id='num_subs', ctx=Store())], ctx=Store())], value=Call(func=Name(id='convert_num_line_capitalization', ctx=Load()), args=[Name(id='line', ctx=Load()), Name(id='num', ctx=Load()), Name(id='num_str', ctx=Load())], keywords=[])), AugAssign(target=Name(id='num_subs_total', ctx=Store()), op=Add(), value=Name(id='num_subs', ctx=Load())), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='num_subs', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), Name(id='verbose', ctx=Load())]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='  convert in line '), FormattedValue(value=BinOp(left=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1)), op=Add(), right=Name(id='num_metadata_lines', ctx=Load())), conversion=-1), Constant(value=' the number: '), FormattedValue(value=Name(id='num', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='line', ctx=Store()), Name(id='num_subs', ctx=Store())], ctx=Store())], value=Call(func=Name(id='convert_num_line_lowercase', ctx=Load()), args=[Name(id='line', ctx=Load()), Name(id='num', ctx=Load()), Name(id='num_str', ctx=Load()), Name(id='i', ctx=Load()), Name(id='num_metadata_lines', ctx=Load()), Name(id='printed_exceptions', ctx=Load()), Name(id='common_english_vocab', ctx=Load())], keywords=[])), AugAssign(target=Name(id='num_subs_total', ctx=Store()), op=Add(), value=Name(id='num_subs', ctx=Load())), Assign(targets=[Subscript(value=Name(id='lines', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Store())], value=Name(id='line', ctx=Load()))], orelse=[]), Return(value=Tuple(elts=[Name(id='lines', ctx=Load()), Name(id='num_subs_total', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='convert_numbers_in_content', args=arguments(posonlyargs=[], args=[arg(arg='content'), arg(arg='num_limit'), arg(arg='additional_numbers'), arg(arg='num_metadata_lines'), arg(arg='print_output')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=' \n    Converts numerical values in text content to their word equivalents, excluding lines with timestamps.\n\n    :param content: string containing the text content to be processed.\n    :param num_limit: integer representing the upper limit for numbers to convert.\n    :param additional_numbers: list of additional numbers to be converted outside the standard range.\n    :param num_metadata_lines: integer representing the number of metadata lines in the content.\n    :param print_output: boolean indicating whether to print the conversion output.\n    :return: tuple containing the converted content as a string and the total number of substitutions made.\n    ')), Assign(targets=[Name(id='lines', ctx=Store())], value=Call(func=Attribute(value=Name(id='content', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[])), Assign(targets=[Name(id='num_subs_total', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='printed_exceptions', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='num', ctx=Store()), iter=BinOp(left=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='num_limit', ctx=Load())], keywords=[])], keywords=[]), op=Add(), right=Name(id='additional_numbers', ctx=Load())), body=[Assign(targets=[Name(id='num_str', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='num', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='lines', ctx=Store()), Name(id='num_subs', ctx=Store())], ctx=Store())], value=Call(func=Name(id='convert_num_lines', ctx=Load()), args=[Name(id='lines', ctx=Load()), Name(id='num', ctx=Load()), Name(id='num_str', ctx=Load()), Name(id='num_metadata_lines', ctx=Load()), Name(id='print_output', ctx=Load()), Name(id='printed_exceptions', ctx=Load())], keywords=[])), AugAssign(target=Name(id='num_subs_total', ctx=Store()), op=Add(), value=Name(id='num_subs', ctx=Load()))], orelse=[]), Return(value=Tuple(elts=[Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[]), Name(id='num_subs_total', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='convert_ordinals_in_content', args=arguments(posonlyargs=[], args=[arg(arg='content'), arg(arg='punct_capitalization')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=' \n    Converts ordinal numbers in a string of text to their word equivalents and capitalizes words following specified punctuation.\n\n    :param content: string of text containing ordinal numbers and punctuation.\n    :param punct_capitalization: list of punctuation characters after which the following word should be capitalized.\n    :return: string of text with ordinal numbers converted and words capitalized as specified.\n    ')), Assign(targets=[Name(id='ordinal_map', ctx=Store())], value=Dict(keys=[Constant(value='1st'), Constant(value='2nd'), Constant(value='3rd'), Constant(value='4th'), Constant(value='5th'), Constant(value='6th'), Constant(value='7th'), Constant(value='8th'), Constant(value='9th')], values=[Constant(value='first'), Constant(value='second'), Constant(value='third'), Constant(value='fourth'), Constant(value='fifth'), Constant(value='sixth'), Constant(value='seventh'), Constant(value='eighth'), Constant(value='ninth')])), Assign(targets=[Name(id='converted_content', ctx=Store())], value=Name(id='content', ctx=Load())), For(target=Tuple(elts=[Name(id='ordinal', ctx=Store()), Name(id='word', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='ordinal_map', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='converted_content', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[BinOp(left=BinOp(left=Constant(value='\\b'), op=Add(), right=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='ordinal', ctx=Load())], keywords=[])), op=Add(), right=Constant(value='\\b')), Name(id='word', ctx=Load()), Name(id='converted_content', ctx=Load())], keywords=[]))], orelse=[]), For(target=Name(id='punctuation', ctx=Store()), iter=Name(id='punct_capitalization', ctx=Load()), body=[Assign(targets=[Name(id='pattern', ctx=Store())], value=BinOp(left=BinOp(left=Constant(value='(^|['), op=Add(), right=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='escape', ctx=Load()), args=[Name(id='punctuation', ctx=Load())], keywords=[])), op=Add(), right=Constant(value=']\\s)(\\w)'))), Assign(targets=[Name(id='converted_content', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[Name(id='pattern', ctx=Load()), Lambda(args=arguments(posonlyargs=[], args=[arg(arg='match')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=BinOp(left=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=1)], keywords=[]), op=Add(), right=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=2)], keywords=[]), attr='upper', ctx=Load()), args=[], keywords=[]))), Name(id='converted_content', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='converted_content', ctx=Load()))], decorator_list=[]), FunctionDef(name='convert_nums_to_words', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='verbose')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='\n    Converts numerals in the content of a file to their corresponding words, appends a specified suffix to the filename, and creates a new file with the converted content.\n\n    :param file_path: string of the path to the original file.\n    :param verbose: boolean for printing verbose messages. Defaults to False.\n    :return: string of the path to the newly created file with the converted content.\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='read_file_flex'), alias(name='write_metadata_and_content'), alias(name='verbose_print')], level=0), Assign(targets=[Name(id='num_limit', ctx=Store())], value=Constant(value=10)), Assign(targets=[Name(id='additional_numbers', ctx=Store())], value=List(elts=[Constant(value=1000000), Constant(value=1000000000), Constant(value=1000000000000)], ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='metadata', ctx=Store()), Name(id='content', ctx=Store())], ctx=Store())], value=Call(func=Name(id='read_file_flex', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_metadata_lines', ctx=Store())], value=IfExp(test=Compare(left=Name(id='metadata', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=Constant(value=0), orelse=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Attribute(value=Name(id='metadata', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[])], keywords=[]))), Assign(targets=[Name(id='content', ctx=Store())], value=Call(func=Name(id='convert_ordinals_in_content', ctx=Load()), args=[Name(id='content', ctx=Load()), List(elts=[Constant(value='.'), Constant(value='?'), Constant(value='!')], ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='converted_content', ctx=Store()), Name(id='num_subs_total', ctx=Store())], ctx=Store())], value=Call(func=Name(id='convert_numbers_in_content', ctx=Load()), args=[Name(id='content', ctx=Load()), Name(id='num_limit', ctx=Load()), Name(id='additional_numbers', ctx=Load()), Name(id='num_metadata_lines', ctx=Load()), Name(id='verbose', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), Constant(value='Review and fix manually: addresses')], keywords=[])), Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='END convert_nums_to_words - Conversion Count: '), FormattedValue(value=Name(id='num_subs_total', ctx=Load()), conversion=-1), Constant(value='\n')])], keywords=[])), Expr(value=Call(func=Name(id='write_metadata_and_content', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='metadata', ctx=Load()), Name(id='converted_content', ctx=Load())], keywords=[keyword(arg='overwrite', value=Constant(value='yes'))])), Return(value=Name(id='file_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='read_speaker_names_from_json', args=arguments(posonlyargs=[], args=[arg(arg='json_file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=" \n    Reads speaker names from a JSON file's metadata, which have been inserted by us and are not in the raw deepgram json files.\n\n    :param json_file_path: string of the path to the JSON file.\n    :return: list of speaker names if they exist, otherwise an empty list.\n    ")), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='json_file_path', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='The file path does not exist for '), FormattedValue(value=Name(id='json_file_path', ctx=Load()), conversion=-1), Constant(value='.')])], keywords=[]))], orelse=[]), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='json_file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='data', ctx=Store())], value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='load', ctx=Load()), args=[Name(id='file', ctx=Load())], keywords=[]))]), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='metadata'), Dict(keys=[], values=[])], keywords=[]), attr='get', ctx=Load()), args=[Constant(value='speaker_names'), List(elts=[], ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='write_speaker_names_to_json', args=arguments(posonlyargs=[], args=[arg(arg='json_file_path'), arg(arg='speaker_names'), arg(arg='verbose')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value=" \n    Writes speaker names to a JSON file's metadata. Overwrites file.\n\n    :param json_file_path: string of the path to the JSON file.\n    :param speaker_names: list of strings containing speaker names.\n    :return: None.\n    ")), ImportFrom(module='primary.fileops', names=[alias(name='verbose_print')], level=0), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='json_file_path', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='The file path does not exist for '), FormattedValue(value=Name(id='json_file_path', ctx=Load()), conversion=-1), Constant(value='.')])], keywords=[]))], orelse=[]), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='json_file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='data', ctx=Store())], value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='load', ctx=Load()), args=[Name(id='file', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='speaker_names_updated', ctx=Store())], value=Constant(value=False)), If(test=BoolOp(op=And(), values=[Compare(left=Constant(value='metadata'), ops=[In()], comparators=[Name(id='data', ctx=Load())]), Compare(left=Constant(value='speaker_names'), ops=[In()], comparators=[Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='metadata'), ctx=Load())])]), body=[If(test=Compare(left=Subscript(value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='metadata'), ctx=Load()), slice=Constant(value='speaker_names'), ctx=Load()), ops=[NotEq()], comparators=[Name(id='speaker_names', ctx=Load())]), body=[Assign(targets=[Subscript(value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='metadata'), ctx=Load()), slice=Constant(value='speaker_names'), ctx=Store())], value=Name(id='speaker_names', ctx=Load())), Assign(targets=[Name(id='speaker_names_updated', ctx=Store())], value=Constant(value=True))], orelse=[])], orelse=[Expr(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='setdefault', ctx=Load()), args=[Constant(value='metadata'), Dict(keys=[], values=[])], keywords=[]), attr='update', ctx=Load()), args=[Dict(keys=[Constant(value='speaker_names')], values=[Name(id='speaker_names', ctx=Load())])], keywords=[])), Assign(targets=[Name(id='speaker_names_updated', ctx=Store())], value=Constant(value=True))]), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='json_file_path', ctx=Load()), Constant(value='w')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Expr(value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='dump', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='file', ctx=Load())], keywords=[keyword(arg='indent', value=Constant(value=4))]))]), If(test=Name(id='speaker_names_updated', ctx=Load()), body=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='Speaker names in the JSON have been updated.')])], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='Speaker names in the JSON are unchanged.')])], keywords=[]))])], decorator_list=[]), FunctionDef(name='find_unassigned_speakers', args=arguments(posonlyargs=[], args=[arg(arg='md_file_path'), arg(arg='verbose')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value=" \n    Identifies speakers in the markdown file who do not have assigned names.\n    This is determined by if the line has a valid timestamp and then looking for 'Speaker X' before the timestamp.\n\n    :param md_file_path: string of the path to the markdown file.\n    :return: list of strings of unassigned speaker names, or None if all speakers are assigned.\n    ")), ImportFrom(module='primary.fileops', names=[alias(name='verbose_print'), alias(name='get_timestamp')], level=0), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='md_file_path', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='The file path does not exist for '), FormattedValue(value=Name(id='md_file_path', ctx=Load()), conversion=-1), Constant(value='.')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='unassigned_speaker_numbers', ctx=Store())], value=List(elts=[], ctx=Load())), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='md_file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='md_file', ctx=Store()))], body=[For(target=Name(id='line', ctx=Store()), iter=Name(id='md_file', ctx=Load()), body=[Assign(targets=[Name(id='timestamp_index', ctx=Store())], value=Call(func=Name(id='get_timestamp', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])), If(test=Name(id='timestamp_index', ctx=Load()), body=[Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='search', ctx=Load()), args=[Constant(value='Speaker\\s+(\\d+)'), Subscript(value=Name(id='line', ctx=Load()), slice=Slice(upper=Subscript(value=Name(id='timestamp_index', ctx=Load()), slice=Constant(value=1), ctx=Load())), ctx=Load())], keywords=[])), If(test=Name(id='match', ctx=Load()), body=[Assign(targets=[Name(id='speaker_number', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='group', ctx=Load()), args=[Constant(value=1)], keywords=[])], keywords=[])), If(test=Compare(left=Name(id='speaker_number', ctx=Load()), ops=[NotIn()], comparators=[Name(id='unassigned_speaker_numbers', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='unassigned_speaker_numbers', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='speaker_number', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[])], orelse=[])]), Expr(value=Call(func=Attribute(value=Name(id='unassigned_speaker_numbers', ctx=Load()), attr='sort', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='unassigned_speakers', ctx=Store())], value=ListComp(elt=JoinedStr(values=[Constant(value='Speaker '), FormattedValue(value=Name(id='number', ctx=Load()), conversion=-1)]), generators=[comprehension(target=Name(id='number', ctx=Store()), iter=Name(id='unassigned_speaker_numbers', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='num_unassigned', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='unassigned_speakers', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='num_unassigned', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='From find_unassigned_speakers - Number of speakers not assigned names: '), FormattedValue(value=Name(id='num_unassigned', ctx=Load()), conversion=-1), Constant(value='. Speaker names: '), FormattedValue(value=Call(func=Attribute(value=Constant(value=' '), attr='join', ctx=Load()), args=[Name(id='unassigned_speakers', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[])), Return(value=Name(id='unassigned_speakers', ctx=Load()))], orelse=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='From find_unassigned_speakers - All speakers have been assigned names.')])], keywords=[])), Return(value=Constant(value=None))])], decorator_list=[]), FunctionDef(name='propagate_speaker_names_throughout_md', args=arguments(posonlyargs=[], args=[arg(arg='md_file_path'), arg(arg='input_speaker_names')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n    Propagates speaker names throughout a markdown file based on provided input names or existing assignments.\n\n    :param md_file_path: string of the path to the markdown file.\n    :param input_speaker_names: list of tuples with speaker numbers and names, if available.\n    :return: list of tuples with speaker numbers and names after propagation.\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='get_timestamp')], level=0), Assign(targets=[Name(id='speaker_names', ctx=Store())], value=IfExp(test=Name(id='input_speaker_names', ctx=Load()), body=Call(func=Attribute(value=Name(id='input_speaker_names', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]), orelse=List(elts=[], ctx=Load()))), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='md_file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='content', ctx=Store())], value=Call(func=Attribute(value=Name(id='file', ctx=Load()), attr='readlines', ctx=Load()), args=[], keywords=[]))]), Assign(targets=[Name(id='updated_content', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='line', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='content', ctx=Load())], keywords=[]), body=[Assign(targets=[Tuple(elts=[Name(id='_', ctx=Store()), Name(id='index', ctx=Store())], ctx=Store())], value=Call(func=Name(id='get_timestamp', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[keyword(arg='max_words', value=Constant(value=10))])), If(test=Compare(left=Name(id='index', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='search', ctx=Load()), args=[Constant(value='Speaker\\s+(\\d+)\\s*=\\s*(.+)'), Subscript(value=Name(id='line', ctx=Load()), slice=Slice(upper=Name(id='index', ctx=Load())), ctx=Load())], keywords=[])), If(test=Name(id='match', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='speaker_num', ctx=Store()), Name(id='name', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='groups', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='speaker_num', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Name(id='speaker_num', ctx=Load())], keywords=[])), Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Tuple(elts=[Name(id='speaker_num', ctx=Load()), Name(id='name', ctx=Load())], ctx=Load()), ops=[NotIn()], comparators=[Name(id='speaker_names', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='speaker_names', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='speaker_num', ctx=Load()), Name(id='name', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='line', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1), Constant(value='  '), FormattedValue(value=Call(func=Attribute(value=Subscript(value=Name(id='line', ctx=Load()), slice=Slice(lower=Name(id='index', ctx=Load())), ctx=Load()), attr='lstrip', ctx=Load()), args=[], keywords=[]), conversion=-1)]))], orelse=[For(target=Tuple(elts=[Name(id='spkr_num', ctx=Store()), Name(id='spkr_name', ctx=Store())], ctx=Store()), iter=Name(id='speaker_names', ctx=Load()), body=[Assign(targets=[Name(id='line', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[JoinedStr(values=[Constant(value='\\bSpeaker '), FormattedValue(value=Name(id='spkr_num', ctx=Load()), conversion=-1), Constant(value='\\b\\s*')]), JoinedStr(values=[FormattedValue(value=Name(id='spkr_name', ctx=Load()), conversion=-1), Constant(value='  ')]), Name(id='line', ctx=Load())], keywords=[]))], orelse=[])])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='updated_content', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[]))], orelse=[]), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='updated_content', ctx=Load())], keywords=[]), op=Sub(), right=Constant(value=1)), UnaryOp(op=USub(), operand=Constant(value=1)), UnaryOp(op=USub(), operand=Constant(value=1))], keywords=[]), body=[Assign(targets=[Name(id='line', ctx=Store())], value=Subscript(value=Name(id='updated_content', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='_', ctx=Store()), Name(id='index', ctx=Store())], ctx=Store())], value=Call(func=Name(id='get_timestamp', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[keyword(arg='max_words', value=Constant(value=10))])), If(test=Compare(left=Name(id='index', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[For(target=Tuple(elts=[Name(id='spkr_num', ctx=Store()), Name(id='spkr_name', ctx=Store())], ctx=Store()), iter=Name(id='speaker_names', ctx=Load()), body=[Assign(targets=[Name(id='line', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[JoinedStr(values=[Constant(value='\\bSpeaker '), FormattedValue(value=Name(id='spkr_num', ctx=Load()), conversion=-1), Constant(value='\\b\\s*')]), JoinedStr(values=[FormattedValue(value=Name(id='spkr_name', ctx=Load()), conversion=-1), Constant(value='  ')]), Name(id='line', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Subscript(value=Name(id='updated_content', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Store())], value=Name(id='line', ctx=Load()))], orelse=[])], orelse=[]), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='md_file_path', ctx=Load()), Constant(value='w')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Expr(value=Call(func=Attribute(value=Name(id='file', ctx=Load()), attr='writelines', ctx=Load()), args=[Name(id='updated_content', ctx=Load())], keywords=[]))]), Expr(value=Call(func=Attribute(value=Name(id='speaker_names', ctx=Load()), attr='sort', ctx=Load()), args=[], keywords=[keyword(arg='key', value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Subscript(value=Name(id='x', ctx=Load()), slice=Constant(value=0), ctx=Load())))])), Return(value=Name(id='speaker_names', ctx=Load()))], decorator_list=[]), FunctionDef(name='iterate_input_speaker_names', args=arguments(posonlyargs=[], args=[arg(arg='md_file_path'), arg(arg='input_speaker_names')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n    Iterates over input speaker names and updates the markdown file until the user decides to exit.\n\n    :param md_file_path: string of the path to the markdown file.\n    :param input_speaker_names: list of tuples with speaker numbers and names, if available.\n    :return: list of tuples with speaker numbers and names after all iterations.\n    ')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='md_file_path', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='The file path does not exist for '), FormattedValue(value=Name(id='md_file_path', ctx=Load()), conversion=-1), Constant(value='.')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='overall_speaker_names', ctx=Store())], value=IfExp(test=Name(id='input_speaker_names', ctx=Load()), body=Call(func=Attribute(value=Name(id='input_speaker_names', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[]), orelse=List(elts=[], ctx=Load()))), While(test=Constant(value=True), body=[Assign(targets=[Name(id='current_speaker_names', ctx=Store())], value=Call(func=Name(id='propagate_speaker_names_throughout_md', ctx=Load()), args=[Name(id='md_file_path', ctx=Load()), Name(id='overall_speaker_names', ctx=Load())], keywords=[])), For(target=Name(id='speaker_name', ctx=Store()), iter=Name(id='current_speaker_names', ctx=Load()), body=[If(test=Compare(left=Name(id='speaker_name', ctx=Load()), ops=[NotIn()], comparators=[Name(id='overall_speaker_names', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='overall_speaker_names', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='speaker_name', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='overall_speaker_names', ctx=Load()), attr='sort', ctx=Load()), args=[], keywords=[keyword(arg='key', value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Subscript(value=Name(id='x', ctx=Load()), slice=Constant(value=0), ctx=Load())))])), If(test=UnaryOp(op=Not(), operand=Name(id='overall_speaker_names', ctx=Load())), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='No Speaker Names')], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Current speaker_names:')], keywords=[])), For(target=Tuple(elts=[Name(id='num', ctx=Store()), Name(id='name', ctx=Store())], ctx=Store()), iter=Name(id='overall_speaker_names', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Speaker '), FormattedValue(value=Name(id='num', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[])]), Assign(targets=[Name(id='continue_prompt', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='input', ctx=Load()), args=[Constant(value='\nASSIGN SPEAKER NAMES NOW - hit enter to continue or E/exit to exit: ')], keywords=[]), attr='strip', ctx=Load()), args=[], keywords=[]), attr='lower', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='continue_prompt', ctx=Load()), ops=[Eq()], comparators=[Constant(value='')]), body=[Continue()], orelse=[If(test=Compare(left=Name(id='continue_prompt', ctx=Load()), ops=[In()], comparators=[List(elts=[Constant(value='e'), Constant(value='exit')], ctx=Load())]), body=[Assign(targets=[Name(id='unassigned_speakers', ctx=Store())], value=Call(func=Name(id='find_unassigned_speakers', ctx=Load()), args=[Name(id='md_file_path', ctx=Load())], keywords=[])), If(test=Name(id='unassigned_speakers', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Unassigned speakers:')], keywords=[])), For(target=Name(id='spkr', ctx=Store()), iter=Name(id='unassigned_speakers', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='  '), FormattedValue(value=Name(id='spkr', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[])], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='All speakers have been assigned.')], keywords=[]))]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='\nAssigned speaker names:')], keywords=[])), For(target=Tuple(elts=[Name(id='num', ctx=Store()), Name(id='name', ctx=Store())], ctx=Store()), iter=Name(id='overall_speaker_names', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='  Speaker '), FormattedValue(value=Name(id='num', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), Return(value=Name(id='overall_speaker_names', ctx=Load()))], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value="Invalid input. Please either hit enter to continue or type 'E'/'Exit' to exit.")], keywords=[]))])])], orelse=[])], decorator_list=[]), FunctionDef(name='assign_speaker_names', args=arguments(posonlyargs=[], args=[arg(arg='md_file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Assigns speaker names to markdown file by reading from a corresponding JSON file, updating, and writing back to the json if changed.\n    Prompts the user iteratively through assigning the names.\n    \n    :param md_file_path: string of the path to the markdown file.\n    :return: None\n    ')), Assign(targets=[Name(id='json_file_path', ctx=Store())], value=Call(func=Attribute(value=Name(id='md_file_path', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='.md'), Constant(value='.json')], keywords=[])), Try(body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='json_file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='speaker_names', ctx=Store())], value=Call(func=Name(id='read_speaker_names_from_json', ctx=Load()), args=[Name(id='json_file_path', ctx=Load())], keywords=[]))])], handlers=[ExceptHandler(type=Name(id='FileNotFoundError', ctx=Load()), body=[Assign(targets=[Name(id='speaker_names', ctx=Store())], value=List(elts=[], ctx=Load()))])], orelse=[], finalbody=[]), Assign(targets=[Name(id='updated_speaker_names', ctx=Store())], value=Call(func=Name(id='iterate_input_speaker_names', ctx=Load()), args=[Name(id='md_file_path', ctx=Load()), Name(id='speaker_names', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='updated_speaker_names', ctx=Load()), ops=[NotEq()], comparators=[Name(id='speaker_names', ctx=Load())]), body=[Expr(value=Call(func=Name(id='write_speaker_names_to_json', ctx=Load()), args=[Name(id='json_file_path', ctx=Load()), Name(id='updated_speaker_names', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='create_transcript_md_from_json', args=arguments(posonlyargs=[], args=[arg(arg='json_file_path'), arg(arg='combine_segs')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='\n    Creates a markdown transcript from a JSON file containing Deepgram transcription data.\n    If combine_segs is True, combines consecutive segments from the same speaker.\n\n    :param json_file_path: string of the path to the json file containing transcription data.\n    :param combine_segs: boolean indicating whether to combine consecutive segments from the same speaker.\n    :return: string of the path to the created markdown file or None if the json file is not valid.\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='create_initial_metadata'), alias(name='convert_seconds_to_timestamp'), alias(name='set_metadata_field')], level=0), ImportFrom(module='primary.fileops', names=[alias(name='write_metadata_and_content'), alias(name='add_timestamp_links')], level=0), Assign(targets=[Name(id='md_file_path', ctx=Store())], value=BinOp(left=Subscript(value=Name(id='json_file_path', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=5))), ctx=Load()), op=Add(), right=Constant(value='.md'))), Assign(targets=[Name(id='link', ctx=Store())], value=Call(func=Name(id='get_link_from_json', ctx=Load()), args=[Name(id='json_file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='lines', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='validate_transcript_json', ctx=Load()), args=[Name(id='json_file_path', ctx=Load())], keywords=[])), body=[Return(value=Constant(value=None))], orelse=[]), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='json_file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='data', ctx=Store())], value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='load', ctx=Load()), args=[Name(id='file', ctx=Load())], keywords=[])), Assign(targets=[Name(id='model_name', ctx=Store())], value=Subscript(value=Subscript(value=Subscript(value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='metadata'), ctx=Load()), slice=Constant(value='model_info'), ctx=Load()), slice=Subscript(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Subscript(value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='metadata'), ctx=Load()), slice=Constant(value='model_info'), ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[]), slice=Constant(value=0), ctx=Load()), ctx=Load()), slice=Constant(value='name'), ctx=Load())), Assign(targets=[Name(id='paragraph_data', ctx=Store())], value=Subscript(value=Subscript(value=Subscript(value=Subscript(value=Subscript(value=Subscript(value=Subscript(value=Name(id='data', ctx=Load()), slice=Constant(value='results'), ctx=Load()), slice=Constant(value='channels'), ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Constant(value='alternatives'), ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Constant(value='paragraphs'), ctx=Load()), slice=Constant(value='paragraphs'), ctx=Load())), Assign(targets=[Name(id='curr_speaker', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='curr_timestamp', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='curr_transcript', ctx=Store())], value=Constant(value='')), For(target=Name(id='para', ctx=Store()), iter=Name(id='paragraph_data', ctx=Load()), body=[Assign(targets=[Name(id='speaker_id', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='para', ctx=Load()), slice=Constant(value='speaker'), ctx=Load())], keywords=[])), Assign(targets=[Name(id='speaker', ctx=Store())], value=JoinedStr(values=[Constant(value='Speaker '), FormattedValue(value=Name(id='speaker_id', ctx=Load()), conversion=-1)])), Assign(targets=[Name(id='start_timestamp', ctx=Store())], value=Call(func=Name(id='convert_seconds_to_timestamp', ctx=Load()), args=[Subscript(value=Name(id='para', ctx=Load()), slice=Constant(value='start'), ctx=Load())], keywords=[])), Assign(targets=[Name(id='sentences', ctx=Store())], value=Call(func=Attribute(value=Name(id='para', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='sentences'), List(elts=[], ctx=Load())], keywords=[])), Assign(targets=[Name(id='transcript', ctx=Store())], value=Call(func=Attribute(value=Constant(value=' '), attr='join', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='sentence', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='text'), Constant(value='')], keywords=[]), generators=[comprehension(target=Name(id='sentence', ctx=Store()), iter=Name(id='sentences', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), If(test=BoolOp(op=And(), values=[Name(id='combine_segs', ctx=Load()), Compare(left=Name(id='speaker', ctx=Load()), ops=[Eq()], comparators=[Name(id='curr_speaker', ctx=Load())])]), body=[AugAssign(target=Name(id='curr_transcript', ctx=Store()), op=Add(), value=BinOp(left=Constant(value=' '), op=Add(), right=Name(id='transcript', ctx=Load())))], orelse=[If(test=Name(id='curr_transcript', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='extend', ctx=Load()), args=[List(elts=[BinOp(left=BinOp(left=Name(id='curr_speaker', ctx=Load()), op=Add(), right=Constant(value='  ')), op=Add(), right=Name(id='curr_timestamp', ctx=Load())), Name(id='curr_transcript', ctx=Load()), Constant(value='')], ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='curr_speaker', ctx=Store())], value=Name(id='speaker', ctx=Load())), Assign(targets=[Name(id='curr_timestamp', ctx=Store())], value=Name(id='start_timestamp', ctx=Load())), Assign(targets=[Name(id='curr_transcript', ctx=Store())], value=Name(id='transcript', ctx=Load()))])], orelse=[]), If(test=Name(id='curr_transcript', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='lines', ctx=Load()), attr='extend', ctx=Load()), args=[List(elts=[BinOp(left=BinOp(left=Name(id='curr_speaker', ctx=Load()), op=Add(), right=Constant(value='  ')), op=Add(), right=Name(id='curr_timestamp', ctx=Load())), Name(id='curr_transcript', ctx=Load()), Constant(value='')], ctx=Load())], keywords=[]))], orelse=[])]), Assign(targets=[Name(id='content', ctx=Store())], value=BinOp(left=Constant(value='## content\n\n### transcript\n\n'), op=Add(), right=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[]))), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='DEBUG - content: '), FormattedValue(value=Name(id='content', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Name(id='create_initial_metadata', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='date_today', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='datetime', ctx=Load()), attr='now', ctx=Load()), args=[], keywords=[]), attr='strftime', ctx=Load()), args=[Constant(value='%m-%d-%Y')], keywords=[])), Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Name(id='set_metadata_field', ctx=Load()), args=[Name(id='metadata', ctx=Load()), Constant(value='last updated'), BinOp(left=Name(id='date_today', ctx=Load()), op=Add(), right=Constant(value=' Created'))], keywords=[])), Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Name(id='set_metadata_field', ctx=Load()), args=[Name(id='metadata', ctx=Load()), Constant(value='link'), Name(id='link', ctx=Load())], keywords=[])), Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Name(id='set_metadata_field', ctx=Load()), args=[Name(id='metadata', ctx=Load()), Constant(value='transcript source'), BinOp(left=Constant(value='deepgram '), op=Add(), right=Name(id='model_name', ctx=Load()))], keywords=[])), Expr(value=Call(func=Name(id='write_metadata_and_content', ctx=Load()), args=[Name(id='md_file_path', ctx=Load()), Name(id='metadata', ctx=Load()), Name(id='content', ctx=Load())], keywords=[keyword(arg='overwrite', value=Constant(value='yes'))])), Expr(value=Call(func=Name(id='convert_nums_to_words', ctx=Load()), args=[Name(id='md_file_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='add_timestamp_links', ctx=Load()), args=[Name(id='md_file_path', ctx=Load())], keywords=[])), Return(value=Name(id='md_file_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='process_deepgram_transcription', args=arguments(posonlyargs=[], args=[arg(arg='title'), arg(arg='link'), arg(arg='model'), arg(arg='audio_inbox_path')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='data/audio_inbox')]), body=[Expr(value=Constant(value='\n    Processes a Deepgram transcription from a YouTube video link by downloading the audio, transcribing it, and creating a markdown transcript.\n\n    :param title: the title of the video used to name the downloaded audio file.\n    :param link: the YouTube link to the video to be transcribed.\n    :param model: the Deepgram model used for transcription.\n    :param audio_inbox_path: the directory path where the audio file will be downloaded.\n    :return: the path to the created markdown file or None if transcription fails.\n    ')), Assign(targets=[Name(id='audio_file_path', ctx=Store())], value=Call(func=Name(id='download_mp3_from_youtube', ctx=Load()), args=[Name(id='link', ctx=Load()), JoinedStr(values=[FormattedValue(value=Name(id='audio_inbox_path', ctx=Load()), conversion=-1), Constant(value='/'), FormattedValue(value=Name(id='title', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='json_file_path', ctx=Store())], value=Call(func=Name(id='transcribe_deepgram', ctx=Load()), args=[Name(id='audio_file_path', ctx=Load()), Name(id='model', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='json_file_path', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='transcription failed or the file type is incorrect.')], keywords=[])), Return(value=Constant(value=None))], orelse=[]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='json_file_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='add_link_to_json', ctx=Load()), args=[Name(id='json_file_path', ctx=Load()), Name(id='link', ctx=Load())], keywords=[])), Assign(targets=[Name(id='md_file_path', ctx=Store())], value=Call(func=Name(id='create_transcript_md_from_json', ctx=Load()), args=[Name(id='json_file_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='assign_speaker_names', ctx=Load()), args=[Name(id='md_file_path', ctx=Load())], keywords=[])), Return(value=Name(id='md_file_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='process_deepgram_transcription_from_audio_file', args=arguments(posonlyargs=[], args=[arg(arg='audio_file_path'), arg(arg='link'), arg(arg='model')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=' \n    Transcribes an audio file using the Deepgram service, adds the YouTube link to the transcription, creates a markdown transcript, and assigns speaker names.\n\n    :param audio_file_path: string of the path to the audio file to be transcribed.\n    :param link: string of the youtube link to be added to the transcription json.\n    :param model: string of the deepgram model to be used for transcription.\n    :return: string of the path to the markdown file with the completed transcription or None if transcription fails.\n    ')), Assign(targets=[Name(id='json_file_path', ctx=Store())], value=Call(func=Name(id='transcribe_deepgram', ctx=Load()), args=[Name(id='audio_file_path', ctx=Load()), Name(id='model', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='json_file_path', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Transcription failed or the file type is incorrect.')], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='add_link_to_json', ctx=Load()), args=[Name(id='json_file_path', ctx=Load()), Name(id='link', ctx=Load())], keywords=[])), Assign(targets=[Name(id='md_file_path', ctx=Store())], value=Call(func=Name(id='create_transcript_md_from_json', ctx=Load()), args=[Name(id='json_file_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='assign_speaker_names', ctx=Load()), args=[Name(id='md_file_path', ctx=Load())], keywords=[])), Return(value=Name(id='md_file_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='process_multiple_videos', args=arguments(posonlyargs=[], args=[arg(arg='videos_to_process'), arg(arg='model'), arg(arg='bool_youtube')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='nova-2-general'), Constant(value=True)]), body=[Expr(value=Constant(value="\n    Processes multiple videos by transcribing them and creating YouTube markdown files if bool_youtube is True.\n\n    :param videos_to_process: list of tuples containing the title and link of each video to be processed.\n    :param model: string of the deepgram model to be used for transcription. Defaults to 'enhmeet' (deepgram enhanced-meeting) model.\n    :param bool_youtube: boolean indicating whether to create YouTube markdown files. Defaults to True.\n    :return: None\n    ")), For(target=Tuple(elts=[Name(id='title', ctx=Store()), Name(id='link', ctx=Store())], ctx=Store()), iter=Name(id='videos_to_process', ctx=Load()), body=[Try(body=[Assign(targets=[Name(id='cur_md', ctx=Store())], value=Call(func=Name(id='process_deepgram_transcription', ctx=Load()), args=[Name(id='title', ctx=Load()), Name(id='link', ctx=Load()), Name(id='model', ctx=Load())], keywords=[])), If(test=Name(id='bool_youtube', ctx=Load()), body=[Expr(value=Call(func=Name(id='create_youtube_md_from_file_link', ctx=Load()), args=[Name(id='cur_md', ctx=Load())], keywords=[]))], orelse=[])], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Error processing video '), FormattedValue(value=Name(id='title', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[]))])], orelse=[], finalbody=[])], orelse=[])], decorator_list=[])], type_ignores=[])

Module(body=[Import(names=[alias(name='sys')]), Import(names=[alias(name='os')]), Import(names=[alias(name='json')]), Import(names=[alias(name='glob')]), Import(names=[alias(name='shutil')]), Import(names=[alias(name='warnings')]), Import(names=[alias(name='requests')]), Import(names=[alias(name='tiktoken')]), Import(names=[alias(name='anthropic')]), ImportFrom(module='openai', names=[alias(name='OpenAI')], level=0), ImportFrom(module='termcolor', names=[alias(name='colored')], level=0), ImportFrom(module='tenacity', names=[alias(name='retry'), alias(name='wait_random_exponential'), alias(name='stop_after_attempt')], level=0), ImportFrom(module='config', names=[alias(name='OPENAI_API_KEY_CONFIG_LLM'), alias(name='ANTHROPIC_API_KEY_CONFIG_LLM')], level=0), ImportFrom(module='primary.fileops', names=[alias(name='*')], level=0), Import(names=[alias(name='warnings')]), Assign(targets=[Attribute(value=Name(id='warnings', ctx=Load()), attr='formatwarning', ctx=Store())], value=Name(id='custom_formatwarning', ctx=Load())), Assign(targets=[Name(id='current_dir', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='abspath', ctx=Load()), args=[Name(id='__file__', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='parent_dir', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Name(id='current_dir', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='sys', ctx=Load()), attr='path', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='parent_dir', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), slice=Constant(value='OPENAI_API_KEY_CONFIG_LLM'), ctx=Store())], value=Name(id='OPENAI_API_KEY_CONFIG_LLM', ctx=Load())), Assign(targets=[Subscript(value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), slice=Constant(value='ANTHROPIC_API_KEY'), ctx=Store())], value=Name(id='ANTHROPIC_API_KEY_CONFIG_LLM', ctx=Load())), Assign(targets=[Name(id='OPENAI_MODEL', ctx=Store())], value=Constant(value='gpt-4o-2024-08-06')), Assign(targets=[Name(id='ANTHROPIC_MODEL', ctx=Store())], value=Constant(value='claude-3-5-sonnet-20240620')), Assign(targets=[Name(id='TOKEN_COST_DICT', ctx=Store())], value=Dict(keys=[Constant(value='gpt-4o'), Constant(value='gpt-4o-2024-08-06'), Constant(value='gpt-4o-mini'), Constant(value='claude-3-5-sonnet-20240620')], values=[Dict(keys=[Constant(value='input_token_cost'), Constant(value='output_token_cost')], values=[Constant(value=5), Constant(value=15)]), Dict(keys=[Constant(value='input_token_cost'), Constant(value='output_token_cost')], values=[Constant(value=2.5), Constant(value=10)]), Dict(keys=[Constant(value='input_token_cost'), Constant(value='output_token_cost')], values=[Constant(value=0.15), Constant(value=0.6)]), Dict(keys=[Constant(value='input_token_cost'), Constant(value='output_token_cost')], values=[Constant(value=3), Constant(value=15)])])), Assign(targets=[Name(id='BLOCK_DELIMITER', ctx=Store())], value=Constant(value='\n---\n')), FunctionDef(name='pretty_print_function', args=arguments(posonlyargs=[], args=[arg(arg='messages'), arg(arg='tools'), arg(arg='print_prompts'), arg(arg='print_input'), arg(arg='verbose')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Constant(value=True), Constant(value=False)]), body=[Expr(value=Constant(value='\n    Prints messages with role-specific colors and separates function details for clarity.\n\n    :param messages: list of dictionaries containing message role and content\n    :params tools: list of tools, each containing function details, passed to pretty_print_function_descriptions\n    :param print_prompts: boolean of whether to print the system prompt and function parameter descriptions, defaults to False\n    :param print_input: boolean of whether to print the user input, defaults to True\n    :return: a list of the print strings as [print_str_prompts, print_str_input, print_str_responses]\n    ')), Assign(targets=[Name(id='role_to_color', ctx=Store())], value=Dict(keys=[Constant(value='system'), Constant(value='function parameter descriptions'), Constant(value='user'), Constant(value='assistant'), Constant(value='function responses')], values=[Constant(value='red'), Constant(value='yellow'), Constant(value='green'), Constant(value='grey'), Constant(value='magenta')])), Assign(targets=[Name(id='print_str_prompts', ctx=Store())], value=Constant(value='')), Assign(targets=[Name(id='print_str_input', ctx=Store())], value=Constant(value='')), Assign(targets=[Name(id='print_str_responses', ctx=Store())], value=Constant(value='')), Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='messages:\n'), FormattedValue(value=Name(id='messages', ctx=Load()), conversion=-1)])], keywords=[])), Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='tools:\n'), FormattedValue(value=Name(id='tools', ctx=Load()), conversion=-1)])], keywords=[])), For(target=Tuple(elts=[Name(id='index', ctx=Store()), Name(id='message', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='messages', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='Message '), FormattedValue(value=BinOp(left=Name(id='index', ctx=Load()), op=Add(), right=Constant(value=1)), conversion=-1), Constant(value=' of '), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='messages', ctx=Load())], keywords=[]), conversion=-1), Constant(value=' messages')])], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='message', ctx=Load()), slice=Constant(value='role'), ctx=Load()), ops=[Eq()], comparators=[Constant(value='system')]), Name(id='print_prompts', ctx=Load())]), body=[Assign(targets=[Name(id='print_str_prompts', ctx=Store())], value=JoinedStr(values=[Constant(value='System Prompt: '), FormattedValue(value=Subscript(value=Name(id='message', ctx=Load()), slice=Constant(value='content'), ctx=Load()), conversion=-1), Constant(value='\n')])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Name(id='colored', ctx=Load()), args=[Name(id='print_str_prompts', ctx=Load()), Subscript(value=Name(id='role_to_color', ctx=Load()), slice=Subscript(value=Name(id='message', ctx=Load()), slice=Constant(value='role'), ctx=Load()), ctx=Load())], keywords=[])], keywords=[])), If(test=Compare(left=Name(id='tools', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[AugAssign(target=Name(id='print_str_prompts', ctx=Store()), op=Add(), value=Call(func=Name(id='pretty_print_function_descriptions', ctx=Load()), args=[Name(id='tools', ctx=Load()), Subscript(value=Name(id='role_to_color', ctx=Load()), slice=Constant(value='function parameter descriptions'), ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), If(test=Compare(left=Subscript(value=Name(id='message', ctx=Load()), slice=Constant(value='role'), ctx=Load()), ops=[Eq()], comparators=[Constant(value='user')]), body=[Assign(targets=[Name(id='print_str_input', ctx=Store())], value=JoinedStr(values=[Constant(value='User Input:\n'), FormattedValue(value=Subscript(value=Name(id='message', ctx=Load()), slice=Constant(value='content'), ctx=Load()), conversion=-1), Constant(value='\n')])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Name(id='colored', ctx=Load()), args=[Name(id='print_str_input', ctx=Load()), Subscript(value=Name(id='role_to_color', ctx=Load()), slice=Subscript(value=Name(id='message', ctx=Load()), slice=Constant(value='role'), ctx=Load()), ctx=Load())], keywords=[])], keywords=[]))], orelse=[If(test=Compare(left=Subscript(value=Name(id='message', ctx=Load()), slice=Constant(value='role'), ctx=Load()), ops=[Eq()], comparators=[Constant(value='assistant')]), body=[Assign(targets=[Name(id='assistant_msg_str', ctx=Store())], value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='message', ctx=Load())], keywords=[])), Assign(targets=[Name(id='function_start_idx', ctx=Store())], value=Call(func=Attribute(value=Name(id='assistant_msg_str', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value="'function': ")], keywords=[])), Assign(targets=[Name(id='assistant_msg_part', ctx=Store())], value=Subscript(value=Name(id='assistant_msg_str', ctx=Load()), slice=Slice(upper=Name(id='function_start_idx', ctx=Load())), ctx=Load())), Assign(targets=[Name(id='function_msg_part', ctx=Store())], value=Subscript(value=Name(id='assistant_msg_str', ctx=Load()), slice=Slice(lower=Name(id='function_start_idx', ctx=Load())), ctx=Load())), If(test=Compare(left=Name(id='function_start_idx', ctx=Load()), ops=[NotEq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=[Assign(targets=[Name(id='function_name_start_idx', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='function_msg_part', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value="'name': '")], keywords=[]), op=Add(), right=Call(func=Name(id='len', ctx=Load()), args=[Constant(value="'name': '")], keywords=[]))), Assign(targets=[Name(id='function_name_end_idx', ctx=Store())], value=Call(func=Attribute(value=Name(id='function_msg_part', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value="'"), Name(id='function_name_start_idx', ctx=Load())], keywords=[])), Assign(targets=[Name(id='function_name', ctx=Store())], value=Subscript(value=Name(id='function_msg_part', ctx=Load()), slice=Slice(lower=Name(id='function_name_start_idx', ctx=Load()), upper=Name(id='function_name_end_idx', ctx=Load())), ctx=Load())), Assign(targets=[Name(id='arguments_str', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Call(func=Attribute(value=Name(id='function_msg_part', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value="'arguments': '{"), Constant(value=1)], keywords=[]), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), attr='rstrip', ctx=Load()), args=[Constant(value="}'}}]")], keywords=[])), Assign(targets=[Name(id='arguments_str', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='arguments_str', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='\\n'), Constant(value='\n')], keywords=[]), attr='replace', ctx=Load()), args=[Constant(value='\\'), Constant(value='')], keywords=[]), attr='replace', ctx=Load()), args=[Constant(value='"'), Constant(value='')], keywords=[])), Assign(targets=[Name(id='print_str_responses', ctx=Store())], value=Constant(value='Function Parameters Responses:\n')), For(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Name(id='arguments_str', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=',')], keywords=[]), body=[Assign(targets=[Name(id='key_value', ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=':'), Constant(value=1)], keywords=[])), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='key_value', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=2)]), body=[Assign(targets=[Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store())], value=Name(id='key_value', ctx=Load())), AugAssign(target=Name(id='print_str_responses', ctx=Store()), op=Add(), value=JoinedStr(values=[Constant(value='  '), FormattedValue(value=Call(func=Attribute(value=Name(id='key', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), conversion=-1), Constant(value=': '), FormattedValue(value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), conversion=-1), Constant(value='\n')]))], orelse=[AugAssign(target=Name(id='print_str_responses', ctx=Store()), op=Add(), value=JoinedStr(values=[Constant(value='  '), FormattedValue(value=Name(id='line', ctx=Load()), conversion=-1), Constant(value='\n')]))])], orelse=[]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Name(id='colored', ctx=Load()), args=[Name(id='print_str_responses', ctx=Load()), Subscript(value=Name(id='role_to_color', ctx=Load()), slice=Constant(value='function responses'), ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], orelse=[])])], orelse=[]), Return(value=List(elts=[Name(id='print_str_prompts', ctx=Load()), Name(id='print_str_input', ctx=Load()), Name(id='print_str_responses', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='pretty_print_function_descriptions', args=arguments(posonlyargs=[], args=[arg(arg='tools'), arg(arg='print_color')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Print descriptions of functions and their properties from a list of tools.\n\n    :param tools: a list of tools, each containing function details\n    :return: a string of function names and descriptions, including properties\n    ')), Assign(targets=[Name(id='output_str', ctx=Store())], value=Constant(value='')), For(target=Name(id='tool', ctx=Store()), iter=Name(id='tools', ctx=Load()), body=[If(test=Compare(left=Subscript(value=Name(id='tool', ctx=Load()), slice=Constant(value='type'), ctx=Load()), ops=[Eq()], comparators=[Constant(value='function')]), body=[Assign(targets=[Name(id='function_name', ctx=Store())], value=JoinedStr(values=[Constant(value='Function Name: '), FormattedValue(value=Subscript(value=Subscript(value=Name(id='tool', ctx=Load()), slice=Constant(value='function'), ctx=Load()), slice=Constant(value='name'), ctx=Load()), conversion=-1)])), Assign(targets=[Name(id='function_description', ctx=Store())], value=JoinedStr(values=[Constant(value='Function Description: '), FormattedValue(value=Subscript(value=Subscript(value=Name(id='tool', ctx=Load()), slice=Constant(value='function'), ctx=Load()), slice=Constant(value='description'), ctx=Load()), conversion=-1)])), AugAssign(target=Name(id='output_str', ctx=Store()), op=Add(), value=BinOp(left=BinOp(left=BinOp(left=Name(id='function_name', ctx=Load()), op=Add(), right=Constant(value='\n')), op=Add(), right=Name(id='function_description', ctx=Load())), op=Add(), right=Constant(value='\n'))), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Name(id='colored', ctx=Load()), args=[Name(id='output_str', ctx=Load()), Name(id='print_color', ctx=Load())], keywords=[])], keywords=[])), AugAssign(target=Name(id='output_str', ctx=Store()), op=Add(), value=Constant(value='Function Parameter Descriptions:\n')), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Name(id='colored', ctx=Load()), args=[Constant(value='Function Parameter Descriptions:'), Name(id='print_color', ctx=Load())], keywords=[])], keywords=[])), AugAssign(target=Name(id='output_str', ctx=Store()), op=Add(), value=Constant(value='\n')), Assign(targets=[Name(id='properties', ctx=Store())], value=Subscript(value=Subscript(value=Subscript(value=Name(id='tool', ctx=Load()), slice=Constant(value='function'), ctx=Load()), slice=Constant(value='parameters'), ctx=Load()), slice=Constant(value='properties'), ctx=Load())), For(target=Tuple(elts=[Name(id='prop', ctx=Store()), Name(id='details', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='properties', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='prop_description', ctx=Store())], value=JoinedStr(values=[Constant(value='  '), FormattedValue(value=Name(id='prop', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Call(func=Attribute(value=Subscript(value=Name(id='details', ctx=Load()), slice=Constant(value='description'), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), conversion=-1)])), AugAssign(target=Name(id='output_str', ctx=Store()), op=Add(), value=BinOp(left=Name(id='prop_description', ctx=Load()), op=Add(), right=Constant(value='\n'))), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Name(id='colored', ctx=Load()), args=[Name(id='prop_description', ctx=Load()), Name(id='print_color', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Return(value=Name(id='output_str', ctx=Load()))], decorator_list=[]), FunctionDef(name='count_tokens', args=arguments(posonlyargs=[], args=[arg(arg='input_string')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Counts the number of tokens in a given string using the 'cl100k_base' encoding.\n\n    :param input_string: string of text to be tokenized.\n    :return: integer representing the number of tokens in the input string.\n    ")), Assign(targets=[Name(id='encoding', ctx=Store())], value=Call(func=Attribute(value=Name(id='tiktoken', ctx=Load()), attr='get_encoding', ctx=Load()), args=[Constant(value='cl100k_base')], keywords=[])), Assign(targets=[Name(id='token_count', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Attribute(value=Name(id='encoding', ctx=Load()), attr='encode', ctx=Load()), args=[Name(id='input_string', ctx=Load())], keywords=[])], keywords=[])), Return(value=Name(id='token_count', ctx=Load()))], decorator_list=[]), FunctionDef(name='cost_llm_on_file', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='prompt'), arg(arg='model'), arg(arg='token_cost_dict'), arg(arg='verbose'), arg(arg='chunking_function'), arg(arg='chunking_function_args'), arg(arg='output_tokens_ratio'), arg(arg='output_tokens_fixed')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Constant(value=None), Tuple(elts=[], ctx=Load()), Constant(value=1), Constant(value=0)]), body=[Expr(value=Constant(value='\n    Calculates the cost of processing a file using a language model, based on the number of input and output tokens.\n\n    :param file_path: string of the path to the file to be processed.\n    :param prompt: string of the prompt to be used for the language model.\n    :param model: string of the name of the language model to be used.\n    :param token_cost_dict: dictionary containing the cost per token for the input and output of the model.\n    :param chunking_function: function to be used for chunking the file, defaults to None.\n    :param chunking_function_args: tuple of arguments to be passed to the chunking function, defaults to an empty tuple.\n    :param output_tokens_ratio: ratio of input tokens to output tokens, defaults to 1.\n    :param output_tokens_fixed: fixed number of output tokens per chunk, defaults to 0.\n    :return: tuple of total input cost, total output cost, and total cost.\n    ')), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='output_tokens_ratio', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=0)]), Compare(left=Name(id='output_tokens_fixed', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=0)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='output_tokens_ratio and output_tokens_fixed cannot both be non zero')], keywords=[]))], orelse=[]), FunctionDef(name='default_chunking', args=arguments(posonlyargs=[], args=[arg(arg='file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='r')], keywords=[keyword(arg='encoding', value=Constant(value='utf-8'))]), optional_vars=Name(id='file', ctx=Store()))], body=[Return(value=List(elts=[Call(func=Attribute(value=Name(id='file', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[])], ctx=Load()))])], decorator_list=[]), Assign(targets=[Name(id='chunks', ctx=Store())], value=Call(func=BoolOp(op=Or(), values=[Name(id='chunking_function', ctx=Load()), Name(id='default_chunking', ctx=Load())]), args=[Name(id='file_path', ctx=Load()), Starred(value=Name(id='chunking_function_args', ctx=Load()), ctx=Load())], keywords=[])), Assign(targets=[Name(id='total_input_tokens', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='total_output_tokens', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='total_cost', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='input_token_cost', ctx=Store())], value=Subscript(value=Subscript(value=Name(id='token_cost_dict', ctx=Load()), slice=Name(id='model', ctx=Load()), ctx=Load()), slice=Constant(value='input_token_cost'), ctx=Load())), Assign(targets=[Name(id='output_token_cost', ctx=Store())], value=Subscript(value=Subscript(value=Name(id='token_cost_dict', ctx=Load()), slice=Name(id='model', ctx=Load()), ctx=Load()), slice=Constant(value='output_token_cost'), ctx=Load())), Assign(targets=[Name(id='prompt_tokens', ctx=Store())], value=Call(func=Name(id='count_tokens', ctx=Load()), args=[Name(id='prompt', ctx=Load())], keywords=[])), For(target=Name(id='chunk', ctx=Store()), iter=Name(id='chunks', ctx=Load()), body=[Assign(targets=[Name(id='input_tokens', ctx=Store())], value=Name(id='prompt_tokens', ctx=Load())), Assign(targets=[Name(id='chunk_input', ctx=Store())], value=Call(func=Name(id='count_tokens', ctx=Load()), args=[Name(id='chunk', ctx=Load())], keywords=[])), AugAssign(target=Name(id='input_tokens', ctx=Store()), op=Add(), value=Name(id='chunk_input', ctx=Load())), If(test=Compare(left=Name(id='output_tokens_fixed', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='output_tokens', ctx=Store())], value=Name(id='output_tokens_fixed', ctx=Load()))], orelse=[Assign(targets=[Name(id='output_tokens', ctx=Store())], value=BinOp(left=Name(id='chunk_input', ctx=Load()), op=Mult(), right=Name(id='output_tokens_ratio', ctx=Load())))]), AugAssign(target=Name(id='total_input_tokens', ctx=Store()), op=Add(), value=Name(id='input_tokens', ctx=Load())), AugAssign(target=Name(id='total_output_tokens', ctx=Store()), op=Add(), value=Name(id='output_tokens', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='total_input_cost', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='total_input_tokens', ctx=Load()), op=Div(), right=Constant(value=1000000)), op=Mult(), right=Name(id='input_token_cost', ctx=Load()))), Assign(targets=[Name(id='total_output_cost', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='total_output_tokens', ctx=Load()), op=Div(), right=Constant(value=1000000)), op=Mult(), right=Name(id='output_token_cost', ctx=Load()))), Assign(targets=[Name(id='total_cost', ctx=Store())], value=BinOp(left=Name(id='total_input_cost', ctx=Load()), op=Add(), right=Name(id='total_output_cost', ctx=Load()))), If(test=Name(id='verbose', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='File input tokens: '), FormattedValue(value=Name(id='total_input_tokens', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value=',')])), Constant(value=' (Cost: $'), FormattedValue(value=Name(id='input_token_cost', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.4f')])), Constant(value='/1M tokens, Input token cost: $'), FormattedValue(value=Name(id='total_input_cost', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.2f')])), Constant(value=')')])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='File output tokens: '), FormattedValue(value=Name(id='total_output_tokens', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value=',')])), Constant(value=' (Cost: $'), FormattedValue(value=Name(id='output_token_cost', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.4f')])), Constant(value='/1M tokens, Output token cost: $'), FormattedValue(value=Name(id='total_output_cost', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.2f')])), Constant(value=')')])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='File cost: $'), FormattedValue(value=Name(id='total_cost', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.2f')])), Constant(value='\n\n')])], keywords=[]))], orelse=[]), Return(value=Tuple(elts=[Name(id='total_input_cost', ctx=Load()), Name(id='total_output_cost', ctx=Load()), Name(id='total_cost', ctx=Load()), Name(id='total_input_tokens', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='cost_llm_on_corpus', args=arguments(posonlyargs=[], args=[arg(arg='corpus_path'), arg(arg='prompt'), arg(arg='model'), arg(arg='token_cost_dict'), arg(arg='verbose'), arg(arg='suffix_include'), arg(arg='suffix_exclude'), arg(arg='include_subfolders'), arg(arg='chunking_function'), arg(arg='chunking_function_args'), arg(arg='output_tokens_ratio'), arg(arg='output_tokens_fixed')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Constant(value=None), Constant(value=None), Constant(value=False), Constant(value=None), Tuple(elts=[], ctx=Load()), Constant(value=1), Constant(value=0)]), body=[Expr(value=Constant(value='\n    Calculates the cost of processing a corpus using a language model, based on the number of input and output tokens.\n\n    :param corpus_path: string of the path to the corpus to be processed.\n    :param prompt: string of the prompt to be used for the language model.\n    :param model: string of the name of the language model to be used.\n    :param token_cost_dict: dictionary containing the cost per token for the input and output of the model.\n    :param chunking_function: function to be used for chunking the file, defaults to None.\n    :param chunking_function_args: tuple of arguments to be passed to the chunking function, defaults to an empty tuple.\n    :param output_tokens_ratio: ratio of input tokens to output tokens, defaults to 1.\n    :param output_tokens_fixed: fixed number of output tokens per chunk, defaults to 0.\n    :param suffix_include: string of the suffix that included files must have, defaults to None.\n    :param suffix_exclude: string of the suffix that files must not have to be included, defaults to None.\n    :param include_subfolders: boolean indicating whether to include files from subfolders, defaults to False.\n    :return: tuple of total input cost, total output cost, and total cost for the entire corpus.\n    ')), Assign(targets=[Name(id='total_input_cost', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='total_output_cost', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='total_cost', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='total_input_tokens', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='file_paths', ctx=Store())], value=Call(func=Name(id='get_files_in_folder', ctx=Load()), args=[Name(id='corpus_path', ctx=Load())], keywords=[keyword(arg='suffix_include', value=Name(id='suffix_include', ctx=Load())), keyword(arg='suffix_exclude', value=Name(id='suffix_exclude', ctx=Load())), keyword(arg='include_subfolders', value=Name(id='include_subfolders', ctx=Load()))])), For(target=Name(id='file_path', ctx=Store()), iter=Name(id='file_paths', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='file_input_cost', ctx=Store()), Name(id='file_output_cost', ctx=Store()), Name(id='file_cost', ctx=Store()), Name(id='input_tokens', ctx=Store())], ctx=Store())], value=Call(func=Name(id='cost_llm_on_file', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='prompt', ctx=Load()), Name(id='model', ctx=Load()), Name(id='token_cost_dict', ctx=Load()), Name(id='verbose', ctx=Load()), Name(id='chunking_function', ctx=Load()), Name(id='chunking_function_args', ctx=Load()), Name(id='output_tokens_ratio', ctx=Load()), Name(id='output_tokens_fixed', ctx=Load())], keywords=[])), AugAssign(target=Name(id='total_input_cost', ctx=Store()), op=Add(), value=Name(id='file_input_cost', ctx=Load())), AugAssign(target=Name(id='total_output_cost', ctx=Store()), op=Add(), value=Name(id='file_output_cost', ctx=Load())), AugAssign(target=Name(id='total_cost', ctx=Store()), op=Add(), value=Name(id='file_cost', ctx=Load())), AugAssign(target=Name(id='total_input_tokens', ctx=Store()), op=Add(), value=Name(id='input_tokens', ctx=Load()))], orelse=[]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='\nCorpus Summary for '), FormattedValue(value=Name(id='corpus_path', ctx=Load()), conversion=-1)])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Corpus input cost: '), FormattedValue(value=Name(id='total_input_cost', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.2f')]))])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Corpus output cost: '), FormattedValue(value=Name(id='total_output_cost', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.2f')]))])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Corpus total cost: $'), FormattedValue(value=Name(id='total_cost', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.2f')]))])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Corpus total files: '), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='file_paths', ctx=Load())], keywords=[]), conversion=-1), Constant(value=', total input tokens: '), FormattedValue(value=Name(id='total_input_tokens', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value=',')])), Constant(value='\n')])], keywords=[])), Return(value=Tuple(elts=[Name(id='total_input_cost', ctx=Load()), Name(id='total_output_cost', ctx=Load()), Name(id='total_cost', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='add_token_counts_to_headings', args=arguments(posonlyargs=[], args=[arg(arg='text')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Adds token counts to markdown headings in the given text.\n\n    :param text: string, the text content to process.\n    :return: string, the text with token counts added to headings.\n    ')), Assign(targets=[Name(id='updated_lines', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='match', ctx=Load()), args=[Constant(value='^#{1,6}\\s'), Name(id='line', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='heading', ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='heading_text', ctx=Store())], value=Call(func=Name(id='find_heading_text', ctx=Load()), args=[Name(id='text', ctx=Load()), Name(id='heading', ctx=Load())], keywords=[])), If(test=Name(id='heading_text', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='start', ctx=Store()), Name(id='end', ctx=Store())], ctx=Store())], value=Name(id='heading_text', ctx=Load())), Assign(targets=[Name(id='section_content', ctx=Store())], value=Subscript(value=Name(id='text', ctx=Load()), slice=Slice(lower=Name(id='start', ctx=Load()), upper=Name(id='end', ctx=Load())), ctx=Load())), Assign(targets=[Name(id='token_count', ctx=Store())], value=Call(func=Name(id='count_tokens', ctx=Load()), args=[Name(id='section_content', ctx=Load())], keywords=[])), Assign(targets=[Name(id='formatted_count', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='token_count', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value=',')]))])), Assign(targets=[Name(id='updated_line', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='line', ctx=Load()), conversion=-1), Constant(value=' ('), FormattedValue(value=Name(id='formatted_count', ctx=Load()), conversion=-1), Constant(value=' tokens)')])), Expr(value=Call(func=Attribute(value=Name(id='updated_lines', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='updated_line', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='updated_lines', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[]))])], orelse=[Expr(value=Call(func=Attribute(value=Name(id='updated_lines', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[]))])], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='updated_lines', ctx=Load())], keywords=[])), Assign(targets=[Name(id='total_tokens', ctx=Store())], value=Call(func=Name(id='count_tokens', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='first_line', ctx=Store()), Starred(value=Name(id='rest', ctx=Store()), ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n'), Constant(value=1)], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=BinOp(left=JoinedStr(values=[FormattedValue(value=Name(id='first_line', ctx=Load()), conversion=-1), Constant(value=' ('), FormattedValue(value=Name(id='total_tokens', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value=',')])), Constant(value=' tokens)\n')]), op=Add(), right=IfExp(test=Name(id='rest', ctx=Load()), body=Subscript(value=Name(id='rest', ctx=Load()), slice=Constant(value=0), ctx=Load()), orelse=Constant(value='')))), Return(value=Name(id='result', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_line_numbers_with_match', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='match_str')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Retrieve line numbers from a file where the line matches a given string exactly after stripping.\n\n    :param file_path: path to the file to be searched\n    :param match_str: string of text to match on each line\n    :return: list of line numbers where the match_str is found\n    ')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='isfile', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='The file path does not exist or is invalid for '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value='.')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='line_numbers', ctx=Store())], value=List(elts=[], ctx=Load())), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[For(target=Tuple(elts=[Name(id='line_number', ctx=Store()), Name(id='line', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='file', ctx=Load())], keywords=[keyword(arg='start', value=Constant(value=1))]), body=[If(test=Compare(left=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Name(id='match_str', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='line_numbers', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='line_number', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])]), Return(value=Name(id='line_numbers', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_speaker_segments', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='skip_string')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='SKIPQA')]), body=[Expr(value=Constant(value='\n    Extract segments from a file that do not contain a specific skip string, or all segments if skip string is None.\n\n    :param file_path: string of the path to the file to be processed\n    :param skip_string: string of the substring used to identify segments to skip, or None to include all segments\n    :return: list of segments without the skip string, or all segments if skip string is None\n    ')), Assign(targets=[Name(id='transcript', ctx=Store())], value=Call(func=Name(id='get_heading', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[keyword(arg='heading', value=Constant(value='### transcript'))])), Assign(targets=[Name(id='transcript', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='transcript', ctx=Load()), attr='lstrip', ctx=Load()), args=[Constant(value='### transcript')], keywords=[]), attr='rstrip', ctx=Load()), args=[Constant(value='\n')], keywords=[]), attr='lstrip', ctx=Load()), args=[Constant(value='\n*')], keywords=[])), Assign(targets=[Name(id='segments', ctx=Store())], value=Call(func=Attribute(value=Name(id='transcript', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n\n')], keywords=[])), If(test=Compare(left=Name(id='skip_string', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='segments', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='segment', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='segment', ctx=Store()), iter=Name(id='segments', ctx=Load()), ifs=[Compare(left=Name(id='skip_string', ctx=Load()), ops=[NotIn()], comparators=[Name(id='segment', ctx=Load())])], is_async=0)]))], orelse=[Assign(targets=[Name(id='segments', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='segment', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='segment', ctx=Store()), iter=Name(id='segments', ctx=Load()), ifs=[], is_async=0)]))]), Return(value=Name(id='segments', ctx=Load()))], decorator_list=[]), FunctionDef(name='count_segment_tokens', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='skip_string')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='SKIPQA')]), body=[Expr(value=Constant(value='\n    Count tokens in each segment of a file and provide token statistics.\n\n    :param file_path: string of the path to the file to be processed\n    :param skip_string: string of the substring used to identify segments to skip\n    :return: tuple containing (list of segments, list of token counts)\n    ')), Assign(targets=[Name(id='segments', ctx=Store())], value=Call(func=Name(id='get_speaker_segments', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='skip_string', ctx=Load())], keywords=[])), Assign(targets=[Name(id='segment_tokens', ctx=Store())], value=ListComp(elt=Call(func=Name(id='count_tokens', ctx=Load()), args=[Name(id='segment', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='segment', ctx=Store()), iter=Name(id='segments', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='total_tokens', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[Name(id='segment_tokens', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_tokens', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Name(id='segment_tokens', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Total tokens in the file: '), FormattedValue(value=Name(id='total_tokens', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value=',')])), Constant(value='  x 4 for characters: '), FormattedValue(value=BinOp(left=Constant(value=4), op=Mult(), right=Name(id='total_tokens', ctx=Load())), conversion=-1, format_spec=JoinedStr(values=[Constant(value=',')]))])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Number of segments in the file: '), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='segments', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Maximum tokens in any segment: '), FormattedValue(value=Name(id='max_tokens', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value=',')])), Constant(value='  x 4 for characters: '), FormattedValue(value=BinOp(left=Constant(value=4), op=Mult(), right=Name(id='max_tokens', ctx=Load())), conversion=-1, format_spec=JoinedStr(values=[Constant(value=',')]))])], keywords=[])), Return(value=Name(id='segment_tokens', ctx=Load()))], decorator_list=[]), FunctionDef(name='plot_segment_tokens', args=arguments(posonlyargs=[], args=[arg(arg='file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Create a horizontal bar chart plot of token counts for each segment and save it as a PNG file.\n\n    :param file_path: string of the path to the file to be processed\n    :return: string of the path to the saved PNG file\n    ')), Import(names=[alias(name='matplotlib.pyplot', asname='plt')]), Assign(targets=[Name(id='segments', ctx=Store())], value=Call(func=Name(id='get_speaker_segments', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='segment_tokens', ctx=Store())], value=Call(func=Name(id='count_segment_tokens', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='plt', ctx=Load()), attr='figure', ctx=Load()), args=[], keywords=[keyword(arg='figsize', value=Tuple(elts=[Constant(value=15), Constant(value=10)], ctx=Load()))])), Assign(targets=[Name(id='y_pos', ctx=Store())], value=Call(func=Name(id='range', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='segment_tokens', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='plt', ctx=Load()), attr='barh', ctx=Load()), args=[Name(id='y_pos', ctx=Load()), Name(id='segment_tokens', ctx=Load())], keywords=[])), Assign(targets=[Name(id='total_tokens', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[Name(id='segment_tokens', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_tokens', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Name(id='segment_tokens', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_segments', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='segment_tokens', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='plt', ctx=Load()), attr='title', ctx=Load()), args=[JoinedStr(values=[Constant(value='Token Distribution in Segments\n\n'), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value='\n\nMaximum tokens in any segment: '), FormattedValue(value=Name(id='max_tokens', ctx=Load()), conversion=-1), Constant(value='\nNumber of segments: '), FormattedValue(value=Name(id='num_segments', ctx=Load()), conversion=-1), Constant(value='\nTotal tokens: '), FormattedValue(value=Name(id='total_tokens', ctx=Load()), conversion=-1), Constant(value='\n\n')])], keywords=[keyword(arg='loc', value=Constant(value='left')), keyword(arg='fontweight', value=Constant(value='bold')), keyword(arg='fontsize', value=Constant(value=14))])), Expr(value=Call(func=Attribute(value=Name(id='plt', ctx=Load()), attr='ylabel', ctx=Load()), args=[Constant(value='Segment Index')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='plt', ctx=Load()), attr='xlabel', ctx=Load()), args=[Constant(value='Token Count')], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='plt', ctx=Load()), attr='gca', ctx=Load()), args=[], keywords=[]), attr='invert_yaxis', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='base_name', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[]), attr='rsplit', ctx=Load()), args=[Constant(value='.'), Constant(value=1)], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='output_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Constant(value='logs'), Constant(value='plots'), JoinedStr(values=[Constant(value='Token_count_'), FormattedValue(value=Name(id='base_name', ctx=Load()), conversion=-1), Constant(value='.png')])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='plt', ctx=Load()), attr='savefig', ctx=Load()), args=[Name(id='output_path', ctx=Load())], keywords=[keyword(arg='bbox_inches', value=Constant(value='tight'))])), Expr(value=Call(func=Attribute(value=Name(id='plt', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[])), Import(names=[alias(name='subprocess')]), Expr(value=Call(func=Attribute(value=Name(id='subprocess', ctx=Load()), attr='run', ctx=Load()), args=[List(elts=[Constant(value='code'), Name(id='output_path', ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Token count of segments plot saved to: '), FormattedValue(value=Name(id='output_path', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Name(id='output_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='group_segments_select_speaker', args=arguments(posonlyargs=[], args=[arg(arg='segments'), arg(arg='speaker')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Groups consecutive segments not containing the specified speaker's name and selects segments where the speaker's name is found before the timestamp.\n    Calls get_timestamp from fileops.py to determine if the first line in a segment is a speaker line.\n\n    :param segments: list of text segments to be processed\n    :param speaker: string of the speaker's name to select segments\n    :return: list of text segments where the speaker's name is found before the timestamp\n    ")), ImportFrom(module='primary.fileops', names=[alias(name='get_timestamp')], level=0), Assign(targets=[Name(id='final_segments', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='temp_segments', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='segment', ctx=Store()), iter=Name(id='segments', ctx=Load()), body=[Assign(targets=[Name(id='first_line', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='segment', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n'), Constant(value=1)], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='timestamp', ctx=Store()), Name(id='index', ctx=Store())], ctx=Store())], value=Call(func=Name(id='get_timestamp', ctx=Load()), args=[Name(id='first_line', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='timestamp', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='speaker', ctx=Load()), ops=[In()], comparators=[Subscript(value=Name(id='first_line', ctx=Load()), slice=Slice(upper=Name(id='index', ctx=Load())), ctx=Load())])]), body=[Expr(value=Call(func=Attribute(value=Name(id='temp_segments', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='segment', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='final_segments', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='\n\n'), attr='join', ctx=Load()), args=[Name(id='temp_segments', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='temp_segments', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='temp_segments', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='segment', ctx=Load())], keywords=[]))])], orelse=[]), If(test=Name(id='temp_segments', ctx=Load()), body=[Assign(targets=[Name(id='last_segment_first_line', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Subscript(value=Name(id='temp_segments', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n'), Constant(value=1)], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='timestamp', ctx=Store()), Name(id='index', ctx=Store())], ctx=Store())], value=Call(func=Name(id='get_timestamp', ctx=Load()), args=[Name(id='last_segment_first_line', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='timestamp', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='speaker', ctx=Load()), ops=[In()], comparators=[Subscript(value=Name(id='last_segment_first_line', ctx=Load()), slice=Slice(upper=Name(id='index', ctx=Load())), ctx=Load())])]), body=[Expr(value=Call(func=Attribute(value=Name(id='final_segments', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='\n\n'), attr='join', ctx=Load()), args=[Name(id='temp_segments', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])], orelse=[]), Return(value=ListComp(elt=Name(id='segment', ctx=Load()), generators=[comprehension(target=Name(id='segment', ctx=Store()), iter=Name(id='final_segments', ctx=Load()), ifs=[Call(func=Attribute(value=Name(id='segment', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])], is_async=0)]))], decorator_list=[]), FunctionDef(name='group_segments_token_cap', args=arguments(posonlyargs=[], args=[arg(arg='segments'), arg(arg='token_cap')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=2000)]), body=[Expr(value=Constant(value='\n    Groups consecutive segments without exceeding the token_cap, without splitting segments.\n    Includes segments that exceed the token_cap as individual blocks.\n\n    :param segments: list of text segments to be processed\n    :param token_cap: integer of maximum number of tokens, using words = .75 tokens\n    :return: list of grouped text segments without exceeding the token_cap, including oversized segments as individual blocks\n    ')), Assign(targets=[Name(id='final_segments', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='temp_segments', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='current_token_count', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='word_cap', ctx=Store())], value=BinOp(left=Name(id='token_cap', ctx=Load()), op=Div(), right=Constant(value=0.75))), For(target=Name(id='segment', ctx=Store()), iter=Name(id='segments', ctx=Load()), body=[Assign(targets=[Name(id='words_in_segment', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Attribute(value=Name(id='segment', ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Name(id='words_in_segment', ctx=Load()), ops=[Gt()], comparators=[Name(id='word_cap', ctx=Load())]), body=[If(test=Name(id='temp_segments', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='final_segments', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='\n\n'), attr='join', ctx=Load()), args=[Name(id='temp_segments', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='temp_segments', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='current_token_count', ctx=Store())], value=Constant(value=0))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='final_segments', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='segment', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=BinOp(left=Name(id='current_token_count', ctx=Load()), op=Add(), right=BinOp(left=Name(id='words_in_segment', ctx=Load()), op=Mult(), right=Constant(value=0.75))), ops=[Gt()], comparators=[Name(id='token_cap', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='final_segments', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='\n\n'), attr='join', ctx=Load()), args=[Name(id='temp_segments', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='temp_segments', ctx=Store())], value=List(elts=[Name(id='segment', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='current_token_count', ctx=Store())], value=BinOp(left=Name(id='words_in_segment', ctx=Load()), op=Mult(), right=Constant(value=0.75)))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='temp_segments', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='segment', ctx=Load())], keywords=[])), AugAssign(target=Name(id='current_token_count', ctx=Store()), op=Add(), value=BinOp(left=Name(id='words_in_segment', ctx=Load()), op=Mult(), right=Constant(value=0.75)))])])], orelse=[]), If(test=Name(id='temp_segments', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='final_segments', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='\n\n'), attr='join', ctx=Load()), args=[Name(id='temp_segments', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=ListComp(elt=Name(id='segment', ctx=Load()), generators=[comprehension(target=Name(id='segment', ctx=Store()), iter=Name(id='final_segments', ctx=Load()), ifs=[Call(func=Attribute(value=Name(id='segment', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])], is_async=0)]))], decorator_list=[]), FunctionDef(name='split_file_select_speaker', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='speaker'), arg(arg='skip_string'), arg(arg='suffix_new')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='SKIPQA'), Constant(value='_blocks')]), body=[Expr(value=Constant(value='\n    Add block delimiters to a file, with a block for every segment by the selected speaker and other segments grouped together.\n\n    :param file_path: path to the file to be processed\n    :param speaker: the speaker whose sections will be delimited\n    :param skip_string: string to identify speaker segments to skip\n    :param suffix_new: suffix for the new file with block delimiters\n    :return: file_path of new file with separator delimiters ("---") with suffix_new=\'_blocks\' by default\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='read_metadata_and_content'), alias(name='write_metadata_and_content')], level=0), Assign(targets=[Tuple(elts=[Name(id='metadata', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Name(id='read_metadata_and_content', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='segments', ctx=Store())], value=Call(func=Name(id='get_speaker_segments', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='skip_string', ctx=Load())], keywords=[])), Assign(targets=[Name(id='grouped_segments', ctx=Store())], value=Call(func=Name(id='group_segments_select_speaker', ctx=Load()), args=[Name(id='segments', ctx=Load()), Name(id='speaker', ctx=Load())], keywords=[])), Assign(targets=[Name(id='new_content', ctx=Store())], value=BinOp(left=Constant(value='## content\n\n'), op=Add(), right=Call(func=Attribute(value=Name(id='BLOCK_DELIMITER', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='grouped_segments', ctx=Load())], keywords=[]))), Return(value=Call(func=Name(id='write_metadata_and_content', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='metadata', ctx=Load()), Name(id='new_content', ctx=Load()), Name(id='suffix_new', ctx=Load())], keywords=[keyword(arg='overwrite', value=Constant(value='no'))]))], decorator_list=[]), FunctionDef(name='split_file_every_speaker', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='skip_string'), arg(arg='suffix_new')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value='_blocks')]), body=[Expr(value=Constant(value='\n    Add block delimiters to a file with one block per speaker segment regardless of speaker.\n\n    :param file_path: path to the file to be processed\n    :param skip_string: string to identify speaker segments to skip\n    :param suffix_new: suffix for the new file with block delimiters\n    :return: file_path of new file with separator delimiters ("---") with suffix_new=\'_blocks\' by default\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='read_metadata_and_content'), alias(name='write_metadata_and_content')], level=0), Assign(targets=[Tuple(elts=[Name(id='metadata', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Name(id='read_metadata_and_content', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='segments', ctx=Store())], value=Call(func=Name(id='get_speaker_segments', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='skip_string', ctx=Load())], keywords=[])), Assign(targets=[Name(id='new_content', ctx=Store())], value=BinOp(left=Constant(value='## content\n\n'), op=Add(), right=Call(func=Attribute(value=Name(id='BLOCK_DELIMITER', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='segments', ctx=Load())], keywords=[]))), Return(value=Call(func=Name(id='write_metadata_and_content', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='metadata', ctx=Load()), Name(id='new_content', ctx=Load()), Name(id='suffix_new', ctx=Load())], keywords=[keyword(arg='overwrite', value=Constant(value='no'))]))], decorator_list=[]), FunctionDef(name='split_file_token_cap', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='token_cap'), arg(arg='skip_string'), arg(arg='suffix_new')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='SKIPQA'), Constant(value='_blocks')]), body=[Expr(value=Constant(value='\n    Add block delimiters to a file with one block per speaker segment regardless of speaker.\n\n    :param file_path: path to the file to be processed\n    :param token_cap: integer of maximum number of tokens, using words = .75 tokens\n    :param skip_string: string to identify speaker segments to skip\n    :param suffix_new: suffix for the new file with block delimiters\n    :return: file_path of new file with separator delimiters ("---") with suffix_new=\'_blocks\' by default\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='read_metadata_and_content'), alias(name='write_metadata_and_content')], level=0), Assign(targets=[Tuple(elts=[Name(id='metadata', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Name(id='read_metadata_and_content', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='segments', ctx=Store())], value=Call(func=Name(id='get_speaker_segments', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='skip_string', ctx=Load())], keywords=[])), Assign(targets=[Name(id='grouped_segments', ctx=Store())], value=Call(func=Name(id='group_segments_token_cap', ctx=Load()), args=[Name(id='segments', ctx=Load()), Name(id='token_cap', ctx=Load())], keywords=[])), Assign(targets=[Name(id='new_content', ctx=Store())], value=BinOp(left=Constant(value='## content\n\n'), op=Add(), right=Call(func=Attribute(value=Name(id='BLOCK_DELIMITER', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='grouped_segments', ctx=Load())], keywords=[]))), Return(value=Call(func=Name(id='write_metadata_and_content', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='metadata', ctx=Load()), Name(id='new_content', ctx=Load()), Name(id='suffix_new', ctx=Load())], keywords=[keyword(arg='overwrite', value=Constant(value='no'))]))], decorator_list=[]), FunctionDef(name='test_openai_chat', args=arguments(posonlyargs=[], args=[arg(arg='model')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='OPENAI_MODEL', ctx=Load())]), body=[Expr(value=Constant(value='\n    Sends a predefined message to the OpenAI chat API and prints the response.\n\n    :param model: string of the model name to be used for the chat completion request\n    :return: None\n    ')), Try(body=[Assign(targets=[Name(id='messages', ctx=Store())], value=List(elts=[Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='user'), Constant(value='Tell me a knock knock joke about science.')])], ctx=Load())), Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Name(id='openai_chat_completion_request', ctx=Load()), args=[Name(id='messages', ctx=Load())], keywords=[keyword(arg='model', value=Name(id='model', ctx=Load()))])), If(test=Name(id='response', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='API chat response:'), Attribute(value=Name(id='response', ctx=Load()), attr='text', ctx=Load())], keywords=[]))], orelse=[])], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Failed to access the OpenAI API: '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='openai_chat_completion_request', args=arguments(posonlyargs=[], args=[arg(arg='messages'), arg(arg='tools'), arg(arg='tool_choice'), arg(arg='model')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Name(id='OPENAI_MODEL', ctx=Load())]), body=[Expr(value=Constant(value='\n    Send a chat completion request to the OpenAI API with the provided messages and optional tools and tool choice.\n\n    :param messages: a list of message dictionaries to send in the chat completion request\n    :param tools: optional list of tools to include in the request\n    :param tool_choice: optional tool choice to include in the request\n    :param model: the model to use for the chat completion request\n    :return: the response object from the OpenAI API request\n    ')), Assign(targets=[Name(id='headers', ctx=Store())], value=Dict(keys=[Constant(value='Content-Type'), Constant(value='Authorization')], values=[Constant(value='application/json'), BinOp(left=Constant(value='Bearer '), op=Add(), right=Name(id='OPENAI_API_KEY_CONFIG_LLM', ctx=Load()))])), Assign(targets=[Name(id='json_data', ctx=Store())], value=Dict(keys=[Constant(value='model'), Constant(value='messages')], values=[Name(id='model', ctx=Load()), Name(id='messages', ctx=Load())])), If(test=Compare(left=Name(id='tools', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='json_data', ctx=Load()), attr='update', ctx=Load()), args=[Dict(keys=[Constant(value='tools')], values=[Name(id='tools', ctx=Load())])], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='tool_choice', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='json_data', ctx=Load()), attr='update', ctx=Load()), args=[Dict(keys=[Constant(value='tool_choice')], values=[Name(id='tool_choice', ctx=Load())])], keywords=[]))], orelse=[]), Try(body=[Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Attribute(value=Name(id='requests', ctx=Load()), attr='post', ctx=Load()), args=[Constant(value='https://api.openai.com/v1/chat/completions')], keywords=[keyword(arg='headers', value=Name(id='headers', ctx=Load())), keyword(arg='json', value=Name(id='json_data', ctx=Load()))])), Return(value=Name(id='response', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Unable to generate OpenAI Chat Completion response')], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Exception: '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Name(id='e', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[Call(func=Name(id='retry', ctx=Load()), args=[], keywords=[keyword(arg='wait', value=Call(func=Name(id='wait_random_exponential', ctx=Load()), args=[], keywords=[keyword(arg='multiplier', value=Constant(value=1)), keyword(arg='max', value=Constant(value=40))])), keyword(arg='stop', value=Call(func=Name(id='stop_after_attempt', ctx=Load()), args=[Constant(value=3)], keywords=[]))])]), FunctionDef(name='simple_openai_chat_completion_request', args=arguments(posonlyargs=[], args=[arg(arg='prompt'), arg(arg='model')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='headers', ctx=Store())], value=Dict(keys=[Constant(value='Content-Type'), Constant(value='Authorization')], values=[Constant(value='application/json'), BinOp(left=Constant(value='Bearer '), op=Add(), right=Name(id='OPENAI_API_KEY_CONFIG_LLM', ctx=Load()))])), Assign(targets=[Name(id='messages', ctx=Store())], value=List(elts=[Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='user'), Name(id='prompt', ctx=Load())])], ctx=Load())), Assign(targets=[Name(id='json_data', ctx=Store())], value=Dict(keys=[Constant(value='model'), Constant(value='messages')], values=[Name(id='model', ctx=Load()), Name(id='messages', ctx=Load())])), Try(body=[Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Attribute(value=Name(id='requests', ctx=Load()), attr='post', ctx=Load()), args=[Constant(value='https://api.openai.com/v1/chat/completions')], keywords=[keyword(arg='headers', value=Name(id='headers', ctx=Load())), keyword(arg='json', value=Name(id='json_data', ctx=Load()))])), Assign(targets=[Name(id='response_json', ctx=Store())], value=Call(func=Attribute(value=Name(id='response', ctx=Load()), attr='json', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Subscript(value=Subscript(value=Subscript(value=Name(id='response_json', ctx=Load()), slice=Constant(value='choices'), ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Constant(value='message'), ctx=Load()), slice=Constant(value='content'), ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Unable to generate ChatCompletion response')], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Exception: '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='openai_function_call', args=arguments(posonlyargs=[], args=[arg(arg='fcall_prompt'), arg(arg='content'), arg(arg='tools'), arg(arg='model'), arg(arg='verbose')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='OPENAI_MODEL', ctx=Load()), Constant(value=False)]), body=[Expr(value=Constant(value="\n    Sends a prompt and content to the OpenAI LLM and returns the assistant's message.\n\n    :param fcall_prompt: string of the system's prompt to initiate the conversation\n    :param content: string of the user's content to process\n    :param tools: list of dictionaries containing tool configurations\n    :param model: string specifying the OpenAI model to use\n    :param verbose: boolean indicating whether to print detailed response text\n    :return: string of the assistant's message from the LLM response\n    ")), Assign(targets=[Name(id='messages', ctx=Store())], value=List(elts=[Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='system'), Name(id='fcall_prompt', ctx=Load())]), Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='user'), Name(id='content', ctx=Load())])], ctx=Load())), Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='OPENAI_MODEL = '), FormattedValue(value=Name(id='model', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='chat_response', ctx=Store())], value=Call(func=Name(id='openai_chat_completion_request', ctx=Load()), args=[Name(id='messages', ctx=Load())], keywords=[keyword(arg='tools', value=Name(id='tools', ctx=Load())), keyword(arg='model', value=Name(id='model', ctx=Load()))])), Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='Response Status Code: '), FormattedValue(value=Attribute(value=Name(id='chat_response', ctx=Load()), attr='status_code', ctx=Load()), conversion=-1)])], keywords=[])), Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='Response Text: '), FormattedValue(value=Attribute(value=Name(id='chat_response', ctx=Load()), attr='text', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='assistant_message', ctx=Store())], value=Constant(value=None)), Try(body=[Assign(targets=[Name(id='assistant_message', ctx=Store())], value=Subscript(value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='chat_response', ctx=Load()), attr='json', ctx=Load()), args=[], keywords=[]), slice=Constant(value='choices'), ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Constant(value='message'), ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='messages', ctx=Load()), attr='append', ctx=Load()), args=[Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='assistant'), Name(id='assistant_message', ctx=Load())])], keywords=[])), If(test=Name(id='verbose', ctx=Load()), body=[Expr(value=Call(func=Name(id='pretty_print_function', ctx=Load()), args=[Name(id='messages', ctx=Load()), Name(id='tools', ctx=Load())], keywords=[]))], orelse=[])], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Error parsing response: '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[]))])], orelse=[], finalbody=[]), Return(value=Name(id='assistant_message', ctx=Load()))], decorator_list=[]), FunctionDef(name='anthropic_chat_completion_request', args=arguments(posonlyargs=[], args=[arg(arg='messages'), arg(arg='model'), arg(arg='system'), arg(arg='max_tokens'), arg(arg='temperature')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='ANTHROPIC_MODEL', ctx=Load()), Constant(value=None), Constant(value=4096), Constant(value=0.7)]), body=[Expr(value=Constant(value="\n    Make a chat completion request to Anthropic's API.\n\n    :param messages: List of message objects representing the conversation\n    :param model: The model to use for the completion\n    :param system: System message to set the behavior of the assistant\n    :param max_tokens: Maximum number of tokens to generate (default: 4096)\n    :param temperature: Controls randomness in the output (0 to 1, default: 0.7)\n    :return: The generated message content or None if an error occurs\n    ")), Assign(targets=[Name(id='client', ctx=Store())], value=Call(func=Attribute(value=Name(id='anthropic', ctx=Load()), attr='Anthropic', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='request_params', ctx=Store())], value=Dict(keys=[Constant(value='model'), Constant(value='max_tokens'), Constant(value='temperature')], values=[Name(id='model', ctx=Load()), Name(id='max_tokens', ctx=Load()), Name(id='temperature', ctx=Load())])), If(test=Name(id='system', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='request_params', ctx=Load()), slice=Constant(value='system'), ctx=Store())], value=Name(id='system', ctx=Load()))], orelse=[]), If(test=Name(id='messages', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='request_params', ctx=Load()), slice=Constant(value='messages'), ctx=Store())], value=Name(id='messages', ctx=Load()))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='No messages were provided for Anthropic chat completion request.')], keywords=[]))]), Try(body=[Assign(targets=[Name(id='message', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='client', ctx=Load()), attr='messages', ctx=Load()), attr='create', ctx=Load()), args=[], keywords=[keyword(value=Name(id='request_params', ctx=Load()))])), Return(value=Attribute(value=Subscript(value=Attribute(value=Name(id='message', ctx=Load()), attr='content', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='text', ctx=Load()))], handlers=[ExceptHandler(type=Attribute(value=Name(id='anthropic', ctx=Load()), attr='APIError', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Anthropic API error: '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[]))]), ExceptHandler(type=Attribute(value=Name(id='anthropic', ctx=Load()), attr='APIConnectionError', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Error connecting to Anthropic API: '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[]))]), ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='An unexpected error occurred: '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[]))])], orelse=[], finalbody=[]), Return(value=Constant(value=None))], decorator_list=[]), FunctionDef(name='simple_anthropic_chat_completion_request', args=arguments(posonlyargs=[], args=[arg(arg='prompt'), arg(arg='model')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='ANTHROPIC_MODEL', ctx=Load())]), body=[Expr(value=Constant(value='\n    Make a simple chat completion request to Anthropic\'s API.\n\n    :param prompt: String containing the user\'s prompt or message\n    :param model: String specifying the Anthropic model to use (default: "claude-3-opus-20240229")\n    :return: String containing the generated message content, or an error message if the request fails\n    ')), Assign(targets=[Name(id='headers', ctx=Store())], value=Dict(keys=[Constant(value='Content-Type'), Constant(value='X-API-Key'), Constant(value='anthropic-version')], values=[Constant(value='application/json'), Subscript(value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), slice=Constant(value='ANTHROPIC_API_KEY'), ctx=Load()), Constant(value='2023-06-01')])), Assign(targets=[Name(id='json_data', ctx=Store())], value=Dict(keys=[Constant(value='model'), Constant(value='max_tokens'), Constant(value='messages')], values=[Name(id='model', ctx=Load()), Constant(value=1000), List(elts=[Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='user'), Name(id='prompt', ctx=Load())])], ctx=Load())])), Try(body=[Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Attribute(value=Name(id='requests', ctx=Load()), attr='post', ctx=Load()), args=[Constant(value='https://api.anthropic.com/v1/messages')], keywords=[keyword(arg='headers', value=Name(id='headers', ctx=Load())), keyword(arg='json', value=Name(id='json_data', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='response', ctx=Load()), attr='raise_for_status', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='response_json', ctx=Store())], value=Call(func=Attribute(value=Name(id='response', ctx=Load()), attr='json', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Subscript(value=Subscript(value=Name(id='response_json', ctx=Load()), slice=Constant(value='content'), ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Constant(value='text'), ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Attribute(value=Attribute(value=Name(id='requests', ctx=Load()), attr='exceptions', ctx=Load()), attr='RequestException', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Unable to generate ChatCompletion response')], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Exception: '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='llm_process_block', args=arguments(posonlyargs=[], args=[arg(arg='block'), arg(arg='prompt'), arg(arg='provider')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='openai')]), body=[Expr(value=Constant(value='\n    Processes a single block of text with a given prompt using the OpenAI chat completion API.\n\n    :param block: string of the text block to be processed.\n    :param prompt: string of the prompt to use for the chat completion request.\n    :param provider: string indicating the LLM provider (default is "openai").\n    :return: string of the processed text block or None if no valid response is received.\n    ')), If(test=Compare(left=Name(id='provider', ctx=Load()), ops=[Eq()], comparators=[Constant(value='openai')]), body=[Assign(targets=[Name(id='messages', ctx=Store())], value=List(elts=[Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='system'), Name(id='prompt', ctx=Load())]), Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='user'), Name(id='block', ctx=Load())])], ctx=Load())), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[BinOp(left=Constant(value='OPENAI LLM = '), op=Add(), right=Name(id='OPENAI_MODEL', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='chat_response', ctx=Store())], value=Call(func=Name(id='openai_chat_completion_request', ctx=Load()), args=[Name(id='messages', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='chat_response', ctx=Load()), attr='status_code', ctx=Load()), ops=[Eq()], comparators=[Constant(value=200)]), body=[Assign(targets=[Name(id='response_json', ctx=Store())], value=Call(func=Attribute(value=Name(id='chat_response', ctx=Load()), attr='json', ctx=Load()), args=[], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Constant(value='choices'), ops=[In()], comparators=[Name(id='response_json', ctx=Load())]), Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='response_json', ctx=Load()), slice=Constant(value='choices'), ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=0)])]), body=[Return(value=Subscript(value=Subscript(value=Subscript(value=Subscript(value=Name(id='response_json', ctx=Load()), slice=Constant(value='choices'), ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Constant(value='message'), ctx=Load()), slice=Constant(value='content'), ctx=Load()))], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value="No 'choices' in response or 'choices' list is empty.")], keywords=[])), Return(value=Constant(value=None))])], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Request failed with status code '), FormattedValue(value=Attribute(value=Name(id='chat_response', ctx=Load()), attr='status_code', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Attribute(value=Name(id='chat_response', ctx=Load()), attr='text', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Constant(value=None))])], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value="Provider '"), FormattedValue(value=Name(id='provider', ctx=Load()), conversion=-1), Constant(value="' is not set up yet.")])], keywords=[]))])], decorator_list=[]), FunctionDef(name='llm_process_file_blocks', args=arguments(posonlyargs=[], args=[arg(arg='blocks_file_path'), arg(arg='prompt'), arg(arg='suffix_new'), arg(arg='mode'), arg(arg='provider'), arg(arg='retain_delimiters')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='openai'), Constant(value=False)]), body=[Expr(value=Constant(value='\n    Processes blocks of text in a file using a specified prompt and operation mode, then writes the processed content back to the file.\n\n    :param blocks_file_path: string of the path to the file containing text blocks\n    :param prompt: string of the prompt to use for processing each text block\n    :param suffix_new: string of the suffix to append to the file when saving the new content\n    :param mode: string of the operation mode (\'replace\' or \'append\') to handle the processed blocks\n    :param provider: string indicating the LLM provider (default is "openai")\n    :param retain_delimiters: boolean indicating whether to retain the original block delimiters in the new content\n    :return: the path to the file with the updated content\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='read_metadata_and_content'), alias(name='write_metadata_and_content')], level=0), If(test=Compare(left=Name(id='mode', ctx=Load()), ops=[NotIn()], comparators=[List(elts=[Constant(value='replace'), Constant(value='append')], ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value="mode must be 'replace' or 'append'.")], keywords=[]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='metadata', ctx=Store()), Name(id='content', ctx=Store())], ctx=Store())], value=Call(func=Name(id='read_metadata_and_content', ctx=Load()), args=[Name(id='blocks_file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='content', ctx=Store())], value=Call(func=Attribute(value=Name(id='content', ctx=Load()), attr='lstrip', ctx=Load()), args=[Constant(value='## content\n\n')], keywords=[])), Assign(targets=[Name(id='blocks', ctx=Store())], value=Call(func=Attribute(value=Name(id='content', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='BLOCK_DELIMITER', ctx=Load())], keywords=[])), Assign(targets=[Name(id='processed_blocks', ctx=Store())], value=List(elts=[], ctx=Load())), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='BLOCKS TO PROCESS WITH SIMPLE LLM CALL: '), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='blocks', ctx=Load())], keywords=[]), conversion=-1), Constant(value='\n')])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Name(id='colored', ctx=Load()), args=[JoinedStr(values=[Constant(value='Simple LLM Call Prompt: '), FormattedValue(value=Name(id='prompt', ctx=Load()), conversion=-1), Constant(value='\n')]), Constant(value='red')], keywords=[])], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='block', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='blocks', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='\n\nBlock number: '), FormattedValue(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1)), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='llm_response', ctx=Store())], value=Call(func=Name(id='llm_process_block', ctx=Load()), args=[Name(id='block', ctx=Load()), Name(id='prompt', ctx=Load()), Name(id='provider', ctx=Load())], keywords=[])), If(test=Name(id='llm_response', ctx=Load()), body=[If(test=Compare(left=Name(id='mode', ctx=Load()), ops=[Eq()], comparators=[Constant(value='replace')]), body=[Expr(value=Call(func=Attribute(value=Name(id='processed_blocks', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='llm_response', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='mode', ctx=Load()), ops=[Eq()], comparators=[Constant(value='append')]), body=[Expr(value=Call(func=Attribute(value=Name(id='processed_blocks', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='block', ctx=Load()), op=Add(), right=Constant(value='\n')), op=Add(), right=Name(id='llm_response', ctx=Load()))], keywords=[]))], orelse=[])]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Name(id='colored', ctx=Load()), args=[Constant(value='User Input:'), Constant(value='green')], keywords=[])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Name(id='colored', ctx=Load()), args=[Name(id='block', ctx=Load()), Constant(value='green')], keywords=[])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Name(id='colored', ctx=Load()), args=[Constant(value='LLM Response:'), Constant(value='blue')], keywords=[])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Name(id='colored', ctx=Load()), args=[Name(id='llm_response', ctx=Load()), Constant(value='blue')], keywords=[])], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='No response received for block.')], keywords=[]))])], orelse=[]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Name(id='colored', ctx=Load()), args=[JoinedStr(values=[Constant(value='\nSingle LLM call prompt: '), FormattedValue(value=Name(id='prompt', ctx=Load()), conversion=-1), Constant(value='\n')]), Constant(value='red')], keywords=[])], keywords=[])), Assign(targets=[Name(id='new_content', ctx=Store())], value=Constant(value='## content\n\n')), AugAssign(target=Name(id='new_content', ctx=Store()), op=Add(), value=IfExp(test=UnaryOp(op=Not(), operand=Name(id='retain_delimiters', ctx=Load())), body=Call(func=Attribute(value=Constant(value='\n\n'), attr='join', ctx=Load()), args=[Name(id='processed_blocks', ctx=Load())], keywords=[]), orelse=Call(func=Attribute(value=Name(id='BLOCK_DELIMITER', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='processed_blocks', ctx=Load())], keywords=[]))), Return(value=Call(func=Name(id='write_metadata_and_content', ctx=Load()), args=[Name(id='blocks_file_path', ctx=Load()), Name(id='metadata', ctx=Load()), Name(id='new_content', ctx=Load()), Name(id='suffix_new', ctx=Load())], keywords=[keyword(arg='overwrite', value=Constant(value='no-sub'))]))], decorator_list=[]), FunctionDef(name='scall_replace', args=arguments(posonlyargs=[], args=[arg(arg='blocks_file_path'), arg(arg='prompt'), arg(arg='suffix_new'), arg(arg='provider'), arg(arg='retain_delimiters')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='_scall-replace'), Constant(value='openai'), Constant(value=False)]), body=[Expr(value=Constant(value='\n    Processes a file\'s text blocks and replace the original text with LLM-processed content based on a given prompt.\n    \n    :param blocks_file_path: string of the path to the file containing text blocks\n    :param prompt: string of the prompt to use for processing each text block\n    :param suffix_new: string of the suffix to append to the file when saving the new content\n    :param provider: string indicating the LLM provider (default is "openai")\n    :param retain_delimiters: boolean indicating whether to retain the original block delimiters in the new content\n    :return: string of the path to the file with the updated content\n    ')), Return(value=Call(func=Name(id='llm_process_file_blocks', ctx=Load()), args=[Name(id='blocks_file_path', ctx=Load()), Name(id='prompt', ctx=Load()), Name(id='suffix_new', ctx=Load()), Constant(value='replace')], keywords=[keyword(arg='provider', value=Name(id='provider', ctx=Load())), keyword(arg='retain_delimiters', value=Name(id='retain_delimiters', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='scall_append', args=arguments(posonlyargs=[], args=[arg(arg='blocks_file_path'), arg(arg='prompt'), arg(arg='suffix_new'), arg(arg='provider'), arg(arg='retain_delimiters')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='_scall-append'), Constant(value='openai'), Constant(value=False)]), body=[Expr(value=Constant(value='\n    Processes a file\'s text blocks to append LLM-processed content based on a given prompt after the original text.\n    \n    :param blocks_file_path: string of the path to the file containing text blocks\n    :param prompt: string of the prompt to use for processing each text block\n    :param suffix_new: string of the suffix to append to the file when saving the new content\n    :param provider: string indicating the LLM provider (default is "openai")\n    :param retain_delimiters: boolean indicating whether to retain the original block delimiters in the new content\n    :return: string of the path to the file with the updated content\n    ')), Return(value=Call(func=Name(id='llm_process_file_blocks', ctx=Load()), args=[Name(id='blocks_file_path', ctx=Load()), Name(id='prompt', ctx=Load()), Name(id='suffix_new', ctx=Load()), Constant(value='append')], keywords=[keyword(arg='provider', value=Name(id='provider', ctx=Load())), keyword(arg='retain_delimiters', value=Name(id='retain_delimiters', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='create_simple_llm_file', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='prompt'), arg(arg='suffix_new'), arg(arg='mode'), arg(arg='split_file_function'), arg(arg='provider')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value='openai')]), body=[Expr(value=Constant(value='\n    Processes a file with a simple llm call to create a LLM-processed version using a specified block separation function and prompt.\n    Substitutes the suffix_new for the original suffix of the file_path.\n\n    :param file_path: string of the path to the file to be processed\n    :param prompt: string of the prompt to use for processing each text block\n    :param suffix_new: string of the new suffix that will be substituted for the original suffix\n    :param mode: string indicating the operation mode (\'replace\' or \'append\')\n    :param split_file_function: function used to separate the file into blocks\n    :param provider: string indicating the LLM provider (default is "openai")\n    :param args: additional positional arguments passed to the block separation function\n    :param kwargs: additional keyword arguments passed to the block separation function\n    :return: string of the path to the file with the updated content\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='delete_file')], level=0), Assign(targets=[Name(id='separation_kwargs', ctx=Store())], value=DictComp(key=Name(id='key', ctx=Load()), value=Name(id='value', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Compare(left=Name(id='key', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='retain_delimiters')])], is_async=0)])), Assign(targets=[Name(id='blocks_file_path', ctx=Store())], value=Call(func=Name(id='split_file_function', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='separation_kwargs', ctx=Load()))])), Assign(targets=[Name(id='llm_kwargs', ctx=Store())], value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Name(id='llm_kwargs', ctx=Load()), slice=Constant(value='retain_delimiters'), ctx=Store())], value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='retain_delimiters'), Constant(value=False)], keywords=[])), If(test=Compare(left=Name(id='mode', ctx=Load()), ops=[Eq()], comparators=[Constant(value='replace')]), body=[Assign(targets=[Name(id='llm_file_path', ctx=Store())], value=Call(func=Name(id='scall_replace', ctx=Load()), args=[Name(id='blocks_file_path', ctx=Load()), Name(id='prompt', ctx=Load())], keywords=[keyword(arg='suffix_new', value=Name(id='suffix_new', ctx=Load())), keyword(arg='provider', value=Name(id='provider', ctx=Load())), keyword(value=Name(id='llm_kwargs', ctx=Load()))]))], orelse=[If(test=Compare(left=Name(id='mode', ctx=Load()), ops=[Eq()], comparators=[Constant(value='append')]), body=[Assign(targets=[Name(id='llm_file_path', ctx=Store())], value=Call(func=Name(id='scall_append', ctx=Load()), args=[Name(id='blocks_file_path', ctx=Load()), Name(id='prompt', ctx=Load())], keywords=[keyword(arg='suffix_new', value=Name(id='suffix_new', ctx=Load())), keyword(arg='provider', value=Name(id='provider', ctx=Load())), keyword(value=Name(id='llm_kwargs', ctx=Load()))]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value="mode must be 'replace' or 'append'.")], keywords=[]))])]), Expr(value=Call(func=Name(id='delete_file', ctx=Load()), args=[Name(id='blocks_file_path', ctx=Load())], keywords=[])), Return(value=Name(id='llm_file_path', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='PROMPT_SUMMARIZE', ctx=Store())], value=Constant(value='\nsummaize the text after the speaker line as 3 keywords that best captures what is said, returned as a single line with commas between the words. retain the speaker line exactly as it is and put the new key word line as the next line directly underneath')), Assign(targets=[Name(id='PROMPT_QUOTATIONS', ctx=Store())], value=Constant(value='\nYou are an expert at transcript processing, you are to evaluate the provided text according to specific quotation guidelines. Your task is to ensure that all instances of direct speech, internal monologue, specific terms, and imitations are correctly enclosed in single quotation marks. Additionally, you must identify and correct instances where quotations are missing or misused. Follow these guidelines:\n\n1. Use single quotes \' \' for direct speech in anothers voice. Include a comma before the quote if it\'s preceded by a speech attribution (e.g., he said, she asked). Example correction: John said hello → John said, \'hello\'.\n\n2. Use single quotes for internal monologue presented as direct speech.\n\n3. For specific terms, jargon, or phrases, use quotes, but do not add commas before the quotes. Place punctuation inside the single quotes.\n\n4. Contextually decide if quotes are needed for ambiguous sentences.\n\nIn addition to those rules for quotations, please note the following things to keep in mind.\n\n*  Do not add quotes for indirect speech. ie: they expressed their appreciation for them\n\n*  For nested dialogue, use single quotes for the primary speech and double quotes for the nested part. \n\n*  Keep punctuation inside the single quotes for full sentences. For fragments, place punctuation outside.\n\n*  For interrupted dialogue, continue the sentence within the same quotes after the tag or action.\n\n*  Use single quotes for special cases like sarcasm or mimicry.\n\n* Pay special attention to specific and related patterns that my preceed a quotation. These patterns include but are not limited to:\n"they might say, "\n"say well, "\n"oh,"\n"might ask"\n\nYour primary tasks are to:\n- Identify and fix instances where quotations are incorrectly applied.\n- Locate and edit parts of the text where quotations are necessary but missing, according to these guidelines.\n\nPlease evaluate the text provided and make necessary corrections or suggest where quotations should be added or amended.\nIf an existing quotation is found your response should be the quote itself in curly braces, followed by a few word description of the problem with \'**\' at either end. if there is no problem with the existing quotation, just say \'CORRECT\' for that description. If there is text that is not enclosed in quotes that shouldnt be, then DONT RETURN ANYTHING FOR IT. IGNORE IT. THE CURLY BRACES ARE AN IMPORTANT FLAG, USE THEM.\nIf there is a section that, according to the rules should have a quote, then return the section that should be quoted, with a few extra words from the text on either side. the quotes should be applied and flagged by curly braces and a description that uses the number of the rule that is being referenced to make the call.\nIf no changes at all are to be needed, please only respond with \'N/A\'. Only use \'N/A\' when there are no errors or quotes in the entire block.')), Assign(targets=[Name(id='PROMPT_COPYEDIT', ctx=Store())], value=Constant(value='\nYou are an expert in copyediting interview transcripts. Your task is to refine the transcript while preserving its verbatim nature. Follow these guidelines:\n1. General Principles:\n- Maintain verbatim transcription: Preserve the speaker\'s original words and speech patterns as much as possible.\n- Aim for a polished and readable transcript while keeping the original meaning and style intact.\n- Don\'t rephrase.\n- Don\'t make drastic changes, don\'t make any changes that does not align with the given guidelines.\n- Don\'t correct grammatical errors.\n- Don\'t remove words if unnecessary or if it does not fall in any of the following guidelines mentioned.\n\n2. Speaker Transitions and Segmentation based on context:\n- Correct unsplit speaker segments based on context and conversation flow.\n\n3. Proper Names and Terminology:\n- Correct and standardize spelling of proper names, places, and specialized terms.\n- Capitalize proper nouns appropriately.\n- Capitalize also the positions and organizations (e.g., Town Manager, Town Council, Fire Marshal)\n- Use unpunctuated acronyms, please don\'t add periods in between (e.g., ASCC instead of A.S.C.C.)\n\n4. Transcription Error Correction:\n- Identify and fix words that don\'t make sense given the surrounding context. (e.g., \'The cat jumped over the moon\'  might be an error for \'The cat jumped over the broom.\')\n- Replace the informal word \'gonna\' with \'going to\' and \'wanna\' with \'want to\' \n\n5. Punctuations and Formatting:\n- Use appropriate punctuation: commas, periods, question marks.\n- Use double quotation marks ("") for quoted speech or phrase, meaning when the speaker is quoting someone else\'s words.\n- Don\'t use exclamation marks (!) replace them with periods (.).\n- If there are any forward slash (/) or backslash (\\), replace them with dashes (-).\n- Don\'t use semicolons (;) and colons (:), if needed then use commas (,) instead.\n- Don\'t use hyphens (—) or dashes (-), if needed then use commas (,) instead.\n- Don\'t use this format of ellipsis \'…\', use three periods (...) instead.\n\n6. Disfluencies and Filler Words:\n- Remove repetitions unless they add meaning (e.g., \'I I\' change to \'I\', \'this this\' chang to \'this\', \'he said that he said that\' change to \'he said that\').\n- Remove \'uh\' and \'um\' unless they significantly impact meaning.\n- Retain \'you know,\' \'I mean,\' \'like,\' and \'yeah\' if they add meaning to the statement.\n- Only use commas for restarts, hesitations, and self-corrections (e.g., I want to, I mean, I need to fix, or rather, correct this issue.).\n- Don\'t use hyphen (—) or dashes (-) for restarts, hesitations, and self-corrections.\n\n7. Time and Dates:\n- Change time format from 24-hour to 12-hour when appropriate (e.g., 14:00 to 2 o\'clock).   \n- Format dates consistently, as much as possible use the long format date (e.g., June 1st, June 4th).\n\n8. Special Characters and Formatting:\n- Spell out currency types (e.g., change $123 to 123 dollars).\n- Use the special character \'&\' only if needed in the proper name (e.g., AT&T).\n- Replace special characters with their standard English equivalents (e.g., Gödel to Godel).\n\n9. Quotations and Specific Terms:\n- Use double quotation marks if the speaker is quoting someone\'s words (e.g., Popper said, “Science must begin with myths, and with criticism of myths.").\n- Follow the American style for quotations, place periods and commas inside quotation marks.\n\nHere are examples with explanations of the kinds of edits I\'m looking:\n<example1>\nBefore: Dale Pfau (EPC Chair)  [9:14](https://youtu.be/hNFjjFll1EY&t=554)\nWhen the new ones come out? We we will probably review them at least in September. We\'ll review full committing yet. Do you have any do you have any idea when that might happen?\n\nAfter: Dale Pfau (EPC Chair)  [9:14](https://youtu.be/hNFjjFll1EY&t=554)\nWhen the new ones come out? We will probably review them at least in subcommittee and may bring them to full committee. Yeah. Do you have any idea when that might happen?\n\nExplanation:\n- Removed repetition of "we".\n- Corrected "full committing" to "full committee" based on context.\n- Removed repetition of "do you have any".\n- Added "Yeah." to separate the response to the previous question from the new question.\n</example1>\n\n<example2>\nBefore: Dale Pfau (EPC Chair)  [15:30](https://youtu.be/hNFjjFll1EY&t=930)\nTo add to that. I\'ve had Starlink a little over a year now. I use it. I primarily got it as a backup to another Internet connection I have that goes out. StarLink never goes out. As long as you\'ve got power, it\'s gonna be there. So even AT and T Fiber goes out occasionally when they lose power.\n\nAfter: Dale Pfau (EPC Chair)  [15:30](https://youtu.be/hNFjjFll1EY&t=930)\nTo add to that, I\'ve had Starlink a little over a year now. I use it. I primarily got it as a backup to another internet connection I have that goes out. Starlink never goes out. As long as you\'ve got power, it\'s going to be there. So even AT&T Fiber goes out occasionally when they lose power.\n\nExplanation:\n- Added a comma after "To add to that".\n- Changed "Internet" to lowercase "internet" as it\'s not a proper noun.\n- Corrected the proper noun "StarLink" to "Starlink".\n- Changed "gonna" to "going to" for formality.\n- Corrected the proper noun "AT and T" to "AT&T".\n</example2>\n\nPlease apply the necessary corrections to the transcript while maintaining the integrity of the spoken content. Remember that when in doubt and it\'s not specified in the given guidelines, prioritize preserving the original speech over making grammatical improvements. If you\'re unsure about a potential edit, flag it for human review, add *** in the beginning and end of the word or phrase that needs to be reviewed.\n\nBefore providing your final response, think through your edits step by step to ensure consistency and adherence to the provided guidelines.\n')), FunctionDef(name='create_copyedit_file', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='split_file_function'), arg(arg='prompt')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value="\n    Processes a file for copyediting by separating it into blocks, applying a prompt to each block, and appending the results to a new file with a '_copyedit' suffix.\n    Uses an argument to pass in the separator function, in case you want different types of blocks\n\n    :param file_path: string of the path to the file to be processed\n    :param split_file_function: function used to separate the file into blocks\n    :param prompt: string of the prompt to use for processing each text block\n    :param args: additional positional arguments passed to the block separation function\n    :param kwargs: additional keyword arguments passed to the block separation function\n    :return: string of the path to the file with the updated content\n    ")), ImportFrom(module='primary.fileops', names=[alias(name='delete_file')], level=0), Assign(targets=[Name(id='blocks_file_path', ctx=Store())], value=Call(func=Name(id='split_file_function', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), Assign(targets=[Name(id='copyedit_file_path', ctx=Store())], value=Call(func=Name(id='scall_replace', ctx=Load()), args=[Name(id='blocks_file_path', ctx=Load()), Name(id='prompt', ctx=Load())], keywords=[keyword(arg='retain_delimiters', value=Constant(value=True)), keyword(arg='suffix_new', value=Constant(value='_llmce'))])), Expr(value=Call(func=Name(id='delete_file', ctx=Load()), args=[Name(id='blocks_file_path', ctx=Load())], keywords=[])), Return(value=Name(id='copyedit_file_path', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='PROMPT_TRANSITIONS', ctx=Store())], value=Constant(value='\n    Your task is to analyze transcripts for speaker transition errors. \n    You will do this on a single speaker segment where the speaker segments are identified by a speaker name followed by a time stamp with a link. And then on the next line, the segment text, which is the dialogue of what that speaker\n    The intended target segment is identified as the segment that follows the following text "TARGET SEGMENT TO ANALYZE FOR TRANSITIONS".\n    The input text I\'m providing contains the ending speaker text from the speaker segment above, and it also contains below the target segment the beginning text from below. And those adjacent text are provided for context so you can look to see if there are words from the previous segment that should be in the target segment, and likewise if there are words from the next segment that should, that start the next segment that should be at the end of the target segment.    \n    For your analysis, ignore any text on the speaker line itself, which is the line that contains the speaker name and the timestamp. There could be additional words after that for other processing. Just ignore those, such as \'SKIPQA\'\n    \n    To do the analysis To look for possible transition errors in the target segment, what you should do is look at the ending words of the text above, which is from the previous segment, and see if they both, see if that text both looks out of place at the end of that text, and then insert that text at the beginning of the speaker segment text for the target segment and see if that fits better as a speaker dialogue. And you can also analyze that target speaker segment text to see if it looks out of place without the added text.\n\n    If your analysis concludes that there are no transition errors in the text for the target segment, then make your response only the text "No suspected transition errors."\n    If your analysis concludes that there are transition errors, then state what those are with quoted text, but do not reproduce the entire text for the target segment. I will make the modifications manually.\n    ')), Assign(targets=[Name(id='PROMPT_TRANSITIONS_2', ctx=Store())], value=Constant(value="\n    Your task is to analyze transcripts for speaker transition errors. You will be given entiere speaker segments and you will return suggestions if needed. Follow these guidelines:\n1. **Speaker Transitions (ST) - Identifying Missing Speaker Transitions**:\n   - ALWAYS Flag and suggest changes when there is a possible interjection from another speaker such as these listed:\n        - 'Yes, I agree.'\n        - 'Okay.'\n        - 'Right.'\n    - Be creative and think deeply about any sentence that could be from a different speaker and flag it with curly braces if there is doubt that the entire block is from a single speaker.\n    - If there is any text at all that could be interpreted as coming from a seperate speaker, than Flag it for review.\n    - Heavily favor tagging possible errors in the middle of a speaker block, rather than at the beggining or end. Do not flag anything at the beginning or the end of a block. assume that whatever is there is correct.\n3. **Evaluating Overlapping Talk**:\n   a) If overlapping talk is short and doesn't affect meaning, suggest integrating it into the next speaker segment.\n   b) If moving the overlap confuses the start of the next segment and the overlapping statement is short and insignificant, suggest deletion.\n   c) If the overlapping statement is significant and moving it confuses the start of the next segment, suggest adding a new speaker segment.\n\nYour response if a change is considered to be needed should be of the entire text given to you, but with the problematic section enclosed in curly braces, followed by a few word description of the problem with '**' at either end. THE CURLY BRACES ARE AN IMPORTANT FLAG, USE THEM.\nIf no changes at all are to be needed, please only respond with 'N/A'. Only use 'N/A' when there are no errors in the entire block. The parts that are without error before or after an error should still be returned.\n    ")), FunctionDef(name='mod_blocks_file_with_adjacent_words', args=arguments(posonlyargs=[], args=[arg(arg='blocks_file_path'), arg(arg='num_adjacent_words')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Modifies the content of a file by adding a specified number of words from the previous and next blocks to each block.\n    Also adds a Markdown heading and content at the beginning of the new content.\n    :param blocks_file_path: string of the path to the file containing text blocks\n    :param num_adjacent_words: integer indicating the number of words to add from adjacent blocks\n    :return: None\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='read_metadata_and_content'), alias(name='write_metadata_and_content')], level=0), Assign(targets=[Tuple(elts=[Name(id='metadata', ctx=Store()), Name(id='content', ctx=Store())], ctx=Store())], value=Call(func=Name(id='read_metadata_and_content', ctx=Load()), args=[Name(id='blocks_file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='content', ctx=Store())], value=Call(func=Attribute(value=Name(id='content', ctx=Load()), attr='lstrip', ctx=Load()), args=[Constant(value='## content\n\n')], keywords=[])), Assign(targets=[Name(id='blocks', ctx=Store())], value=Call(func=Attribute(value=Name(id='content', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='BLOCK_DELIMITER', ctx=Load())], keywords=[])), Assign(targets=[Name(id='modified_blocks', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='block', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='blocks', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='prev_context', ctx=Store())], value=IfExp(test=Compare(left=Name(id='i', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=Call(func=Attribute(value=Constant(value=' '), attr='join', ctx=Load()), args=[Subscript(value=Call(func=Attribute(value=Subscript(value=Name(id='blocks', ctx=Load()), slice=Call(func=Name(id='max', ctx=Load()), args=[Constant(value=0), BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Constant(value=1))], keywords=[]), ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_adjacent_words', ctx=Load()))), ctx=Load())], keywords=[]), orelse=Constant(value=''))), Assign(targets=[Name(id='next_context', ctx=Store())], value=IfExp(test=Compare(left=Name(id='i', ctx=Load()), ops=[Lt()], comparators=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='blocks', ctx=Load())], keywords=[]), op=Sub(), right=Constant(value=1))]), body=Call(func=Attribute(value=Constant(value=' '), attr='join', ctx=Load()), args=[Subscript(value=Call(func=Attribute(value=Subscript(value=Name(id='blocks', ctx=Load()), slice=Call(func=Name(id='min', ctx=Load()), args=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='blocks', ctx=Load())], keywords=[]), op=Sub(), right=Constant(value=1)), BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1))], keywords=[]), ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[]), slice=Slice(upper=BinOp(left=Name(id='num_adjacent_words', ctx=Load()), op=Add(), right=Constant(value=3))), ctx=Load())], keywords=[]), orelse=Constant(value=''))), Assign(targets=[Name(id='augmented_block', ctx=Store())], value=Call(func=Attribute(value=JoinedStr(values=[FormattedValue(value=Name(id='prev_context', ctx=Load()), conversion=-1), Constant(value='\n\nTARGET SEGMENT\n'), FormattedValue(value=Name(id='block', ctx=Load()), conversion=-1), Constant(value='\n\n'), FormattedValue(value=Name(id='next_context', ctx=Load()), conversion=-1)]), attr='strip', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='modified_blocks', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='augmented_block', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='new_content', ctx=Store())], value=BinOp(left=Constant(value='## content\n\n'), op=Add(), right=Call(func=Attribute(value=Name(id='BLOCK_DELIMITER', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='modified_blocks', ctx=Load())], keywords=[]))), Expr(value=Call(func=Name(id='write_metadata_and_content', ctx=Load()), args=[Name(id='blocks_file_path', ctx=Load()), Name(id='metadata', ctx=Load()), Name(id='new_content', ctx=Load())], keywords=[keyword(arg='overwrite', value=Constant(value='yes'))])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Modified block file with adjacent words for block file: '), FormattedValue(value=Name(id='blocks_file_path', ctx=Load()), conversion=-1)])], keywords=[]))], decorator_list=[]), FunctionDef(name='scall_replace_adjacent_words', args=arguments(posonlyargs=[], args=[arg(arg='blocks_file_path'), arg(arg='prompt'), arg(arg='adjacent_words'), arg(arg='retain_delimiters'), arg(arg='suffix_new')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Constant(value='_scall-replace-adj')]), body=[Expr(value=Constant(value='\n    Replaces words adjacent to each block in a file with a language model processed version based on a given prompt.\n\n    :param blocks_file_path: string of the path to the file containing text blocks\n    :param prompt: string of the prompt to process each block with\n    :param adjacent_words: integer indicating the number of words to add from adjacent blocks\n    :param retain_delimiters: boolean indicating whether to retain original block delimiters\n    :param suffix_new: string of the suffix to append to the new file name\n    :return: string of the path to the modified file\n    ')), Expr(value=Call(func=Name(id='mod_blocks_file_with_adjacent_words', ctx=Load()), args=[Name(id='blocks_file_path', ctx=Load()), Name(id='adjacent_words', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='llm_process_file_blocks', ctx=Load()), args=[Name(id='blocks_file_path', ctx=Load()), Name(id='prompt', ctx=Load()), Name(id='suffix_new', ctx=Load()), Constant(value='replace'), Name(id='retain_delimiters', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='create_transitions_file', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='split_file_function'), arg(arg='prompt')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='\n    Creates a file with transitions between blocks processed by a language model based on a given prompt.\n\n    :param file_path: string of the path to the original file\n    :param split_file_function: function used to separate the original file into blocks\n    :param prompt: string of the prompt to process each block with\n    :return: string of the path to the transitions file\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='delete_file')], level=0), Assign(targets=[Name(id='adjacent_words', ctx=Store())], value=Constant(value=10)), Assign(targets=[Name(id='blocks_file_path', ctx=Store())], value=Call(func=Name(id='split_file_function', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), Assign(targets=[Name(id='transitions_file_path', ctx=Store())], value=Call(func=Name(id='scall_replace_adjacent_words', ctx=Load()), args=[Name(id='blocks_file_path', ctx=Load()), Name(id='prompt', ctx=Load()), Name(id='adjacent_words', ctx=Load())], keywords=[keyword(arg='retain_delimiters', value=Constant(value=True)), keyword(arg='suffix_new', value=Constant(value='_transitions'))])), Expr(value=Call(func=Name(id='delete_file', ctx=Load()), args=[Name(id='blocks_file_path', ctx=Load())], keywords=[])), Return(value=Name(id='transitions_file_path', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='FCALL_PROMPT_QA_DIALOGUE_STATEDQA', ctx=Store())], value=Constant(value='\nYou are an expert text analyzer that is trained in identifying stated questions and answers in transcripts of dialogue. You will be given blocks of dialogue and your role is to return extracted question and answer pairs that faithfully capture the meaningful content in the dialogue, while removing filler words and minimally modifying the text for clarity and readability. You will use your tool to only return exact JSON in the format specified.\n')), Assign(targets=[Name(id='FCALL_PROMPT_QA_DIALOGUE_FROMANSWER', ctx=Store())], value=Constant(value='\nYou are an expert text analyzer that is trained in identifying questions or implied questions. You will be given dialogue and your role is to return a create a general, simple question from the provided answer. This created general question may or may not be related to the question actually asked by the speaker in the dialogue preceding the answer. The created general question will be part of a question and answer set used for Retrieval Augmented Generation. The question must not mention the speaker name. You will use your tool to only return exact JSON in the format specified.\n')), Assign(targets=[Name(id='FCALL_PROMPT_QA_DEUTSCH', ctx=Store())], value=Constant(value="\nYou are an expert text analyzer that is trained in identifying questions or implied questions. You will be given dialogue and your role is to return a create a general, simple question from the provided answer. This created general question may or may not be related to the question actually asked by the speaker in the dialogue preceding the answer. The created general question will be part of a question and answer set used for Retrieval Augmented Generation. The question must not mention the speaker name. The question should be written in such a way that it assumes that the answer provided is the best knowledge humanity has about this topic at present moment.  Some specific phrases to use include: 1) 'multiverse quantum theory' - rather than 'many-worlds interpretation of quantum'. You will use your tool to only return exact JSON in the format specified. \n")), Assign(targets=[Name(id='CUSTOM_INSTRUCTIONS_DEUTSCH_GENERALQ', ctx=Store())], value=Constant(value="\nAnalyze the following passage and create a general, simple question for which the answer will be the response. This will be part of a question and answer set such that new questions are compared against the questions, and answers retrieved. The question should not mention the author, or David Deutsch. The question should be written in such a way that it assumes that the answer provided is the best knowledge humanity has about this topic at present moment. Use the phrase 'multiverse quantum theory' rather than 'many-worlds interpretation of quantum'\n")), FunctionDef(name='tools_qa_speaker', args=arguments(posonlyargs=[], args=[arg(arg='speaker')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Generate a list of tools for question and answer extraction based on the speaker's response.\n\n    :param speaker: string of the speaker's name whose responses are being analyzed\n    :return: list of dictionaries containing tool configurations for QA extraction\n    ")), Return(value=List(elts=[Dict(keys=[Constant(value='type'), Constant(value='function')], values=[Constant(value='function'), Dict(keys=[Constant(value='name'), Constant(value='description'), Constant(value='parameters')], values=[Constant(value='get_qa'), Constant(value='Extract and modify a question into a generic form and provide the exact verbatim answer from a transcript'), Dict(keys=[Constant(value='type'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='object'), Dict(keys=[Constant(value='question'), Constant(value='timestamp')], values=[Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='string'), JoinedStr(values=[Constant(value='\n                    The question should capture the essence of the original query posed by the interviewer in a simplified, generic form. It should focus on the core topic or idea, removing extraneous contextual details. The modified question should have semantic alignment with '), FormattedValue(value=Name(id='speaker', ctx=Load()), conversion=-1), Constant(value="'s answer. The question should be rephrased for a third-person audience, ensuring it is generalized and does not include direct references to "), FormattedValue(value=Name(id='speaker', ctx=Load()), conversion=-1), Constant(value='. DO NOT mention the name '), FormattedValue(value=Name(id='speaker', ctx=Load()), conversion=-1), Constant(value=' in the question.\n                    ')])]), Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='string'), JoinedStr(values=[Constant(value='\n                    The timestamp corresponding to the start of '), FormattedValue(value=Name(id='speaker', ctx=Load()), conversion=-1), Constant(value="'s response in the format H:MM:SS or MM:SS or M:SS (chose whichever is present in the input text). This timestamp is crucial for contextualizing the answer within the transcript and must be accurate to reflect the exact moment the response begins.\n                    ")])])]), List(elts=[Constant(value='question'), Constant(value='timestamp')], ctx=Load())])])])], ctx=Load()))], decorator_list=[]), FunctionDef(name='fcall_qa_speaker', args=arguments(posonlyargs=[], args=[arg(arg='block_file_path'), arg(arg='speaker'), arg(arg='fcall_prompt'), arg(arg='suffix_new')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='_qa')]), body=[Expr(value=Constant(value=' \n    Processes a transcript file already sectioned into blocks to generate new question and answer file.\n    Answers are based on the speaker segments of the provided speaker.\n    Uses OpenAI function calling.\n\n    :param block_file_path: string of the path to the _blocks file to be processed.\n    :param speaker: string of the speaker\'s name for the answers in QA.\n    :param fcall_prompt: string of the prompt to be used for function calling.\n    :param suffix_new: string of the suffix to be appended to the original filename for the new file. Defaults to "_qa".\n    :return: string of the path to the newly created file with QA\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='read_metadata_and_content'), alias(name='add_timestamp_links')], level=0), ImportFrom(module='primary.fileops', names=[alias(name='sub_suffix_in_str'), alias(name='set_last_updated'), alias(name='write_metadata_and_content')], level=0), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[BinOp(left=Constant(value='***Running fcall_qa on file: '), op=Add(), right=Name(id='block_file_path', ctx=Load()))], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='metadata', ctx=Store()), Name(id='block_content', ctx=Store())], ctx=Store())], value=Call(func=Name(id='read_metadata_and_content', ctx=Load()), args=[Name(id='block_file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Name(id='set_last_updated', ctx=Load()), args=[Name(id='metadata', ctx=Load()), Constant(value='Created QA')], keywords=[])), Assign(targets=[Name(id='blocks', ctx=Store())], value=Call(func=Attribute(value=Name(id='block_content', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='BLOCK_DELIMITER', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='QA BLOCKS TO PROCESS: '), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='blocks', ctx=Load())], keywords=[]), conversion=-1), Constant(value='\n')])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Name(id='colored', ctx=Load()), args=[JoinedStr(values=[Constant(value='System Prompt: '), FormattedValue(value=Name(id='fcall_prompt', ctx=Load()), conversion=-1), Constant(value='\n')]), Constant(value='red')], keywords=[])], keywords=[])), Expr(value=Call(func=Name(id='pretty_print_function_descriptions', ctx=Load()), args=[Call(func=Name(id='tools_qa_speaker', ctx=Load()), args=[Name(id='speaker', ctx=Load())], keywords=[]), Constant(value='red')], keywords=[])), Assign(targets=[Name(id='qa_content', ctx=Store())], value=Constant(value='## content\n\n')), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='block', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='blocks', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='\n\nQA BLOCK NUMBER: '), FormattedValue(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1)), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='qa_response', ctx=Store())], value=Call(func=Name(id='openai_function_call', ctx=Load()), args=[Name(id='fcall_prompt', ctx=Load()), Name(id='block', ctx=Load()), Call(func=Name(id='tools_qa_speaker', ctx=Load()), args=[Name(id='speaker', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='arguments_json', ctx=Store())], value=Subscript(value=Subscript(value=Subscript(value=Subscript(value=Name(id='qa_response', ctx=Load()), slice=Constant(value='tool_calls'), ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Constant(value='function'), ctx=Load()), slice=Constant(value='arguments'), ctx=Load())), Try(body=[Assign(targets=[Name(id='arguments', ctx=Store())], value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='loads', ctx=Load()), args=[Name(id='arguments_json', ctx=Load())], keywords=[])), Assign(targets=[Name(id='question', ctx=Store())], value=Subscript(value=Name(id='arguments', ctx=Load()), slice=Constant(value='question'), ctx=Load())), Assign(targets=[Name(id='timestamp', ctx=Store())], value=Subscript(value=Name(id='arguments', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load())), Assign(targets=[Name(id='answer', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='block', ctx=Load()), slice=Slice(lower=BinOp(left=Call(func=Attribute(value=Name(id='block', ctx=Load()), attr='rfind', ctx=Load()), args=[Constant(value=')')], keywords=[]), op=Add(), right=Constant(value=1))), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Attribute(value=Attribute(value=Name(id='json', ctx=Load()), attr='decoder', ctx=Load()), attr='JSONDecodeError', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='JSONDecodeError:'), Name(id='e', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[]), AugAssign(target=Name(id='qa_content', ctx=Store()), op=Add(), value=JoinedStr(values=[Constant(value='QUESTION: '), FormattedValue(value=Name(id='question', ctx=Load()), conversion=-1), Constant(value='\nTIMESTAMP: '), FormattedValue(value=Name(id='timestamp', ctx=Load()), conversion=-1), Constant(value='\nANSWER: '), FormattedValue(value=Name(id='answer', ctx=Load()), conversion=-1), Constant(value='\nEDITS: \nTOPICS: \nSTARS: \n\n')]))], orelse=[]), Assign(targets=[Name(id='qa_file_path', ctx=Store())], value=Call(func=Name(id='write_metadata_and_content', ctx=Load()), args=[Name(id='block_file_path', ctx=Load()), Name(id='metadata', ctx=Load()), Name(id='qa_content', ctx=Load()), Name(id='suffix_new', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[BinOp(left=Constant(value='QA written to '), op=Add(), right=Name(id='qa_file_path', ctx=Load()))], keywords=[])), Expr(value=Call(func=Name(id='add_timestamp_links', ctx=Load()), args=[Name(id='qa_file_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Timestamp Links added.')], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Name(id='colored', ctx=Load()), args=[JoinedStr(values=[Constant(value='System Prompt: '), FormattedValue(value=Name(id='fcall_prompt', ctx=Load()), conversion=-1), Constant(value='\n')]), Constant(value='red')], keywords=[])], keywords=[])), Expr(value=Call(func=Name(id='pretty_print_function_descriptions', ctx=Load()), args=[Call(func=Name(id='tools_qa_speaker', ctx=Load()), args=[Name(id='speaker', ctx=Load())], keywords=[]), Constant(value='red')], keywords=[])), Return(value=Name(id='qa_file_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='create_qa_file_select_speaker', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='speaker'), arg(arg='fcall_prompt')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Processes a _prepqa file to generate QA question and answer blocks using OpenAI LLM function calling.\n\n    :param file_path: string of the path to the _prepqa transcript file to be processed.\n    :param speaker: string of the speaker's name to be used in processing.\n    :return: None.\n    ")), Assign(targets=[Name(id='blocks_file_path', ctx=Store())], value=Call(func=Name(id='split_file_select_speaker', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='speaker', ctx=Load())], keywords=[])), Assign(targets=[Name(id='qa_file_path', ctx=Store())], value=Call(func=Name(id='fcall_qa_speaker', ctx=Load()), args=[Name(id='blocks_file_path', ctx=Load()), Name(id='speaker', ctx=Load()), Name(id='fcall_prompt', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='delete_file', ctx=Load()), args=[Name(id='blocks_file_path', ctx=Load())], keywords=[])), Return(value=Name(id='qa_file_path', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='FCALL_SYSTEM_PROMPT_QA_INCREMENTAL_TRANSCTIPRT_FDA_TOWNHALLS_1ST_DRAFT', ctx=Store())], value=Constant(value="\n    You are an expert text analyzer trained in identifying questions and answers in transcripts of dialogue. \n    Your role is to extract and clarify the next question-answer pair from the given transcript chunk.\n    The previous question-answer pair is provided in both the original text verbatim version and in a modified clarified version.\n\n    Your task is identify the next important information that comes after the previous question-answer pair. This important information may comprise an explicit question asked by a speaker, or it may not and instead be a standalone statement.\n    A requirement for qualification as important information of a next question-answer pair is that it is not included in the verbatim_answer property of the provided previous question answer pair.\n     \n    Identify the speakers for both questions and answers. Speakers are identified on separate lines of text that precede the speaker dialogue. The speaker lines end in either just a colon, or a timestamp which optionally be followed by a timestamp link. Speaker lines will start with the speaker name, or a surrogate string such as 'Moderator'. The speaker name may be followed by a role provided in parentheses. The role may comprise or contain text that specifies that speaker as an 'Authority Speaker'. See below for the text that specifies Authority Speakers.\n    \n    If important information is provided by a speaker identified as an Authority Speaker (see below), and that important information is not explicitly asked as a question, then you will generate a clarified question that is the best suitable question to be paired with that important information. The important information will be considered the answer. If a statement is made by a Non-Authority Speaker, and that statement is not phrased as a question, then it must be acknowledged by an Authority Speaker with an explicit affirmation response. See property descriptions below for values to use in this case where there is no explicit verbatim question.\n\n    You will extract both the verbatim_answer from the transcript text, and then process the verbatim_answer to create the clarified_answer. The clarified_answer may be similar or perhaps even identical to the verbatim_answer from the transcript text. Typically the clarified answer wil be modified and therefore different at least to some extent from the verbatim_answer, however the clarified_answer must NEVER contradict the corresponding verbatim_answer and must ALWAYS have the same meaning. You will create the clarified versions of the question and answer by removing filler words to improve clarity and readability.\n\n    This specific corpus comprises transcripts of the dialogue from virtual townhall meetings held by the United States Food and Drug Administration (FDA) to help answer technical questions about the development and validation of tests for the virus SARS-CoV2, and the updated policy on COVID-19 diagnostics policy for diagnostics test for coronavirus disease 2019 during the public health emergency caused by the COVID-19 global pandemic.\n\n    Authority Speakers in this FDA Townhall Transcript Corpus are specified by the inclusion of the string ‘FDA’ in the role portion of the speaker line.\n\n    The criteria for qualification for important information to be extracted as question-answer pairs is that the information be technical in nature, procedural, or legal. Information that should not be considered important and excluded from the question-answer extraction process is information related to the orchestration of the call such as which caller or speaker is being selected by the moderator. Information, whether questions by call-in speakers or answers by FDA staff, that is related to whether the FDA authorities can answer the question are considered to be legal and always to be included. These typical include answers from the FDA Authority Speakers similar to ‘we are not able to respond to questions about specific submissions that might be under review’. If you are not sure whether information qualifies as important information, then includeit and set the review_flag property of the response to True.\n    ")), Assign(targets=[Name(id='FCALL_SYSTEM_PROMPT_QA_INCREMENTAL_TRANSCTIPRT_FDA_TOWNHALLS', ctx=Store())], value=Constant(value="\nYou are an expert text analyzer trained in identifying questions and answers in transcripts of dialogue, specifically for FDA Town Hall meetings on COVID-19 diagnostics. Your role is to extract and clarify the next question-answer pair from the given transcript chunk, while also precisely identifying its location within the text.\n\nYour task:\n1. Identify the next question or important information after the provided previous question-answer pair, even if there is overlap between the corresponding transcript text. The next question and answer may be related to but should be distinct from the previous question and answer.\n2. Extract both verbatim and clarified versions of questions and answers, excluding speaker lines and newline characters.\n3. Identify speakers and their roles for questions and answers separately.\n4. Generate clarified questions for important statements from Authority Speakers if not explicitly asked as questions.\n5. Focus on technical, procedural, or legal information.\n6. Include information about FDA's ability to answer questions.\n7. Exclude call orchestration details involving starting the meeting, openning for questions, connection problems, speaker order, and meeting feedback surveys.\n8. Precisely identify the start and end positions of the verbatim text from the transcript that corresponds to the clairified question-answer pair.\n\nKey points:\n- Important information must not be included in the previous answer.\n- Speakers are identified by lines ending with a colon or timestamp.\n- Authority Speakers are indicated by 'FDA' in their role description.\n- Clarified versions should improve readability without changing meaning.\n- Non-Authority Speaker statements must be acknowledged by Authority Speakers to be included.\n- If unsure about information importance, include it and set the review flag to True.\n- Accurately report the relative character positions (start and end) of the input transcript text that the extracted question-answer pair correspond to.\n- All extracted text (verbatim and clarified) should be on a single line without newline characters or speaker identifications.\n\nThe precise identification of question-answer pair positions is crucial for the incremental extraction process. It allows for:\n- Accurate progression through the transcript without missing or duplicating content.\n- Identification of the next chunk to be processed based on the end position of the current pair.\n- Thorough extraction of all important question-answer pairs from the original transcript.\n\nThis incremental approach ensures comprehensive coverage of the transcript while maintaining context and continuity throughout the extraction process. Your accurate identification of text positions is essential for the seamless progression of this extraction method.\n\nThis process is crucial for organizing and clarifying important information from FDA Town Hall meetings on COVID-19 diagnostics, ensuring accurate and accessible information dissemination while maintaining the transcript's integrity and completeness.\n")), FunctionDef(name='tools_qa_incremental', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=List(elts=[Dict(keys=[Constant(value='type'), Constant(value='function')], values=[Constant(value='function'), Dict(keys=[Constant(value='name'), Constant(value='description'), Constant(value='parameters')], values=[Constant(value='extract_qa'), Constant(value='Extract and clarify the next question-answer pair from an FDA Town Hall transcript chunk'), Dict(keys=[Constant(value='type'), Constant(value='properties'), Constant(value='required')], values=[Constant(value='object'), Dict(keys=[Constant(value='clarified_question'), Constant(value='clarified_answer'), Constant(value='verbatim_question'), Constant(value='verbatim_answer'), Constant(value='speaker_question'), Constant(value='speaker_answer'), Constant(value='relative_start_position'), Constant(value='relative_end_position'), Constant(value='topics'), Constant(value='review_flag')], values=[Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='string'), Constant(value='A clear, concise version of the next question given the context of the provided previous question and answer block, even if this next question overlaps with the previous answer. Remove filler words and improving readability of the question. If no explicit question is asked in the entirity of the transcrtipt text provided, analyze the text to determine if important information provided by an Authority Speaker. If so, then generate an appropriate question based on the important information. The entire text of this next question should be on a single line.')]), Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='string'), Constant(value='A clear, concise version of the answer to the next question, removing filler words and improving readability. Must maintain the same meaning as the verbatim answer but may rephrase for clarity. The entire text of this answer should be on a single line.')]), Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='string'), Constant(value="The exact text corresponding to the next question as it appears in the transcript, excluding the speaker line and any newline characters. If no explicit question is asked, use the string 'IMPLIED QUESTION'. The entire text should be on a single line.")]), Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='string'), Constant(value='The exact answer as it appears in the transcript, including any filler words or hesitations, but excluding the speaker line and any newline characters. The entire text should be on a single line.')]), Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='string'), Constant(value="The name or role of the person asking the question, as identified in the transcript by the text in the speaker line that precedes a colon or timestamp. Do not use a different name spelling that may appear in the speaker dialogue. If the question is implied from an Authority Speaker's statement, use 'NONE'.")]), Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='string'), Constant(value='The name and role of the person providing the answer, as identified in the transcript by the text in the speaker line that precedes a colon or timestamp. Do not use a different name spelling that may appear in the speaker dialogue.')]), Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='integer'), Constant(value='The character position in the transcript chunk where the verbatim_question begins, relative to the start of the chunk.')]), Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='integer'), Constant(value='The character position in the transcript chunk where the verbatim_answer ends, relative to the start of the chunk.')]), Dict(keys=[Constant(value='type'), Constant(value='items'), Constant(value='description')], values=[Constant(value='array'), Dict(keys=[Constant(value='type')], values=[Constant(value='string')]), Constant(value='A list of 1-3 key topics addressed in the question-answer pair, focusing on technical, procedural, or legal aspects of COVID-19 diagnostics.')]), Dict(keys=[Constant(value='type'), Constant(value='description')], values=[Constant(value='boolean'), Constant(value="Set to True if there's any uncertainty about the importance or relevance of the extracted information, or if the content requires additional review. Otherwise, set to False.")])]), List(elts=[Constant(value='clarified_question'), Constant(value='clarified_answer'), Constant(value='verbatim_question'), Constant(value='verbatim_answer'), Constant(value='speaker_question'), Constant(value='speaker_answer'), Constant(value='relative_end_position'), Constant(value='topics'), Constant(value='review_flag')], ctx=Load())])])])], ctx=Load()))], decorator_list=[]), FunctionDef(name='get_next_chunk', args=arguments(posonlyargs=[], args=[arg(arg='transcript'), arg(arg='start_position'), arg(arg='next_tokens')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Get the next chunk of transcript to process, based on the algorithm specification.\n    \n    :param transcript: Complete transcript text.\n    :param start_position: Starting character position in the transcript.\n    :param next_tokens: Number of tokens to look ahead.\n    :return: Tuple of (chunk_text, end_position).\n    ')), Assign(targets=[Name(id='chars_per_token', ctx=Store())], value=Constant(value=4)), Assign(targets=[Name(id='look_ahead_chars', ctx=Store())], value=BinOp(left=Name(id='next_tokens', ctx=Load()), op=Mult(), right=Name(id='chars_per_token', ctx=Load()))), Assign(targets=[Name(id='end_position', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[BinOp(left=Name(id='start_position', ctx=Load()), op=Add(), right=Name(id='look_ahead_chars', ctx=Load())), Call(func=Name(id='len', ctx=Load()), args=[Name(id='transcript', ctx=Load())], keywords=[])], keywords=[])), While(test=BoolOp(op=And(), values=[Compare(left=Name(id='end_position', ctx=Load()), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='transcript', ctx=Load())], keywords=[])]), Compare(left=Subscript(value=Name(id='transcript', ctx=Load()), slice=Name(id='end_position', ctx=Load()), ctx=Load()), ops=[NotEq()], comparators=[Constant(value='\n')])]), body=[AugAssign(target=Name(id='end_position', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[]), Assign(targets=[Name(id='chunk_text', ctx=Store())], value=Subscript(value=Name(id='transcript', ctx=Load()), slice=Slice(lower=Name(id='start_position', ctx=Load()), upper=Name(id='end_position', ctx=Load())), ctx=Load())), Return(value=Tuple(elts=[Name(id='chunk_text', ctx=Load()), Name(id='end_position', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='get_last_qa_block_start_position', args=arguments(posonlyargs=[], args=[arg(arg='qa_file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Read the last processed start position from the existing QA file.\n    \n    :param qa_file_path: String of the path to the QA file.\n    :return: Integer of the transcript start position, or 0 if not found.\n    ')), Try(body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='qa_file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='f', ctx=Store()))], body=[Assign(targets=[Name(id='content', ctx=Store())], value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='field_identifier', ctx=Store())], value=Constant(value='TRANSCRIPT START POSITION: ')), Assign(targets=[Name(id='last_transcript_start_position', ctx=Store())], value=Call(func=Attribute(value=Name(id='content', ctx=Load()), attr='rfind', ctx=Load()), args=[Name(id='field_identifier', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='last_transcript_start_position', ctx=Load()), ops=[NotEq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=[Assign(targets=[Name(id='end_of_line', ctx=Store())], value=Call(func=Attribute(value=Name(id='content', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value='\n'), Name(id='last_transcript_start_position', ctx=Load())], keywords=[])), Assign(targets=[Name(id='position_str', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='content', ctx=Load()), slice=Slice(lower=BinOp(left=Name(id='last_transcript_start_position', ctx=Load()), op=Add(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='field_identifier', ctx=Load())], keywords=[])), upper=Name(id='end_of_line', ctx=Load())), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='position_str', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value=','), Constant(value='')], keywords=[])], keywords=[]))], orelse=[])])], handlers=[ExceptHandler(type=Name(id='FileNotFoundError', ctx=Load()), body=[Pass()])], orelse=[], finalbody=[]), Return(value=Constant(value=0))], decorator_list=[]), FunctionDef(name='fcall_qa_incremental', args=arguments(posonlyargs=[], args=[arg(arg='transcript'), arg(arg='next_tokens'), arg(arg='fcall_prompt'), arg(arg='start_position')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Processes a transcript string incrementally to extract the next question-answer pair using OpenAI function calling.\n    This function yields each QA block along with the current position in the transcript, allowing for incremental processing and resumption from the last processed position.  \n\n    :param transcript: String of the transcript content.\n    :param next_tokens: Integer of the number of tokens to look ahead.\n    :param fcall_prompt: String of the prompt to be used for function calling.\n    :param start_position: Integer of the starting position in the transcript.\n    :yield: Tuple of (qa_block, current_position) or (None, current_position) if an error occurred.\n    ')), Assign(targets=[Name(id='current_position', ctx=Store())], value=Name(id='start_position', ctx=Load())), Assign(targets=[Name(id='previous_block', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='total_chars_transcript', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='transcript', ctx=Load())], keywords=[])), While(test=Compare(left=Name(id='current_position', ctx=Load()), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='transcript', ctx=Load())], keywords=[])]), body=[Assign(targets=[Tuple(elts=[Name(id='chunk', ctx=Store()), Name(id='next_position', ctx=Store())], ctx=Store())], value=Call(func=Name(id='get_next_chunk', ctx=Load()), args=[Name(id='transcript', ctx=Load()), Name(id='current_position', ctx=Load()), Name(id='next_tokens', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='chunk transcript positions:        '), FormattedValue(value=Name(id='current_position', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value=',')])), Constant(value=' to '), FormattedValue(value=Name(id='next_position', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value=',')])), Constant(value=' of total: '), FormattedValue(value=Name(id='total_chars_transcript', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value=',')])), Constant(value=' | Percent done: '), FormattedValue(value=Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='current_position', ctx=Load()), op=Div(), right=Name(id='total_chars_transcript', ctx=Load())), op=Mult(), right=Constant(value=100))], keywords=[]), conversion=-1), Constant(value='%')])], keywords=[])), Assign(targets=[Name(id='prev_block_prompt', ctx=Store())], value=IfExp(test=UnaryOp(op=Not(), operand=Name(id='previous_block', ctx=Load())), body=Constant(value='Please identify the first question-answer pair in the following transcript chunk:'), orelse=JoinedStr(values=[Constant(value='\n        Previous Question-Answer Block:\n        '), FormattedValue(value=Name(id='previous_block', ctx=Load()), conversion=-1), Constant(value='\n        Please identify the next question-answer pair after this one in the following transcript chunk:\n        ')]))), Assign(targets=[Name(id='full_prompt', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Name(id='fcall_prompt', ctx=Load()), op=Add(), right=Constant(value='\n')), op=Add(), right=Name(id='prev_block_prompt', ctx=Load())), op=Add(), right=Constant(value='\n\n')), op=Add(), right=Name(id='chunk', ctx=Load()))), Try(body=[Assign(targets=[Name(id='qa_response', ctx=Store())], value=Call(func=Name(id='openai_function_call', ctx=Load()), args=[Name(id='full_prompt', ctx=Load()), Name(id='chunk', ctx=Load()), Call(func=Name(id='tools_qa_incremental', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='arguments', ctx=Store())], value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='loads', ctx=Load()), args=[Subscript(value=Subscript(value=Subscript(value=Subscript(value=Name(id='qa_response', ctx=Load()), slice=Constant(value='tool_calls'), ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Constant(value='function'), ctx=Load()), slice=Constant(value='arguments'), ctx=Load())], keywords=[])), Assign(targets=[Name(id='qa_block', ctx=Store())], value=JoinedStr(values=[Constant(value='CLARIFIED QUESTION: '), FormattedValue(value=Subscript(value=Name(id='arguments', ctx=Load()), slice=Constant(value='clarified_question'), ctx=Load()), conversion=-1), Constant(value='\n')])), AugAssign(target=Name(id='qa_block', ctx=Store()), op=Add(), value=JoinedStr(values=[Constant(value='CLARIFIED ANSWER: '), FormattedValue(value=Subscript(value=Name(id='arguments', ctx=Load()), slice=Constant(value='clarified_answer'), ctx=Load()), conversion=-1), Constant(value='\n')])), AugAssign(target=Name(id='qa_block', ctx=Store()), op=Add(), value=JoinedStr(values=[Constant(value='VERBATIM QUESTION: '), FormattedValue(value=Subscript(value=Name(id='arguments', ctx=Load()), slice=Constant(value='verbatim_question'), ctx=Load()), conversion=-1), Constant(value='\n')])), AugAssign(target=Name(id='qa_block', ctx=Store()), op=Add(), value=JoinedStr(values=[Constant(value='VERBATIM ANSWER: '), FormattedValue(value=Subscript(value=Name(id='arguments', ctx=Load()), slice=Constant(value='verbatim_answer'), ctx=Load()), conversion=-1), Constant(value='\n')])), AugAssign(target=Name(id='qa_block', ctx=Store()), op=Add(), value=JoinedStr(values=[Constant(value='SPEAKER QUESTION: '), FormattedValue(value=Subscript(value=Name(id='arguments', ctx=Load()), slice=Constant(value='speaker_question'), ctx=Load()), conversion=-1), Constant(value='\n')])), AugAssign(target=Name(id='qa_block', ctx=Store()), op=Add(), value=JoinedStr(values=[Constant(value='SPEAKER ANSWER: '), FormattedValue(value=Subscript(value=Name(id='arguments', ctx=Load()), slice=Constant(value='speaker_answer'), ctx=Load()), conversion=-1), Constant(value='\n')])), Assign(targets=[Name(id='abs_transcript_start_pos', ctx=Store())], value=BinOp(left=Name(id='current_position', ctx=Load()), op=Add(), right=Subscript(value=Name(id='arguments', ctx=Load()), slice=Constant(value='relative_start_position'), ctx=Load()))), Assign(targets=[Name(id='abs_transcript_end_pos', ctx=Store())], value=BinOp(left=Name(id='current_position', ctx=Load()), op=Add(), right=Subscript(value=Name(id='arguments', ctx=Load()), slice=Constant(value='relative_end_position'), ctx=Load()))), AugAssign(target=Name(id='qa_block', ctx=Store()), op=Add(), value=JoinedStr(values=[Constant(value='TRANSCRIPT START POSITION: '), FormattedValue(value=Name(id='abs_transcript_start_pos', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value=',')])), Constant(value='\n')])), AugAssign(target=Name(id='qa_block', ctx=Store()), op=Add(), value=JoinedStr(values=[Constant(value='TRANSCRIPT END POSITION: '), FormattedValue(value=Name(id='abs_transcript_end_pos', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value=',')])), Constant(value='\n')])), AugAssign(target=Name(id='qa_block', ctx=Store()), op=Add(), value=JoinedStr(values=[Constant(value='TOPICS: '), FormattedValue(value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Subscript(value=Name(id='arguments', ctx=Load()), slice=Constant(value='topics'), ctx=Load())], keywords=[]), conversion=-1), Constant(value='\n')])), AugAssign(target=Name(id='qa_block', ctx=Store()), op=Add(), value=JoinedStr(values=[Constant(value='REVIEW FLAG: '), FormattedValue(value=Subscript(value=Name(id='arguments', ctx=Load()), slice=Constant(value='review_flag'), ctx=Load()), conversion=-1), Constant(value='\n\n')])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='qa response transcript position: '), FormattedValue(value=Name(id='abs_transcript_start_pos', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value=',')])), Constant(value=' to '), FormattedValue(value=Name(id='abs_transcript_end_pos', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value=',')]))])], keywords=[])), Assign(targets=[Name(id='previous_block', ctx=Store())], value=Name(id='qa_block', ctx=Load())), Expr(value=Yield(value=Tuple(elts=[Name(id='qa_block', ctx=Load()), Name(id='abs_transcript_start_pos', ctx=Load())], ctx=Load())))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Error in qa extraction: '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[])), Expr(value=Yield(value=Tuple(elts=[Constant(value=None), Name(id='current_position', ctx=Load())], ctx=Load())))])], orelse=[], finalbody=[]), Assign(targets=[Name(id='current_position', ctx=Store())], value=Name(id='abs_transcript_start_pos', ctx=Load()))], orelse=[])], decorator_list=[]), FunctionDef(name='create_qa_file_from_transcript_incremental', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='fcall_prompt')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Manages the incremental extraction of question-answer pairs from a transcript file.\n    This function handles the overall process, including reading the transcript, determining the next chunk to process, and appending the extracted QA blocks to a new file.\n\n    :param file_path: String of the path to the transcript file to be processed.\n    :param fcall_prompt: String of the prompt to be used for function calling.\n    :return: String of the path to the newly created QA file.\n    ')), ImportFrom(module='primary.structured', names=[alias(name='count_blocks')], level=0), Assign(targets=[Tuple(elts=[Name(id='metadata', ctx=Store()), Name(id='content', ctx=Store())], ctx=Store())], value=Call(func=Name(id='read_metadata_and_content', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Name(id='set_last_updated', ctx=Load()), args=[Name(id='metadata', ctx=Load()), Constant(value='Created QA Incremental')], keywords=[])), Assign(targets=[Name(id='metadata', ctx=Store())], value=Call(func=Name(id='set_metadata_field', ctx=Load()), args=[Name(id='metadata', ctx=Load()), Constant(value='source file'), Name(id='file_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[BinOp(left=Constant(value='OPENAI_MODEL = '), op=Add(), right=Name(id='OPENAI_MODEL', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='segment_tokens', ctx=Store())], value=Call(func=Name(id='count_segment_tokens', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_segment_tokens', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Name(id='segment_tokens', ctx=Load())], keywords=[])), Assign(targets=[Name(id='transcript', ctx=Store())], value=Call(func=Name(id='get_heading', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='### transcript')], keywords=[])), Assign(targets=[Name(id='transcript', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='transcript', ctx=Load()), attr='lstrip', ctx=Load()), args=[Constant(value='### transcript')], keywords=[]), attr='rstrip', ctx=Load()), args=[Constant(value='\n')], keywords=[]), attr='lstrip', ctx=Load()), args=[Constant(value='\n*')], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Number of characters in transcript: '), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='transcript', ctx=Load())], keywords=[]), conversion=-1, format_spec=JoinedStr(values=[Constant(value=',')])), Constant(value='\n')])], keywords=[])), Assign(targets=[Name(id='initial_content', ctx=Store())], value=Constant(value='## content\n\n### qa\n')), Assign(targets=[Name(id='qa_file_path', ctx=Store())], value=Call(func=Name(id='write_metadata_and_content', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='metadata', ctx=Load()), Name(id='initial_content', ctx=Load())], keywords=[keyword(arg='overwrite', value=Constant(value='no-sub')), keyword(arg='suffix_new', value=Constant(value='_qa-incremental'))])), Assign(targets=[Name(id='current_position', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='max_retries', ctx=Store())], value=Constant(value=5)), While(test=Compare(left=Name(id='current_position', ctx=Load()), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='transcript', ctx=Load())], keywords=[])]), body=[Assign(targets=[Name(id='existing_blocks', ctx=Store())], value=Call(func=Name(id='count_blocks', ctx=Load()), args=[Name(id='qa_file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='block_number', ctx=Store())], value=BinOp(left=Name(id='existing_blocks', ctx=Load()), op=Add(), right=Constant(value=1))), For(target=Tuple(elts=[Name(id='qa_block', ctx=Store()), Name(id='abs_transcript_start_pos', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='fcall_qa_incremental', ctx=Load()), args=[Name(id='transcript', ctx=Load()), Name(id='max_segment_tokens', ctx=Load()), Name(id='fcall_prompt', ctx=Load())], keywords=[keyword(arg='start_position', value=Name(id='current_position', ctx=Load()))]), body=[Assign(targets=[Name(id='retry_count', ctx=Store())], value=Constant(value=0)), While(test=Compare(left=Name(id='retry_count', ctx=Load()), ops=[Lt()], comparators=[Name(id='max_retries', ctx=Load())]), body=[Try(body=[If(test=Compare(left=Name(id='qa_block', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='Exception', ctx=Load()), args=[JoinedStr(values=[Constant(value='Error occurred on block '), FormattedValue(value=Name(id='block_number', ctx=Load()), conversion=-1), Constant(value='.')])], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='writing block number '), FormattedValue(value=Name(id='block_number', ctx=Load()), conversion=-1), Constant(value='\n')])], keywords=[])), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='qa_file_path', ctx=Load()), Constant(value='a')], keywords=[]), optional_vars=Name(id='f', ctx=Store()))], body=[Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[Name(id='qa_block', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='current_position', ctx=Store())], value=Name(id='abs_transcript_start_pos', ctx=Load())), AugAssign(target=Name(id='block_number', ctx=Store()), op=Add(), value=Constant(value=1)), Break()], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[AugAssign(target=Name(id='retry_count', ctx=Store()), op=Add(), value=Constant(value=1)), If(test=Compare(left=Name(id='retry_count', ctx=Load()), ops=[GtE()], comparators=[Name(id='max_retries', ctx=Load())]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='\n********** Max retries ('), FormattedValue(value=Name(id='max_retries', ctx=Load()), conversion=-1), Constant(value=') reached for block '), FormattedValue(value=Name(id='block_number', ctx=Load()), conversion=-1), Constant(value='. Skipping this block.')])], keywords=[])), AugAssign(target=Name(id='current_position', ctx=Store()), op=Add(), value=Name(id='max_segment_tokens', ctx=Load()))], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='\n********** Error encountered: '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Retry attempt '), FormattedValue(value=Name(id='retry_count', ctx=Load()), conversion=-1), Constant(value=' of '), FormattedValue(value=Name(id='max_retries', ctx=Load()), conversion=-1)])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Retrying the same block.')], keywords=[]))])])], orelse=[], finalbody=[])], orelse=[]), If(test=Compare(left=Name(id='retry_count', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Block processed successfully.')], keywords=[]))], orelse=[If(test=Compare(left=Name(id='retry_count', ctx=Load()), ops=[Lt()], comparators=[Name(id='max_retries', ctx=Load())]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Block processed after retries.')], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Block skipped due to repeated errors.')], keywords=[]))])])], orelse=[])], orelse=[]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='QA extraction completed.')], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[BinOp(left=Constant(value='QA written to '), op=Add(), right=Name(id='qa_file_path', ctx=Load()))], keywords=[])), Return(value=Name(id='qa_file_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='validate_qa_transcript_positions', args=arguments(posonlyargs=[], args=[arg(arg='transcript'), arg(arg='qa_dict')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Validate the extracted QA block against the original transcript based on reported positions.\n    \n    :param transcript: String of the full transcript text.\n    :param qa_dict: Dictionary containing the extracted QA information.\n    :return: Tuple of (bool, str) indicating pass/fail and a mismatch description if applicable.\n    ')), Assign(targets=[Name(id='start_pos', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Subscript(value=Name(id='qa_dict', ctx=Load()), slice=Constant(value='TRANSCRIPT START POSITION'), ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value=','), Constant(value='')], keywords=[])], keywords=[])), Assign(targets=[Name(id='end_pos', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Subscript(value=Name(id='qa_dict', ctx=Load()), slice=Constant(value='TRANSCRIPT END POSITION'), ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value=','), Constant(value='')], keywords=[])], keywords=[])), Assign(targets=[Name(id='original_text', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='transcript', ctx=Load()), slice=Slice(lower=Name(id='start_pos', ctx=Load()), upper=Name(id='end_pos', ctx=Load())), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='extracted_text', ctx=Store())], value=Call(func=Attribute(value=BinOp(left=BinOp(left=Subscript(value=Name(id='qa_dict', ctx=Load()), slice=Constant(value='VERBATIM QUESTION'), ctx=Load()), op=Add(), right=Constant(value=' ')), op=Add(), right=Subscript(value=Name(id='qa_dict', ctx=Load()), slice=Constant(value='VERBATIM ANSWER'), ctx=Load())), attr='strip', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='original_text', ctx=Store())], value=Call(func=Attribute(value=Constant(value=' '), attr='join', ctx=Load()), args=[Call(func=Attribute(value=Name(id='original_text', ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='extracted_text', ctx=Store())], value=Call(func=Attribute(value=Constant(value=' '), attr='join', ctx=Load()), args=[Call(func=Attribute(value=Name(id='extracted_text', ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Name(id='original_text', ctx=Load()), ops=[Eq()], comparators=[Name(id='extracted_text', ctx=Load())]), body=[Return(value=Tuple(elts=[Constant(value=True), Constant(value='')], ctx=Load()))], orelse=[Return(value=Tuple(elts=[Constant(value=False), JoinedStr(values=[Constant(value="Mismatch between original and extracted text.\n    ORIGINAL TRANSCRIPT: '"), FormattedValue(value=Name(id='original_text', ctx=Load()), conversion=-1), Constant(value="'\n    EXTRACTED VERBATIM: '"), FormattedValue(value=Name(id='extracted_text', ctx=Load()), conversion=-1), Constant(value="'")])], ctx=Load()))])], decorator_list=[]), FunctionDef(name='evaluate_qa_extraction', args=arguments(posonlyargs=[], args=[arg(arg='transcript'), arg(arg='qa_file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Evaluate the QA extraction process using LLM-based checks and position validation.\n    \n    :param transcript: String of the full transcript text.\n    :param qa_file_path: String path to the file containing extracted QA blocks.\n    :return: List of dictionaries containing evaluation results for each QA block.\n    ')), ImportFrom(module='primary.structured', names=[alias(name='get_all_fields_dict')], level=0), Assign(targets=[Tuple(elts=[Name(id='_', ctx=Store()), Name(id='qa_content', ctx=Store())], ctx=Store())], value=Call(func=Name(id='read_metadata_and_content', ctx=Load()), args=[Name(id='qa_file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='qa_blocks', ctx=Store())], value=ListComp(elt=Name(id='block', ctx=Load()), generators=[comprehension(target=Name(id='block', ctx=Store()), iter=Call(func=Attribute(value=Name(id='qa_content', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n\n')], keywords=[]), ifs=[BoolOp(op=And(), values=[Call(func=Attribute(value=Name(id='block', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), UnaryOp(op=Not(), operand=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='block', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), attr='startswith', ctx=Load()), args=[Constant(value='#')], keywords=[]))])], is_async=0)])), Assign(targets=[Name(id='evaluation_results', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='num_blocks', ctx=Store())], value=Call(func=Name(id='count_blocks', ctx=Load()), args=[Name(id='qa_file_path', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='block', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='qa_blocks', ctx=Load())], keywords=[keyword(arg='start', value=Constant(value=1))]), body=[Assign(targets=[Name(id='qa_dict', ctx=Store())], value=Call(func=Name(id='get_all_fields_dict', ctx=Load()), args=[Name(id='block', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='position_valid', ctx=Store()), Name(id='mismatch_description', ctx=Store())], ctx=Store())], value=Call(func=Name(id='validate_qa_transcript_positions', ctx=Load()), args=[Name(id='transcript', ctx=Load()), Name(id='qa_dict', ctx=Load())], keywords=[])), Assign(targets=[Name(id='eval_prompt', ctx=Store())], value=JoinedStr(values=[Constant(value='\n        Evaluate the following question-answer pair extracted from an FDA Town Hall transcript:\n        \n        Verbatim Question: '), FormattedValue(value=Subscript(value=Name(id='qa_dict', ctx=Load()), slice=Constant(value='VERBATIM QUESTION'), ctx=Load()), conversion=-1), Constant(value='\n        Verbatim Answer: '), FormattedValue(value=Subscript(value=Name(id='qa_dict', ctx=Load()), slice=Constant(value='VERBATIM ANSWER'), ctx=Load()), conversion=-1), Constant(value='\n        Clarified Question: '), FormattedValue(value=Subscript(value=Name(id='qa_dict', ctx=Load()), slice=Constant(value='CLARIFIED QUESTION'), ctx=Load()), conversion=-1), Constant(value='\n        Clarified Answer: '), FormattedValue(value=Subscript(value=Name(id='qa_dict', ctx=Load()), slice=Constant(value='CLARIFIED ANSWER'), ctx=Load()), conversion=-1), Constant(value='\n        \n        Please evaluate based on the following criteria:\n        1. Accuracy (0-5 scale): How well does the extracted information match the content and intent of the original transcript?\n        2. Formatting (Pass/Fail): Are all texts on a single line without newline characters or speaker identifications?\n        3. Topic Relevance (Pass/Fail): Do the extracted topics align with the content of the Q&A pair?\n        \n        Provide your evaluation in JSON format with the following structure:\n        {\n            "accuracy_score": int,\n            "formatting": "Pass" or "Fail",\n            "topic_relevance": "Pass" or "Fail",\n            "comments": "Any additional comments or explanations"\n        }\n        ')])), Assign(targets=[Name(id='messages', ctx=Store())], value=List(elts=[Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='system'), Constant(value='You are an expert evaluator of text extraction quality.')]), Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='user'), Name(id='eval_prompt', ctx=Load())])], ctx=Load())), Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Name(id='openai_chat_completion_request', ctx=Load()), args=[Name(id='messages', ctx=Load())], keywords=[keyword(arg='model', value=Name(id='OPENAI_MODEL', ctx=Load()))])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='response', ctx=Load()), Name(id='Exception', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Error in LLM call: '), FormattedValue(value=Name(id='response', ctx=Load()), conversion=-1)])], keywords=[])), Continue()], orelse=[]), Try(body=[Assign(targets=[Name(id='llm_evaluation', ctx=Store())], value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='loads', ctx=Load()), args=[Subscript(value=Subscript(value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='response', ctx=Load()), attr='json', ctx=Load()), args=[], keywords=[]), slice=Constant(value='choices'), ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Constant(value='message'), ctx=Load()), slice=Constant(value='content'), ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Attribute(value=Name(id='json', ctx=Load()), attr='JSONDecodeError', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Error: Unable to parse JSON from LLM response')], keywords=[])), Continue()]), ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Error: Unexpected response structure from LLM')], keywords=[])), Continue()])], orelse=[], finalbody=[]), Assign(targets=[Name(id='evaluation_result', ctx=Store())], value=Dict(keys=[Constant(value='accuracy_score'), Constant(value='formatting'), Constant(value='topic_relevance'), Constant(value='position_validation'), Constant(value='mismatch_description'), Constant(value='llm_comments')], values=[Subscript(value=Name(id='llm_evaluation', ctx=Load()), slice=Constant(value='accuracy_score'), ctx=Load()), Subscript(value=Name(id='llm_evaluation', ctx=Load()), slice=Constant(value='formatting'), ctx=Load()), Subscript(value=Name(id='llm_evaluation', ctx=Load()), slice=Constant(value='topic_relevance'), ctx=Load()), IfExp(test=Name(id='position_valid', ctx=Load()), body=Constant(value='Pass'), orelse=Constant(value='Fail')), Name(id='mismatch_description', ctx=Load()), Subscript(value=Name(id='llm_evaluation', ctx=Load()), slice=Constant(value='comments'), ctx=Load())])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='\nAuto Evaluation of block '), FormattedValue(value=Name(id='i', ctx=Load()), conversion=-1), Constant(value=' of '), FormattedValue(value=Name(id='num_blocks', ctx=Load()), conversion=-1)])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='CLARIFIED QUESTION: '), FormattedValue(value=Subscript(value=Name(id='qa_dict', ctx=Load()), slice=Constant(value='CLARIFIED QUESTION'), ctx=Load()), conversion=-1)])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='evaluation_result', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='evaluation_results', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='evaluation_result', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='evaluation_results', ctx=Load()))], decorator_list=[]), FunctionDef(name='generate_evaluation_report', args=arguments(posonlyargs=[], args=[arg(arg='evaluation_results'), arg(arg='output_file')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Generate a readable report from the evaluation results.\n    \n    :param evaluation_results: List of dictionaries containing evaluation results.\n    :param output_file: String path to write the report.\n    ')), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='output_file', ctx=Load()), Constant(value='w')], keywords=[]), optional_vars=Name(id='f', ctx=Store()))], body=[Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[Constant(value='# QA Extraction Auto Evaluation Report\n\n\n')], keywords=[])), Assign(targets=[Name(id='avg_accuracy', ctx=Store())], value=BinOp(left=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Subscript(value=Name(id='r', ctx=Load()), slice=Constant(value='accuracy_score'), ctx=Load()), generators=[comprehension(target=Name(id='r', ctx=Store()), iter=Name(id='evaluation_results', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), op=Div(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='evaluation_results', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='formatting_pass', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Constant(value=1), generators=[comprehension(target=Name(id='r', ctx=Store()), iter=Name(id='evaluation_results', ctx=Load()), ifs=[Compare(left=Subscript(value=Name(id='r', ctx=Load()), slice=Constant(value='formatting'), ctx=Load()), ops=[Eq()], comparators=[Constant(value='Pass')])], is_async=0)])], keywords=[])), Assign(targets=[Name(id='topic_relevance_pass', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Constant(value=1), generators=[comprehension(target=Name(id='r', ctx=Store()), iter=Name(id='evaluation_results', ctx=Load()), ifs=[Compare(left=Subscript(value=Name(id='r', ctx=Load()), slice=Constant(value='topic_relevance'), ctx=Load()), ops=[Eq()], comparators=[Constant(value='Pass')])], is_async=0)])], keywords=[])), Assign(targets=[Name(id='position_validation_pass', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Constant(value=1), generators=[comprehension(target=Name(id='r', ctx=Store()), iter=Name(id='evaluation_results', ctx=Load()), ifs=[Compare(left=Subscript(value=Name(id='r', ctx=Load()), slice=Constant(value='position_validation'), ctx=Load()), ops=[Eq()], comparators=[Constant(value='Pass')])], is_async=0)])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[Constant(value='## Summary Statistics:\n')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[JoinedStr(values=[Constant(value='Average Accuracy Score: '), FormattedValue(value=Name(id='avg_accuracy', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.2f')])), Constant(value='/5\n')])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[JoinedStr(values=[Constant(value='Formatting Pass Rate: '), FormattedValue(value=Name(id='formatting_pass', ctx=Load()), conversion=-1), Constant(value='/'), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='evaluation_results', ctx=Load())], keywords=[]), conversion=-1), Constant(value='\n')])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[JoinedStr(values=[Constant(value='Topic Relevance Pass Rate: '), FormattedValue(value=Name(id='topic_relevance_pass', ctx=Load()), conversion=-1), Constant(value='/'), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='evaluation_results', ctx=Load())], keywords=[]), conversion=-1), Constant(value='\n')])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[JoinedStr(values=[Constant(value='Position Validation Pass Rate: '), FormattedValue(value=Name(id='position_validation_pass', ctx=Load()), conversion=-1), Constant(value='/'), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='evaluation_results', ctx=Load())], keywords=[]), conversion=-1), Constant(value='\n\n\n')])], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='result', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='evaluation_results', ctx=Load()), Constant(value=1)], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[JoinedStr(values=[Constant(value='## QA Block '), FormattedValue(value=Name(id='i', ctx=Load()), conversion=-1), Constant(value=':\n')])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[JoinedStr(values=[Constant(value='Accuracy Score: '), FormattedValue(value=Subscript(value=Name(id='result', ctx=Load()), slice=Constant(value='accuracy_score'), ctx=Load()), conversion=-1), Constant(value='/5\n')])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[JoinedStr(values=[Constant(value='Formatting: '), FormattedValue(value=Subscript(value=Name(id='result', ctx=Load()), slice=Constant(value='formatting'), ctx=Load()), conversion=-1), Constant(value='\n')])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[JoinedStr(values=[Constant(value='Topic Relevance: '), FormattedValue(value=Subscript(value=Name(id='result', ctx=Load()), slice=Constant(value='topic_relevance'), ctx=Load()), conversion=-1), Constant(value='\n')])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[JoinedStr(values=[Constant(value='Position Validation: '), FormattedValue(value=Subscript(value=Name(id='result', ctx=Load()), slice=Constant(value='position_validation'), ctx=Load()), conversion=-1), Constant(value='\n')])], keywords=[])), If(test=Subscript(value=Name(id='result', ctx=Load()), slice=Constant(value='mismatch_description'), ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[JoinedStr(values=[Constant(value='Mismatch Description: '), FormattedValue(value=Subscript(value=Name(id='result', ctx=Load()), slice=Constant(value='mismatch_description'), ctx=Load()), conversion=-1), Constant(value='\n')])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[JoinedStr(values=[Constant(value='LLM Comments: '), FormattedValue(value=Subscript(value=Name(id='result', ctx=Load()), slice=Constant(value='llm_comments'), ctx=Load()), conversion=-1), Constant(value='\n\n')])], keywords=[]))], orelse=[])])], decorator_list=[]), FunctionDef(name='run_automated_evaluation', args=arguments(posonlyargs=[], args=[arg(arg='transcript_file'), arg(arg='qa_file')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Run the automated evaluation process.\n    \n    :param transcript_file: String path to the original transcript file.\n    :param qa_file: String path to the file containing extracted QA blocks.\n    ')), Assign(targets=[Name(id='transcript', ctx=Store())], value=Call(func=Name(id='get_heading', ctx=Load()), args=[Name(id='transcript_file', ctx=Load()), Constant(value='### transcript')], keywords=[])), Assign(targets=[Name(id='transcript', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='transcript', ctx=Load()), attr='lstrip', ctx=Load()), args=[Constant(value='### transcript')], keywords=[]), attr='rstrip', ctx=Load()), args=[Constant(value='\n')], keywords=[]), attr='lstrip', ctx=Load()), args=[Constant(value='\n*')], keywords=[])), Assign(targets=[Name(id='evaluation_results', ctx=Store())], value=Call(func=Name(id='evaluate_qa_extraction', ctx=Load()), args=[Name(id='transcript', ctx=Load()), Name(id='qa_file', ctx=Load())], keywords=[])), Assign(targets=[Name(id='output_file', ctx=Store())], value=Call(func=Name(id='manage_file_overwrite', ctx=Load()), args=[Name(id='qa_file', ctx=Load()), Constant(value='_autoeval')], keywords=[keyword(arg='overwrite', value=Constant(value='no'))])), Expr(value=Call(func=Name(id='generate_evaluation_report', ctx=Load()), args=[Name(id='evaluation_results', ctx=Load()), Name(id='output_file', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Evaluation completed. Report written to '), FormattedValue(value=Name(id='output_file', ctx=Load()), conversion=-1)])], keywords=[]))], decorator_list=[])], type_ignores=[])

Module(body=[Import(names=[alias(name='os')]), Import(names=[alias(name='json')]), Import(names=[alias(name='zipfile')]), Import(names=[alias(name='shutil')]), Import(names=[alias(name='datetime')]), ImportFrom(module='openai', names=[alias(name='OpenAI')], level=0), ImportFrom(module='pinecone', names=[alias(name='Pinecone'), alias(name='ServerlessSpec')], level=0), ImportFrom(module='langchain_pinecone', names=[alias(name='Pinecone', asname='LangchainPinecone')], level=0), ImportFrom(module='langchain_community.document_loaders', names=[alias(name='ObsidianLoader')], level=0), ImportFrom(module='langchain_openai', names=[alias(name='OpenAIEmbeddings')], level=0), ImportFrom(module='langchain.text_splitter', names=[alias(name='RecursiveCharacterTextSplitter')], level=0), ImportFrom(module='config', names=[alias(name='PINECONE_API_KEY'), alias(name='OPENAI_API_KEY_CONFIG_LLM')], level=0), Assign(targets=[Name(id='client', ctx=Store())], value=Call(func=Name(id='OpenAI', ctx=Load()), args=[], keywords=[keyword(arg='api_key', value=Name(id='OPENAI_API_KEY_CONFIG_LLM', ctx=Load()))])), Assign(targets=[Name(id='VZIP_LOG_FOLDER', ctx=Store())], value=Constant(value='logs/vectordb_pinecone_log_zips/')), Assign(targets=[Name(id='EMBEDDING_MODEL', ctx=Store())], value=Constant(value='text-embedding-3-small')), FunctionDef(name='generate_embedding', args=arguments(posonlyargs=[], args=[arg(arg='text'), arg(arg='model')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='EMBEDDING_MODEL', ctx=Load())]), body=[Expr(value=Constant(value=' \n    Generates an embedding vector for the provided text using the specified OpenAI embeddings model.\n\n    :param text: string of text to generate an embedding for.\n    :param model: string of the OpenAI embeddings model to use.\n    :return: list of floats representing the embedding vector.\n    ')), Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='client', ctx=Load()), attr='embeddings', ctx=Load()), attr='create', ctx=Load()), args=[], keywords=[keyword(arg='input', value=Name(id='text', ctx=Load())), keyword(arg='model', value=Name(id='model', ctx=Load()))])), Assign(targets=[Name(id='embedding', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='response', ctx=Load()), attr='data', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='embedding', ctx=Load())), Return(value=Name(id='embedding', ctx=Load()))], decorator_list=[]), FunctionDef(name='generate_vectors_qa', args=arguments(posonlyargs=[], args=[arg(arg='folder_paths'), arg(arg='suffixpat_include'), arg(arg='include_subfolders')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value=' \n    Generates vectors from markdown files in the specified folder paths.\n\n    :param folder_paths: list of strings of the paths to the folders containing markdown files.\n    :param include_subfolders: boolean indicating whether to search for markdown files in subfolders. Default is True.\n    :return: vectors as a list of dictionaries, each containing an id, values, and metadata for a block of text.\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='get_files_in_folder'), alias(name='get_timestamp')], level=0), ImportFrom(module='primary.structured', names=[alias(name='get_blocks_from_file'), alias(name='get_all_fields_dict')], level=0), Assign(targets=[Name(id='vectors', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='total_files', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='num_vectors', ctx=Store())], value=Constant(value=0)), For(target=Name(id='folder_path', ctx=Store()), iter=Name(id='folder_paths', ctx=Load()), body=[Assign(targets=[Name(id='file_paths', ctx=Store())], value=Call(func=Name(id='get_files_in_folder', ctx=Load()), args=[Name(id='folder_path', ctx=Load())], keywords=[keyword(arg='suffixpat_include', value=Name(id='suffixpat_include', ctx=Load())), keyword(arg='include_subfolders', value=Name(id='include_subfolders', ctx=Load()))])), AugAssign(target=Name(id='total_files', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='file_paths', ctx=Load())], keywords=[])), For(target=Name(id='path', ctx=Store()), iter=Name(id='file_paths', ctx=Load()), body=[Assign(targets=[Name(id='blocks', ctx=Store())], value=Call(func=Name(id='get_blocks_from_file', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='block_num', ctx=Store())], value=Constant(value=0)), For(target=Name(id='block', ctx=Store()), iter=Name(id='blocks', ctx=Load()), body=[Assign(targets=[Name(id='fields', ctx=Store())], value=Call(func=Name(id='get_all_fields_dict', ctx=Load()), args=[Name(id='block', ctx=Load())], keywords=[])), Assign(targets=[Name(id='file_name_with_extension', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='path', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='fields', ctx=Load()), slice=Constant(value='SOURCE'), ctx=Store())], value=Name(id='file_name_with_extension', ctx=Load())), Assign(targets=[Name(id='vector_id', ctx=Store())], value=Call(func=Attribute(value=BinOp(left=BinOp(left=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Name(id='file_name_with_extension', ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load()), op=Add(), right=Constant(value='_')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='block_num', ctx=Load())], keywords=[])), attr='replace', ctx=Load()), args=[Constant(value=' '), Constant(value='_')], keywords=[])), Assign(targets=[Name(id='embedding', ctx=Store())], value=Call(func=Name(id='generate_embedding', ctx=Load()), args=[Subscript(value=Name(id='fields', ctx=Load()), slice=Constant(value='QUESTION'), ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='timestamp', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Name(id='get_timestamp', ctx=Load()), args=[Subscript(value=Name(id='fields', ctx=Load()), slice=Constant(value='QUESTION'), ctx=Load())], keywords=[])), If(test=Name(id='timestamp', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='fields', ctx=Load()), slice=Constant(value='TIMESTAMP'), ctx=Store())], value=Name(id='timestamp', ctx=Load()))], orelse=[]), Assign(targets=[Name(id='vector', ctx=Store())], value=Dict(keys=[Constant(value='id'), Constant(value='values'), Constant(value='metadata')], values=[Name(id='vector_id', ctx=Load()), Name(id='embedding', ctx=Load()), Name(id='fields', ctx=Load())])), Expr(value=Call(func=Attribute(value=Name(id='vectors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])), AugAssign(target=Name(id='num_vectors', ctx=Store()), op=Add(), value=Constant(value=1)), AugAssign(target=Name(id='block_num', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[])], orelse=[])], orelse=[]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Vectors generated for '), FormattedValue(value=Name(id='total_files', ctx=Load()), conversion=-1), Constant(value=' files - number of vectors: '), FormattedValue(value=Name(id='num_vectors', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Name(id='vectors', ctx=Load()))], decorator_list=[]), FunctionDef(name='vectors_to_json', args=arguments(posonlyargs=[], args=[arg(arg='vectors'), arg(arg='file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Converts a list of dictionaries into a JSON file.\n\n    :param vectors: list of dictionaries to be converted.\n    :param file_path: name of the JSON file to be created.\n    :return: None.\n    ')), Try(body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='w')], keywords=[]), optional_vars=Name(id='json_file', ctx=Store()))], body=[Expr(value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='dump', ctx=Load()), args=[Name(id='vectors', ctx=Load()), Name(id='json_file', ctx=Load())], keywords=[keyword(arg='indent', value=Constant(value=4))]))]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Successfully created '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value='.')])], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Error processing '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='json_to_vectors', args=arguments(posonlyargs=[], args=[arg(arg='file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Loads vectors from a JSON file.\n\n    :param file_path: Path to the JSON file containing the vectors.\n    :return: List of vectors loaded from the JSON file. Returns an empty list if an error occurs.\n    ')), Try(body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='json_file', ctx=Store()))], body=[Assign(targets=[Name(id='vectors', ctx=Store())], value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='load', ctx=Load()), args=[Name(id='json_file', ctx=Load())], keywords=[]))]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Successfully loaded '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value='.')])], keywords=[])), Return(value=Name(id='vectors', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Error loading '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=List(elts=[], ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='validate_vectors', args=arguments(posonlyargs=[], args=[arg(arg='vectors'), arg(arg='required_fields'), arg(arg='verbose')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value=' \n    Validates that each vector in the list has the required fields and correct data types.\n\n    :param vectors: list of dictionaries, each representing a vector with an id, values, and metadata.\n    :param required_fields: list of required field names (in uppercase). If None, uses a default set.\n    :param verbose: boolean, if True, prints additional information during validation.\n    :return: None. Raises ValueError if validation fails.\n    ')), If(test=Compare(left=Name(id='required_fields', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='required_fields', ctx=Store())], value=List(elts=[Constant(value='QUESTION'), Constant(value='ANSWER'), Constant(value='QUESTION NAME'), Constant(value='ANSWER NAME'), Constant(value='TOPICS'), Constant(value='STARS'), Constant(value='SOURCE')], ctx=Load()))], orelse=[]), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='vector', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='vectors', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Call(func=Attribute(value=Name(id='vector', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='id')], keywords=[]), Name(id='str', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Vector '), FormattedValue(value=Name(id='i', ctx=Load()), conversion=-1), Constant(value=": Missing or invalid 'id'. It should be a string.")])], keywords=[]))], orelse=[]), If(test=BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Call(func=Attribute(value=Name(id='vector', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='values')], keywords=[]), Name(id='list', ctx=Load())], keywords=[])), UnaryOp(op=Not(), operand=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='v', ctx=Load()), Name(id='float', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='v', ctx=Store()), iter=Call(func=Attribute(value=Name(id='vector', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='values'), List(elts=[], ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[]))]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Vector '), FormattedValue(value=Name(id='i', ctx=Load()), conversion=-1), Constant(value=": Missing or invalid 'values'. It should be a list of floats.")])], keywords=[]))], orelse=[]), If(test=BoolOp(op=Or(), values=[Compare(left=Constant(value='metadata'), ops=[NotIn()], comparators=[Name(id='vector', ctx=Load())]), UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Subscript(value=Name(id='vector', ctx=Load()), slice=Constant(value='metadata'), ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]))]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Vector '), FormattedValue(value=Name(id='i', ctx=Load()), conversion=-1), Constant(value=": Missing or invalid 'metadata'. It should be a dictionary.")])], keywords=[]))], orelse=[]), For(target=Name(id='field', ctx=Store()), iter=Name(id='required_fields', ctx=Load()), body=[If(test=Compare(left=Name(id='field', ctx=Load()), ops=[NotIn()], comparators=[Subscript(value=Name(id='vector', ctx=Load()), slice=Constant(value='metadata'), ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Vector '), FormattedValue(value=Name(id='i', ctx=Load()), conversion=-1), Constant(value=": Missing required field '"), FormattedValue(value=Name(id='field', ctx=Load()), conversion=-1), Constant(value="' in metadata.")])], keywords=[]))], orelse=[])], orelse=[]), If(test=Name(id='verbose', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Validated vector '), FormattedValue(value=Name(id='i', ctx=Load()), conversion=-1), Constant(value=': id='), FormattedValue(value=Subscript(value=Name(id='vector', ctx=Load()), slice=Constant(value='id'), ctx=Load()), conversion=-1), Constant(value=', metadata fields: '), FormattedValue(value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Call(func=Attribute(value=Subscript(value=Name(id='vector', ctx=Load()), slice=Constant(value='metadata'), ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[]), conversion=-1)])], keywords=[]))], orelse=[])], orelse=[]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='All '), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='vectors', ctx=Load())], keywords=[]), conversion=-1), Constant(value=' vectors have required fields and correct format.')])], keywords=[]))], decorator_list=[]), FunctionDef(name='upsert_vectors_pinecone', args=arguments(posonlyargs=[], args=[arg(arg='vectors'), arg(arg='vector_index_name'), arg(arg='new_index')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value=' \n    Upserts vectors into a Pinecone index in batches of 100, creating the index if it does not exist and if new_index is True.\n\n    :param vectors: list of dictionaries, each representing a vector to be upserted.\n    :param vector_index_name: string of the name of the Pinecone index.\n    :param new_index: boolean indicating whether to create a new index if it does not exist. Default is True.\n    :return: None.\n    ')), Assign(targets=[Name(id='pc', ctx=Store())], value=Call(func=Name(id='Pinecone', ctx=Load()), args=[], keywords=[keyword(arg='api_key', value=Name(id='PINECONE_API_KEY', ctx=Load()))])), If(test=Name(id='new_index', ctx=Load()), body=[If(test=Compare(left=Name(id='vector_index_name', ctx=Load()), ops=[NotIn()], comparators=[Call(func=Attribute(value=Call(func=Attribute(value=Name(id='pc', ctx=Load()), attr='list_indexes', ctx=Load()), args=[], keywords=[]), attr='names', ctx=Load()), args=[], keywords=[])]), body=[Expr(value=Call(func=Attribute(value=Name(id='pc', ctx=Load()), attr='create_index', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Name(id='vector_index_name', ctx=Load())), keyword(arg='dimension', value=Constant(value=1536)), keyword(arg='metric', value=Constant(value='cosine')), keyword(arg='spec', value=Call(func=Name(id='ServerlessSpec', ctx=Load()), args=[], keywords=[keyword(arg='cloud', value=Constant(value='aws')), keyword(arg='region', value=Constant(value='us-west-2'))]))]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='index', ctx=Store())], value=Call(func=Attribute(value=Name(id='pc', ctx=Load()), attr='Index', ctx=Load()), args=[Name(id='vector_index_name', ctx=Load())], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Constant(value=0), Call(func=Name(id='len', ctx=Load()), args=[Name(id='vectors', ctx=Load())], keywords=[]), Constant(value=100)], keywords=[]), body=[Assign(targets=[Name(id='batch', ctx=Store())], value=Subscript(value=Name(id='vectors', ctx=Load()), slice=Slice(lower=Name(id='i', ctx=Load()), upper=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=100))), ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='index', ctx=Load()), attr='upsert', ctx=Load()), args=[], keywords=[keyword(arg='vectors', value=Name(id='batch', ctx=Load()))]))], orelse=[])], decorator_list=[]), FunctionDef(name='delete_pinecone_index', args=arguments(posonlyargs=[], args=[arg(arg='vector_index_name'), arg(arg='user_prompt')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='\n    Deletes a Pinecone index if it exists, optionally prompting the user for confirmation.\n\n    :param vector_index_name: string of the name of the Pinecone index to be deleted.\n    :param user_prompt: boolean indicating whether to prompt the user for confirmation before deletion. Default is True.\n    :return: Boolean indicating whether the index was actually deleted.\n    ')), Assign(targets=[Name(id='pc', ctx=Store())], value=Call(func=Name(id='Pinecone', ctx=Load()), args=[], keywords=[keyword(arg='api_key', value=Name(id='PINECONE_API_KEY', ctx=Load()))])), If(test=Compare(left=Name(id='vector_index_name', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Call(func=Attribute(value=Name(id='pc', ctx=Load()), attr='list_indexes', ctx=Load()), args=[], keywords=[]), attr='names', ctx=Load()), args=[], keywords=[])]), body=[If(test=Name(id='user_prompt', ctx=Load()), body=[Assign(targets=[Name(id='user_input', ctx=Store())], value=Call(func=Name(id='input', ctx=Load()), args=[JoinedStr(values=[Constant(value="Vector DB Pinecone Index '"), FormattedValue(value=Name(id='vector_index_name', ctx=Load()), conversion=-1), Constant(value="' already exists. Are you sure you want to delete it? (yes/no): ")])], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='user_input', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[NotEq()], comparators=[Constant(value='yes')]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value="Index '"), FormattedValue(value=Name(id='vector_index_name', ctx=Load()), conversion=-1), Constant(value="' was not deleted.")])], keywords=[])), Return(value=Constant(value=False))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='pc', ctx=Load()), attr='delete_index', ctx=Load()), args=[Name(id='vector_index_name', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Deleted existing index: '), FormattedValue(value=Name(id='vector_index_name', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Constant(value=True))], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value="Index '"), FormattedValue(value=Name(id='vector_index_name', ctx=Load()), conversion=-1), Constant(value="' does not exist.")])], keywords=[])), Return(value=Constant(value=False))])], decorator_list=[]), FunctionDef(name='update_pinecone_index_list_md', args=arguments(posonlyargs=[], args=[arg(arg='file_name'), arg(arg='log_folder_path')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='pinecone_index_list.md'), Name(id='VZIP_LOG_FOLDER', ctx=Load())]), body=[Expr(value=Constant(value="\n    Updates a markdown file with a list of Pinecone indices.\n\n    :param file_name: Name of the markdown file to update. Default is 'pinecone_index_list.md'.\n    :param log_folder_path: Path to the folder where the file will be saved. Default is VZIP_LOG_FOLDER.\n    ")), ImportFrom(module='primary.fileops', names=[alias(name='get_current_datetime_humanfriendly')], level=0), Assign(targets=[Name(id='pc', ctx=Store())], value=Call(func=Name(id='Pinecone', ctx=Load()), args=[], keywords=[keyword(arg='api_key', value=Name(id='PINECONE_API_KEY', ctx=Load()))])), Assign(targets=[Name(id='index_names', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='pc', ctx=Load()), attr='list_indexes', ctx=Load()), args=[], keywords=[]), attr='names', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='file_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='log_folder_path', ctx=Load()), Name(id='file_name', ctx=Load())], keywords=[])), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='w')], keywords=[]), optional_vars=Name(id='f', ctx=Store()))], body=[Assign(targets=[Name(id='last_updated', ctx=Store())], value=Call(func=Name(id='get_current_datetime_humanfriendly', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[JoinedStr(values=[Constant(value='Last updated: '), FormattedValue(value=Name(id='last_updated', ctx=Load()), conversion=-1), Constant(value='\n\n')])], keywords=[])), For(target=Name(id='index_name', ctx=Store()), iter=Name(id='index_names', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[JoinedStr(values=[Constant(value='- '), FormattedValue(value=Name(id='index_name', ctx=Load()), conversion=-1), Constant(value='\n')])], keywords=[]))], orelse=[])]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Updated Pinecone index list in '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1)])], keywords=[]))], decorator_list=[]), FunctionDef(name='save_splits_to_json', args=arguments(posonlyargs=[], args=[arg(arg='all_chunks'), arg(arg='output_base_filename'), arg(arg='metadata'), arg(arg='log_folder_path')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='VZIP_LOG_FOLDER', ctx=Load())]), body=[Expr(value=Constant(value='\n    Saves the text splits and metadata to a JSON file, organized by source.\n\n    :param all_chunks: List of Document objects containing the text splits.\n    :param output_base_filename: Base filename for the output JSON file.\n    :param metadata: Dictionary containing metadata to be included in the JSON.\n    :return: Path to the saved JSON file.\n    ')), Assign(targets=[Name(id='output_filename', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='log_folder_path', ctx=Load()), conversion=-1), FormattedValue(value=Name(id='output_base_filename', ctx=Load()), conversion=-1), Constant(value='.json')])), Assign(targets=[Name(id='content_by_source', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='doc', ctx=Store()), iter=Name(id='all_chunks', ctx=Load()), body=[Assign(targets=[Name(id='source', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='doc', ctx=Load()), attr='metadata', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='source'), Constant(value='Unknown source')], keywords=[])), If(test=Compare(left=Name(id='source', ctx=Load()), ops=[NotIn()], comparators=[Name(id='content_by_source', ctx=Load())]), body=[Assign(targets=[Subscript(value=Name(id='content_by_source', ctx=Load()), slice=Name(id='source', ctx=Load()), ctx=Store())], value=Dict(keys=[Constant(value='num_chunks'), Constant(value='chunks')], values=[Constant(value=0), List(elts=[], ctx=Load())]))], orelse=[]), AugAssign(target=Subscript(value=Subscript(value=Name(id='content_by_source', ctx=Load()), slice=Name(id='source', ctx=Load()), ctx=Load()), slice=Constant(value='num_chunks'), ctx=Store()), op=Add(), value=Constant(value=1)), Expr(value=Call(func=Attribute(value=Subscript(value=Subscript(value=Name(id='content_by_source', ctx=Load()), slice=Name(id='source', ctx=Load()), ctx=Load()), slice=Constant(value='chunks'), ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='doc', ctx=Load()), attr='page_content', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Constant(value='total_chunks (vectors)'), ops=[In()], comparators=[Name(id='metadata', ctx=Load())]), body=[Assign(targets=[Subscript(value=Name(id='metadata', ctx=Load()), slice=Constant(value='total_chunks'), ctx=Store())], value=Call(func=Attribute(value=Name(id='metadata', ctx=Load()), attr='pop', ctx=Load()), args=[Constant(value='total_chunks (vectors)')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='data', ctx=Store())], value=Dict(keys=[Constant(value='metadata'), Constant(value='content')], values=[Name(id='metadata', ctx=Load()), Dict(keys=[Constant(value='chunks_by_source')], values=[Name(id='content_by_source', ctx=Load())])])), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='output_filename', ctx=Load()), Constant(value='w')], keywords=[keyword(arg='encoding', value=Constant(value='utf-8'))]), optional_vars=Name(id='f', ctx=Store()))], body=[Expr(value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='dump', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='f', ctx=Load())], keywords=[keyword(arg='ensure_ascii', value=Constant(value=False)), keyword(arg='indent', value=Constant(value=2))]))]), Assign(targets=[Name(id='json_full_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='abspath', ctx=Load()), args=[Name(id='output_filename', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='\nSaved '), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='all_chunks', ctx=Load())], keywords=[]), conversion=-1), Constant(value=' splits from '), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='content_by_source', ctx=Load())], keywords=[]), conversion=-1), Constant(value=' sources to '), FormattedValue(value=Name(id='json_full_path', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Name(id='json_full_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='setup_create_vectordb', args=arguments(posonlyargs=[], args=[arg(arg='folder_paths'), arg(arg='vector_index_base'), arg(arg='suffixpat_include')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n    Sets up the initial parameters for creating a vector database.\n    \n    :param folder_paths: List of folder paths to process\n    :param vector_index_base: Base name for the vector index\n    :param suffixpat_include: Pattern to filter files (optional)\n    :return: Tuple of (vector_index_name, vector_index_name_with_timestamp, datetime, all_file_paths)\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='get_files_in_folder'), alias(name='get_current_datetime_filefriendly')], level=0), Import(names=[alias(name='inspect')]), Assign(targets=[Name(id='calling_function', ctx=Store())], value=Attribute(value=Subscript(value=Call(func=Attribute(value=Name(id='inspect', ctx=Load()), attr='stack', ctx=Load()), args=[], keywords=[]), slice=Constant(value=1), ctx=Load()), attr='function', ctx=Load())), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Running '), FormattedValue(value=Name(id='calling_function', ctx=Load()), conversion=-1), Constant(value='!!')])], keywords=[])), Assign(targets=[Name(id='file_count', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='all_file_paths', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='folder', ctx=Store()), iter=Name(id='folder_paths', ctx=Load()), body=[Assign(targets=[Name(id='folder_file_paths', ctx=Store())], value=Call(func=Name(id='get_files_in_folder', ctx=Load()), args=[Name(id='folder', ctx=Load())], keywords=[keyword(arg='suffixpat_include', value=Name(id='suffixpat_include', ctx=Load()))])), Assign(targets=[Name(id='folder_file_count', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='folder_file_paths', ctx=Load())], keywords=[])), AugAssign(target=Name(id='all_file_paths', ctx=Store()), op=Add(), value=Name(id='folder_file_paths', ctx=Load())), AugAssign(target=Name(id='file_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='folder_file_paths', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Including folder: '), FormattedValue(value=Name(id='folder', ctx=Load()), conversion=-1), Constant(value=' with '), FormattedValue(value=Name(id='folder_file_count', ctx=Load()), conversion=-1), Constant(value=' files.')])], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Total file count: '), FormattedValue(value=Name(id='file_count', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='datetime', ctx=Store())], value=Call(func=Name(id='get_current_datetime_filefriendly', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='date_nodashes', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Call(func=Attribute(value=Name(id='datetime', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='_')], keywords=[]), slice=Constant(value=0), ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='-'), Constant(value='')], keywords=[])), Assign(targets=[Name(id='timestamp', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='datetime', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='_')], keywords=[]), slice=Constant(value=1), ctx=Load())), Assign(targets=[Name(id='vector_index_name', ctx=Store())], value=BinOp(left=Name(id='vector_index_base', ctx=Load()), op=Add(), right=JoinedStr(values=[Constant(value='-'), FormattedValue(value=Name(id='file_count', ctx=Load()), conversion=-1), Constant(value='f-'), FormattedValue(value=Name(id='date_nodashes', ctx=Load()), conversion=-1)]))), Assign(targets=[Name(id='vector_index_name_with_timestamp', ctx=Store())], value=BinOp(left=Name(id='vector_index_base', ctx=Load()), op=Add(), right=JoinedStr(values=[Constant(value='-'), FormattedValue(value=Name(id='file_count', ctx=Load()), conversion=-1), Constant(value='f_'), FormattedValue(value=Name(id='datetime', ctx=Load()), conversion=-1)]))), Return(value=Tuple(elts=[Name(id='vector_index_name', ctx=Load()), Name(id='vector_index_name_with_timestamp', ctx=Load()), Name(id='datetime', ctx=Load()), Name(id='all_file_paths', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='check_and_create_pinecone_index', args=arguments(posonlyargs=[], args=[arg(arg='vector_index_name'), arg(arg='dimension'), arg(arg='metric')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=1536), Constant(value='cosine')]), body=[Expr(value=Constant(value="\n    Initializes Pinecone, checks if the specified index exists, creates it if it doesn't,\n    and prompts the user for action if the index already exists.\n    \n    :param vector_index_name: Name of the Pinecone index to check/create\n    :param dimension: Dimension of the vectors (default is 1536 for OpenAI embeddings)\n    :param metric: Distance metric to use (default is 'cosine')\n    :return: Boolean indicating whether to continue with the vector database creation\n    ")), Assign(targets=[Subscript(value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), slice=Constant(value='PINECONE_API_KEY'), ctx=Store())], value=Name(id='PINECONE_API_KEY', ctx=Load())), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Initializing Pinecone and checking for the existence of vector index: '), FormattedValue(value=Name(id='vector_index_name', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='pc', ctx=Store())], value=Call(func=Name(id='Pinecone', ctx=Load()), args=[], keywords=[keyword(arg='api_key', value=Name(id='PINECONE_API_KEY', ctx=Load()))])), While(test=Constant(value=True), body=[If(test=Compare(left=Name(id='vector_index_name', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Call(func=Attribute(value=Name(id='pc', ctx=Load()), attr='list_indexes', ctx=Load()), args=[], keywords=[]), attr='names', ctx=Load()), args=[], keywords=[])]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value="The index '"), FormattedValue(value=Name(id='vector_index_name', ctx=Load()), conversion=-1), Constant(value="' already exists in Pinecone.\nPlease manually delete the Pinecone vector DB index in the Pinecone portal if you want to continue.")])], keywords=[])), Assign(targets=[Name(id='user_input', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='input', ctx=Load()), args=[Constant(value='Do you want to continue after deleting the index? (yes/no): ')], keywords=[]), attr='strip', ctx=Load()), args=[], keywords=[]), attr='lower', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='user_input', ctx=Load()), ops=[NotIn()], comparators=[List(elts=[Constant(value='yes'), Constant(value='y')], ctx=Load())]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Aborting create_vectordb: User chose not to continue.')], keywords=[])), Return(value=Constant(value=False))], orelse=[])], orelse=[Break()])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='pc', ctx=Load()), attr='create_index', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Name(id='vector_index_name', ctx=Load())), keyword(arg='dimension', value=Name(id='dimension', ctx=Load())), keyword(arg='metric', value=Name(id='metric', ctx=Load())), keyword(arg='spec', value=Call(func=Name(id='ServerlessSpec', ctx=Load()), args=[], keywords=[keyword(arg='cloud', value=Constant(value='aws')), keyword(arg='region', value=Constant(value='us-west-2'))]))])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Created new index: '), FormattedValue(value=Name(id='vector_index_name', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Constant(value=True))], decorator_list=[]), FunctionDef(name='log_zip_vectordb', args=arguments(posonlyargs=[], args=[arg(arg='vectors_file_path'), arg(arg='vector_index_name_with_timestamp'), arg(arg='metadata'), arg(arg='file_paths_list'), arg(arg='log_folder_path')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='VZIP_LOG_FOLDER', ctx=Load())]), body=[Expr(value=Constant(value='\n    Creates a log file for vector database creation and zips source files.\n\n    :param vectors_file_path: Path to the vectors file to be zipped.\n    :param vector_index_name_with_timestamp: Name of the vector index with timestamp.\n    :param metadata: Metadata dictionary containing relevant information.\n    :param file_paths_list: List of all file paths processed.\n    :param log_folder_path: Folder to store log files and zips.\n    :return: Tuple of (log_file_path, zip_file_path)\n    ')), Assign(targets=[Name(id='log_file_name', ctx=Store())], value=JoinedStr(values=[Constant(value='vectordb-log_'), FormattedValue(value=Name(id='vector_index_name_with_timestamp', ctx=Load()), conversion=-1), Constant(value='.md')])), Assign(targets=[Name(id='log_file_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='log_folder_path', ctx=Load()), Name(id='log_file_name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='log_entry', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='log_file_path', ctx=Load()), conversion=-1), Constant(value='\n\n')])), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='metadata', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[AugAssign(target=Name(id='log_entry', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Name(id='key', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1), Constant(value='\n')]))], orelse=[]), AugAssign(target=Name(id='log_entry', ctx=Store()), op=Add(), value=Constant(value='\nfile paths:\n')), AugAssign(target=Name(id='log_entry', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[GeneratorExp(elt=JoinedStr(values=[Constant(value='    '), FormattedValue(value=Name(id='path', ctx=Load()), conversion=-1)]), generators=[comprehension(target=Name(id='path', ctx=Store()), iter=Name(id='file_paths_list', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), AugAssign(target=Name(id='log_entry', ctx=Store()), op=Add(), value=Constant(value='\n')), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='makedirs', ctx=Load()), args=[Name(id='log_folder_path', ctx=Load())], keywords=[keyword(arg='exist_ok', value=Constant(value=True))])), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='log_file_path', ctx=Load()), Constant(value='w')], keywords=[]), optional_vars=Name(id='f', ctx=Store()))], body=[Expr(value=Call(func=Attribute(value=Name(id='f', ctx=Load()), attr='write', ctx=Load()), args=[Name(id='log_entry', ctx=Load())], keywords=[]))]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Logging entry added to '), FormattedValue(value=Name(id='log_file_path', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='zip_file_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='log_folder_path', ctx=Load()), JoinedStr(values=[Constant(value='vectordb-zip_'), FormattedValue(value=Name(id='vector_index_name_with_timestamp', ctx=Load()), conversion=-1), Constant(value='.zip')])], keywords=[])), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='zipfile', ctx=Load()), attr='ZipFile', ctx=Load()), args=[Name(id='zip_file_path', ctx=Load()), Constant(value='w')], keywords=[]), optional_vars=Name(id='zipf', ctx=Store()))], body=[For(target=Name(id='file_path', ctx=Store()), iter=Name(id='file_paths_list', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='zipf', ctx=Load()), attr='write', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Constant(value='vectordb-sources'), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='zipf', ctx=Load()), attr='write', ctx=Load()), args=[Name(id='log_file_path', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='log_file_path', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='zipf', ctx=Load()), attr='write', ctx=Load()), args=[Name(id='vectors_file_path', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='vectors_file_path', ctx=Load())], keywords=[])], keywords=[]))]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Source files, vectors file, and log zipped to '), FormattedValue(value=Name(id='zip_file_path', ctx=Load()), conversion=-1)])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='remove', ctx=Load()), args=[Name(id='vectors_file_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Deleted the original vectors file: '), FormattedValue(value=Name(id='vectors_file_path', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Tuple(elts=[Name(id='log_file_path', ctx=Load()), Name(id='zip_file_path', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='create_vectordb_vrag_langchain', args=arguments(posonlyargs=[], args=[arg(arg='folder_paths'), arg(arg='vector_index_base'), arg(arg='suffixpat_include'), arg(arg='skip_pinecone')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False)]), body=[Expr(value=Constant(value=" \n    Establishes a Pinecone database using documents from the directory of markdown files. \n    If vector index name already exists in Pinecone, this aborts - so the index must be manually deleted in portal prior to running this.\n    VRAG is a different pipeline than QRAG, and currently does not support custom metadata. (RT 6-10-2024)\n    VRAG Is set up to mainly accept unstructured documents, and QRAG only accepts structured input documents.\n\n    :param folder_paths: list of strings of the paths leading to the Obsidian vaults.\n    :param vector_index_base: string of the base name for the Pinecone index, (may only contain -'s), to which the number of files and date are added. \n    :param suffixpat_include: string or None, specifying which file suffix patterns (_suffix and/or extension) to include.\n    :param skip_pinecone: boolean, whether to skip the pinecone index creation and upserting (for splitting and testing).\n    :return: None\n    ")), ImportFrom(module='primary.fileops', names=[alias(name='apply_to_folder'), alias(name='create_new_file_from_heading'), alias(name='sub_suffix_in_file'), alias(name='move_files_with_suffix'), alias(name='remove_timestamp_links'), alias(name='find_and_replace_pairs')], level=0), Assign(targets=[Subscript(value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), slice=Constant(value='OPENAI_API_KEY'), ctx=Store())], value=Name(id='OPENAI_API_KEY_CONFIG_LLM', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='vector_index_name', ctx=Store()), Name(id='vector_index_name_with_timestamp', ctx=Store()), Name(id='datetime', ctx=Store()), Name(id='all_file_paths', ctx=Store())], ctx=Store())], value=Call(func=Name(id='setup_create_vectordb', ctx=Load()), args=[Name(id='folder_paths', ctx=Load()), Name(id='vector_index_base', ctx=Load()), Name(id='suffixpat_include', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='skip_pinecone', ctx=Load())), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='check_and_create_pinecone_index', ctx=Load()), args=[Name(id='vector_index_name', ctx=Load())], keywords=[])), body=[Return()], orelse=[])], orelse=[]), Assign(targets=[Name(id='all_docs', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='folder_path', ctx=Store()), iter=Name(id='folder_paths', ctx=Load()), body=[Assign(targets=[Name(id='temp_folder_path', ctx=Store())], value=BinOp(left=Name(id='VZIP_LOG_FOLDER', ctx=Load()), op=Add(), right=Constant(value='_temp_vrag_sources'))), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='temp_folder_path', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='shutil', ctx=Load()), attr='rmtree', ctx=Load()), args=[Name(id='temp_folder_path', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='makedirs', ctx=Load()), args=[Name(id='temp_folder_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='apply_to_folder', ctx=Load()), args=[Name(id='create_new_file_from_heading', ctx=Load()), Name(id='folder_path', ctx=Load())], keywords=[keyword(arg='heading', value=Constant(value='## content')), keyword(arg='suffix_new', value=Constant(value='_temp')), keyword(arg='suffixpat_include', value=Name(id='suffixpat_include', ctx=Load())), keyword(arg='remove_heading', value=Constant(value=True))])), Expr(value=Call(func=Name(id='move_files_with_suffix', ctx=Load()), args=[Name(id='folder_path', ctx=Load()), Name(id='temp_folder_path', ctx=Load()), Constant(value='_temp')], keywords=[])), Expr(value=Call(func=Name(id='apply_to_folder', ctx=Load()), args=[Name(id='sub_suffix_in_file', ctx=Load()), Name(id='temp_folder_path', ctx=Load()), Constant(value='')], keywords=[])), Expr(value=Call(func=Name(id='apply_to_folder', ctx=Load()), args=[Name(id='remove_timestamp_links', ctx=Load()), Name(id='temp_folder_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='regex_spk_compress', ctx=Store())], value=List(elts=[Tuple(elts=[Constant(value='(\\s*[A-Za-z\\s]+\\s+(?:\\d+:)?\\d+:\\d+)\\n'), Constant(value='\\1  ')], ctx=Load())], ctx=Load())), Expr(value=Call(func=Name(id='apply_to_folder', ctx=Load()), args=[Name(id='find_and_replace_pairs', ctx=Load()), Name(id='temp_folder_path', ctx=Load()), Name(id='regex_spk_compress', ctx=Load())], keywords=[keyword(arg='use_regex', value=Constant(value=True))])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='SUCCESS: Extracted transcript sections to temporary files in '), FormattedValue(value=Name(id='temp_folder_path', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='loader', ctx=Store())], value=Call(func=Name(id='ObsidianLoader', ctx=Load()), args=[Name(id='temp_folder_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='docs', ctx=Store())], value=Call(func=Attribute(value=Name(id='loader', ctx=Load()), attr='load', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='all_docs', ctx=Load()), attr='extend', ctx=Load()), args=[Name(id='docs', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='SUCCESS: Loaded '), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='docs', ctx=Load())], keywords=[]), conversion=-1), Constant(value=' documents from '), FormattedValue(value=Name(id='folder_path', ctx=Load()), conversion=-1)])], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='skip_pinecone', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='shutil', ctx=Load()), attr='rmtree', ctx=Load()), args=[Name(id='temp_folder_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='CLEANUP: Removed temporary files from '), FormattedValue(value=Name(id='temp_folder_path', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='target_chunk_size', ctx=Store())], value=Constant(value=1000)), Assign(targets=[Name(id='chunk_overlap', ctx=Store())], value=Constant(value=150)), Assign(targets=[Name(id='text_splitter', ctx=Store())], value=Call(func=Name(id='RecursiveCharacterTextSplitter', ctx=Load()), args=[], keywords=[keyword(arg='chunk_size', value=Name(id='target_chunk_size', ctx=Load())), keyword(arg='chunk_overlap', value=Name(id='chunk_overlap', ctx=Load()))])), Assign(targets=[Name(id='all_chunks', ctx=Store())], value=Call(func=Attribute(value=Name(id='text_splitter', ctx=Load()), attr='split_documents', ctx=Load()), args=[Name(id='all_docs', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='SUCCESS: Split '), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='all_docs', ctx=Load())], keywords=[]), conversion=-1), Constant(value=' documents into '), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='all_chunks', ctx=Load())], keywords=[]), conversion=-1), Constant(value=' splits with a target chunk size of '), FormattedValue(value=Name(id='target_chunk_size', ctx=Load()), conversion=-1)])], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='skip_pinecone', ctx=Load())), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='PROCESS: Populating vector store in Pinecone cloud database.')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='LangchainPinecone', ctx=Load()), attr='from_documents', ctx=Load()), args=[], keywords=[keyword(arg='documents', value=Name(id='all_chunks', ctx=Load())), keyword(arg='embedding', value=Call(func=Name(id='OpenAIEmbeddings', ctx=Load()), args=[], keywords=[])), keyword(arg='index_name', value=Name(id='vector_index_name', ctx=Load()))])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='SUCCESS: Populated and saved vector store in Pinecone cloud database.')])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='metadata', ctx=Store())], value=Dict(keys=[Constant(value='create vector function'), Constant(value='date and time'), Constant(value='pinecone vector_index_name'), Constant(value='folder_paths'), Constant(value='suffixpat_include'), Constant(value='total_files'), Constant(value='total_chunks'), Constant(value='text_splitter'), Constant(value='target_chunk_size'), Constant(value='chunk_overlap')], values=[Constant(value='create_vectordb_vrag_langchain'), Name(id='datetime', ctx=Load()), Name(id='vector_index_name', ctx=Load()), Name(id='folder_paths', ctx=Load()), Name(id='suffixpat_include', ctx=Load()), Call(func=Name(id='len', ctx=Load()), args=[Name(id='all_file_paths', ctx=Load())], keywords=[]), Call(func=Name(id='len', ctx=Load()), args=[Name(id='all_chunks', ctx=Load())], keywords=[]), Constant(value='Langchain RecursiveCharacterTextSplitter'), Name(id='target_chunk_size', ctx=Load()), Name(id='chunk_overlap', ctx=Load())])), Assign(targets=[Name(id='vectors_file_path', ctx=Store())], value=Call(func=Name(id='save_splits_to_json', ctx=Load()), args=[Name(id='all_chunks', ctx=Load()), JoinedStr(values=[Constant(value='vectordb-splits_'), FormattedValue(value=Name(id='vector_index_name_with_timestamp', ctx=Load()), conversion=-1)]), Name(id='metadata', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='SUCCESS: Saved splits to JSON file at '), FormattedValue(value=Name(id='vectors_file_path', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='log_file_path', ctx=Store()), Name(id='vectordb_zip_path', ctx=Store())], ctx=Store())], value=Call(func=Name(id='log_zip_vectordb', ctx=Load()), args=[Name(id='vectors_file_path', ctx=Load()), Name(id='vector_index_name_with_timestamp', ctx=Load()), Name(id='metadata', ctx=Load()), Name(id='all_file_paths', ctx=Load()), Name(id='VZIP_LOG_FOLDER', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Logging completed. Log file created at '), FormattedValue(value=Name(id='log_file_path', ctx=Load()), conversion=-1)])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Source files zipped to '), FormattedValue(value=Name(id='vectordb_zip_path', ctx=Load()), conversion=-1)])], keywords=[])), Expr(value=Call(func=Name(id='update_pinecone_index_list_md', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='log_file_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='create_qrag_vectordb', args=arguments(posonlyargs=[], args=[arg(arg='folder_paths'), arg(arg='vector_index_base'), arg(arg='suffixpat_include')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), slice=Constant(value='OPENAI_API_KEY'), ctx=Store())], value=Name(id='OPENAI_API_KEY_CONFIG_LLM', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='vector_index_name', ctx=Store()), Name(id='vector_index_name_with_timestamp', ctx=Store()), Name(id='datetime', ctx=Store()), Name(id='all_file_paths', ctx=Store())], ctx=Store())], value=Call(func=Name(id='setup_create_vectordb', ctx=Load()), args=[Name(id='folder_paths', ctx=Load()), Name(id='vector_index_base', ctx=Load()), Name(id='suffixpat_include', ctx=Load())], keywords=[])), Assign(targets=[Name(id='vectors', ctx=Store())], value=Call(func=Name(id='generate_vectors_qa', ctx=Load()), args=[Name(id='folder_paths', ctx=Load()), Name(id='suffixpat_include', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='check_and_create_pinecone_index', ctx=Load()), args=[Name(id='vector_index_name', ctx=Load())], keywords=[])), body=[Return(value=Constant(value=None))], orelse=[]), Expr(value=Call(func=Name(id='upsert_vectors_pinecone', ctx=Load()), args=[Name(id='vectors', ctx=Load()), Name(id='vector_index_name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='metadata', ctx=Store())], value=Dict(keys=[Constant(value='create vector function'), Constant(value='date and time'), Constant(value='pinecone vector_index_name'), Constant(value='folder_paths'), Constant(value='suffixpat_include'), Constant(value='total_files'), Constant(value='total_vectors')], values=[Constant(value='create_qrag_vectordb'), Name(id='datetime', ctx=Load()), Name(id='vector_index_name', ctx=Load()), Name(id='folder_paths', ctx=Load()), Name(id='suffixpat_include', ctx=Load()), Call(func=Name(id='len', ctx=Load()), args=[Name(id='all_file_paths', ctx=Load())], keywords=[]), Call(func=Name(id='len', ctx=Load()), args=[Name(id='vectors', ctx=Load())], keywords=[])])), Assign(targets=[Name(id='vectors_file_path', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='VZIP_LOG_FOLDER', ctx=Load()), conversion=-1), Constant(value='vectordb-vectors_'), FormattedValue(value=Name(id='vector_index_name_with_timestamp', ctx=Load()), conversion=-1), Constant(value='.json')])), Expr(value=Call(func=Name(id='vectors_to_json', ctx=Load()), args=[Name(id='vectors', ctx=Load()), Name(id='vectors_file_path', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='log_file_path', ctx=Store()), Name(id='vectordb_zip_path', ctx=Store())], ctx=Store())], value=Call(func=Name(id='log_zip_vectordb', ctx=Load()), args=[Name(id='vectors_file_path', ctx=Load()), Name(id='vector_index_name_with_timestamp', ctx=Load()), Name(id='metadata', ctx=Load()), Name(id='all_file_paths', ctx=Load()), Name(id='VZIP_LOG_FOLDER', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Logging completed. Log file created at '), FormattedValue(value=Name(id='log_file_path', ctx=Load()), conversion=-1)])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Source files zipped to '), FormattedValue(value=Name(id='vectordb_zip_path', ctx=Load()), conversion=-1)])], keywords=[])), Expr(value=Call(func=Name(id='update_pinecone_index_list_md', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='log_file_path', ctx=Load()))], decorator_list=[])], type_ignores=[])

Module(body=[Import(names=[alias(name='os')]), ImportFrom(module='datetime', names=[alias(name='datetime')], level=0), ImportFrom(module='pinecone', names=[alias(name='Pinecone')], level=0), ImportFrom(module='primary.vectordb', names=[alias(name='generate_embedding')], level=0), ImportFrom(module='primary.llm', names=[alias(name='simple_openai_chat_completion_request')], level=0), ImportFrom(module='primary.rag_prompts_routes', names=[alias(name='*')], level=0), ImportFrom(module='config', names=[alias(name='PINECONE_API_KEY'), alias(name='OPENAI_API_KEY_CONFIG_LLM'), alias(name='ANTHROPIC_API_KEY_CONFIG_LLM')], level=0), Assign(targets=[Subscript(value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), slice=Constant(value='OPENAI_API_KEY'), ctx=Store())], value=Name(id='OPENAI_API_KEY_CONFIG_LLM', ctx=Load())), Assign(targets=[Subscript(value=Attribute(value=Name(id='os', ctx=Load()), attr='environ', ctx=Load()), slice=Constant(value='ANTHROPIC_API_KEY'), ctx=Store())], value=Name(id='ANTHROPIC_API_KEY_CONFIG_LLM', ctx=Load())), Assign(targets=[Name(id='DEFAULT_LLM_MODEL', ctx=Store())], value=Constant(value='gpt-4o')), Assign(targets=[Name(id='pc', ctx=Store())], value=Call(func=Name(id='Pinecone', ctx=Load()), args=[], keywords=[keyword(arg='api_key', value=Name(id='PINECONE_API_KEY', ctx=Load()))])), FunctionDef(name='pinecone_retriever', args=arguments(posonlyargs=[], args=[arg(arg='query'), arg(arg='vector_index_name'), arg(arg='num_chunks')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=5)]), body=[Expr(value=Constant(value=' \n    Retrieves relevant question chunks from a Pinecone index based on the input question.\n\n    :param question: string of the input question to search for.\n    :param vector_index_name: string of the name of the Pinecone index to query.\n    :return: tuple containing fetched question chunks and a dictionary of retrieved IDs with their scores.\n    ')), Assign(targets=[Name(id='vectorized_query', ctx=Store())], value=Call(func=Name(id='generate_embedding', ctx=Load()), args=[Name(id='query', ctx=Load())], keywords=[])), Assign(targets=[Name(id='index', ctx=Store())], value=Call(func=Attribute(value=Name(id='pc', ctx=Load()), attr='Index', ctx=Load()), args=[Name(id='vector_index_name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='retrieved_qchunks', ctx=Store())], value=Call(func=Attribute(value=Name(id='index', ctx=Load()), attr='query', ctx=Load()), args=[], keywords=[keyword(arg='namespace', value=Constant(value='')), keyword(arg='vector', value=Name(id='vectorized_query', ctx=Load())), keyword(arg='top_k', value=Name(id='num_chunks', ctx=Load())), keyword(arg='include_values', value=Constant(value=False))])), Assign(targets=[Name(id='retrieved_ids_scores', ctx=Store())], value=DictComp(key=Subscript(value=Name(id='vector', ctx=Load()), slice=Constant(value='id'), ctx=Load()), value=Subscript(value=Name(id='vector', ctx=Load()), slice=Constant(value='score'), ctx=Load()), generators=[comprehension(target=Name(id='vector', ctx=Store()), iter=Subscript(value=Name(id='retrieved_qchunks', ctx=Load()), slice=Constant(value='matches'), ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='ids', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='retrieved_ids_scores', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='fetched_chunks', ctx=Store())], value=Call(func=Attribute(value=Name(id='index', ctx=Load()), attr='fetch', ctx=Load()), args=[], keywords=[keyword(arg='ids', value=Name(id='ids', ctx=Load())), keyword(arg='namespace', value=Constant(value=''))])), Return(value=Tuple(elts=[Name(id='fetched_chunks', ctx=Load()), Name(id='retrieved_ids_scores', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='print_vrag_display_text', args=arguments(posonlyargs=[], args=[arg(arg='json_object'), arg(arg='show_prompt')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value="\n    Prints a formatted display text for VRAG (Vector Retrieval Augmented Generation) results.\n\n    :param json_object: dictionary containing VRAG results with 'content' key.\n    :param show_prompt: boolean to determine whether to show the full LLM prompt.\n    :return: None.\n    ")), Assign(targets=[Name(id='user_question', ctx=Store())], value=Subscript(value=Subscript(value=Name(id='json_object', ctx=Load()), slice=Constant(value='content'), ctx=Load()), slice=Constant(value='user_question'), ctx=Load())), Assign(targets=[Name(id='ai_answer', ctx=Store())], value=Subscript(value=Subscript(value=Name(id='json_object', ctx=Load()), slice=Constant(value='content'), ctx=Load()), slice=Constant(value='ai_answer'), ctx=Load())), Assign(targets=[Name(id='display_text', ctx=Store())], value=JoinedStr(values=[Constant(value='USER QUESTION: '), FormattedValue(value=Name(id='user_question', ctx=Load()), conversion=-1), Constant(value='\n\n')])), If(test=Name(id='show_prompt', ctx=Load()), body=[Assign(targets=[Name(id='llm_prompt', ctx=Store())], value=Subscript(value=Subscript(value=Name(id='json_object', ctx=Load()), slice=Constant(value='content'), ctx=Load()), slice=Constant(value='llm_prompt'), ctx=Load())), AugAssign(target=Name(id='display_text', ctx=Store()), op=Add(), value=JoinedStr(values=[Constant(value='LLM PROMPT:\n'), FormattedValue(value=Name(id='llm_prompt', ctx=Load()), conversion=-1), Constant(value='\n\n')]))], orelse=[Assign(targets=[Name(id='chunk_texts', ctx=Store())], value=Subscript(value=Subscript(value=Name(id='json_object', ctx=Load()), slice=Constant(value='content'), ctx=Load()), slice=Constant(value='chunk_texts'), ctx=Load())), AugAssign(target=Name(id='display_text', ctx=Store()), op=Add(), value=JoinedStr(values=[Constant(value='RETRIEVED CHUNKS:\n'), FormattedValue(value=Name(id='chunk_texts', ctx=Load()), conversion=-1), Constant(value='\n\n')]))]), AugAssign(target=Name(id='display_text', ctx=Store()), op=Add(), value=JoinedStr(values=[Constant(value='AI ANSWER: '), FormattedValue(value=Name(id='ai_answer', ctx=Load()), conversion=-1)])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='display_text', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='vrag_llm_call', args=arguments(posonlyargs=[], args=[arg(arg='user_question'), arg(arg='vector_index_name'), arg(arg='vrag_preamble'), arg(arg='llm_model'), arg(arg='user_id'), arg(arg='vrag_version')], kwonlyargs=[], kw_defaults=[], defaults=[Name(id='VRAG_PREAMBLE_V1', ctx=Load()), Name(id='DEFAULT_LLM_MODEL', ctx=Load()), Constant(value='default'), Constant(value='1.0')]), body=[Expr(value=Constant(value='\n    Initiates a chat session using vector retrieval augmented generation (VRAG) with a specified question,\n    prompt template, and index name. Returns a JSON object with the results.\n\n    :param user_question: string of the question to initiate the chat with.\n    :param vector_index_name: string of the name of the pinecone index to use for retrieval.\n    :param vrag_preamble: string of the preamble used to format the chat prompt.\n    :param llm_model: string of the language model to use.\n    :param user_id: string of the user identifier.\n    :param bot_version: string of the bot version.\n    :return: dictionary containing the chat response and metadata.\n    ')), Assign(targets=[Tuple(elts=[Name(id='fetched_chunks', ctx=Store()), Name(id='retrieved_ids_scores', ctx=Store())], ctx=Store())], value=Call(func=Name(id='pinecone_retriever', ctx=Load()), args=[Name(id='user_question', ctx=Load()), Name(id='vector_index_name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='chunk_texts', ctx=Store())], value=Constant(value='')), For(target=Tuple(elts=[Name(id='chunk_id', ctx=Store()), Name(id='chunk_data', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Subscript(value=Name(id='fetched_chunks', ctx=Load()), slice=Constant(value='vectors'), ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='chunk_data', ctx=Load()), slice=Constant(value='metadata'), ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='text'), Constant(value='')], keywords=[])), If(test=Name(id='text', ctx=Load()), body=[AugAssign(target=Name(id='chunk_texts', ctx=Store()), op=Add(), value=BinOp(left=Name(id='text', ctx=Load()), op=Add(), right=Constant(value='\n')))], orelse=[])], orelse=[]), Assign(targets=[Name(id='chunk_texts', ctx=Store())], value=Call(func=Attribute(value=Name(id='chunk_texts', ctx=Load()), attr='rstrip', ctx=Load()), args=[Constant(value='\n')], keywords=[])), Assign(targets=[Name(id='llm_prompt', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Name(id='vrag_preamble', ctx=Load()), op=Add(), right=Constant(value='\n')), op=Add(), right=Name(id='chunk_texts', ctx=Load())), op=Add(), right=Constant(value='\nUSER QUESTION: ')), op=Add(), right=Name(id='user_question', ctx=Load())), op=Add(), right=Constant(value='\n\nAI ANSWER: '))), Assign(targets=[Name(id='llm_answer', ctx=Store())], value=Call(func=Name(id='simple_openai_chat_completion_request', ctx=Load()), args=[Name(id='llm_prompt', ctx=Load())], keywords=[keyword(arg='model', value=Name(id='llm_model', ctx=Load()))])), Return(value=Dict(keys=[Constant(value='metadata'), Constant(value='content')], values=[Dict(keys=[Constant(value='timestamp'), Constant(value='user_id'), Constant(value='vector_index_name'), Constant(value='vrag_version'), Constant(value='llm_model'), Constant(value='vrag_info')], values=[Call(func=Attribute(value=Call(func=Attribute(value=Name(id='datetime', ctx=Load()), attr='now', ctx=Load()), args=[], keywords=[]), attr='isoformat', ctx=Load()), args=[], keywords=[]), Name(id='user_id', ctx=Load()), Name(id='vector_index_name', ctx=Load()), Name(id='vrag_version', ctx=Load()), Name(id='llm_model', ctx=Load()), Dict(keys=[Constant(value='vrag_preamble'), Constant(value='num_chunks')], values=[Name(id='vrag_preamble', ctx=Load()), Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='fetched_chunks', ctx=Load()), slice=Constant(value='vectors'), ctx=Load())], keywords=[])])]), Dict(keys=[Constant(value='user_question'), Constant(value='chunk_texts'), Constant(value='llm_prompt'), Constant(value='ai_answer')], values=[Name(id='user_question', ctx=Load()), Name(id='chunk_texts', ctx=Load()), Name(id='llm_prompt', ctx=Load()), Name(id='llm_answer', ctx=Load())])]))], decorator_list=[]), FunctionDef(name='select_chunks_qrag_1or2', args=arguments(posonlyargs=[], args=[arg(arg='fetched_qa_chunks'), arg(arg='retrieved_ids_scores')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=" \n    Sorts and returns the most relevant chunks based on similarity score and 'STARS' rating.\n    Filters down to 1 or 2 chunks from the 5 fetched.\n\n    :param fetched_qchunks: dictionary of fetched question chunks from Pinecone.\n    :param retrieved_ids_scores: dictionary of retrieved IDs with their similarity scores.\n    :return: tuple containing the highest similarity chunk and the highest 'STARS' rated chunk (if different).\n    ")), Assign(targets=[Name(id='highest_sim_id', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Name(id='retrieved_ids_scores', ctx=Load())], keywords=[keyword(arg='key', value=Attribute(value=Name(id='retrieved_ids_scores', ctx=Load()), attr='get', ctx=Load()))])), Assign(targets=[Name(id='highest_stars_id', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Subscript(value=Name(id='fetched_qa_chunks', ctx=Load()), slice=Constant(value='vectors'), ctx=Load())], keywords=[keyword(arg='key', value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Subscript(value=Subscript(value=Subscript(value=Name(id='fetched_qa_chunks', ctx=Load()), slice=Constant(value='vectors'), ctx=Load()), slice=Name(id='x', ctx=Load()), ctx=Load()), slice=Constant(value='metadata'), ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='STARS'), Constant(value=0)], keywords=[])))])), Assign(targets=[Name(id='highest_sim_chunk', ctx=Store())], value=Subscript(value=Subscript(value=Name(id='fetched_qa_chunks', ctx=Load()), slice=Constant(value='vectors'), ctx=Load()), slice=Name(id='highest_sim_id', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='highest_stars_chunk', ctx=Store())], value=IfExp(test=Compare(left=Name(id='highest_sim_id', ctx=Load()), ops=[NotEq()], comparators=[Name(id='highest_stars_id', ctx=Load())]), body=Subscript(value=Subscript(value=Name(id='fetched_qa_chunks', ctx=Load()), slice=Constant(value='vectors'), ctx=Load()), slice=Name(id='highest_stars_id', ctx=Load()), ctx=Load()), orelse=Constant(value=None))), Return(value=Tuple(elts=[Name(id='highest_sim_chunk', ctx=Load()), Name(id='highest_stars_chunk', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='parse_chunk_all', args=arguments(posonlyargs=[], args=[arg(arg='chunk'), arg(arg='simscores')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value=" \n    Formats information from a chunk and its optional similarity scores into a structured dictionary,\n    including all fields present in the chunk's metadata. Handles various data types including lists.\n\n    :param chunk: dictionary containing metadata and content of a document chunk.\n    :param simscores: optional dictionary of similarity scores keyed by chunk id.\n    :return: dictionary containing formatted chunk information.\n    ")), FunctionDef(name='safe_convert', args=arguments(posonlyargs=[], args=[arg(arg='value')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Converts value to appropriate type, handling various data types including lists.')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Tuple(elts=[Name(id='int', ctx=Load()), Name(id='float', ctx=Load()), Name(id='str', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load())], keywords=[]), body=[Return(value=Name(id='value', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='value', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Return(value=ListComp(elt=Call(func=Name(id='safe_convert', ctx=Load()), args=[Name(id='item', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='item', ctx=Store()), iter=Name(id='value', ctx=Load()), ifs=[], is_async=0)]))], orelse=[Try(body=[Return(value=Call(func=Name(id='int', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Try(body=[Return(value=Call(func=Name(id='float', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Return(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])])], orelse=[], finalbody=[])])])], decorator_list=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Subscript(value=Name(id='chunk', ctx=Load()), slice=Constant(value='metadata'), ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='result', ctx=Load()), slice=Call(func=Attribute(value=Name(id='key', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ctx=Store())], value=Call(func=Name(id='safe_convert', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='simscores', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Subscript(value=Name(id='chunk', ctx=Load()), slice=Constant(value='id'), ctx=Load()), ops=[In()], comparators=[Name(id='simscores', ctx=Load())])]), body=[Assign(targets=[Subscript(value=Name(id='result', ctx=Load()), slice=Constant(value='sim'), ctx=Store())], value=Call(func=Name(id='safe_convert', ctx=Load()), args=[Subscript(value=Name(id='simscores', ctx=Load()), slice=Subscript(value=Name(id='chunk', ctx=Load()), slice=Constant(value='id'), ctx=Load()), ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[]), FunctionDef(name='parse_chunk_qa_dd', args=arguments(posonlyargs=[], args=[arg(arg='chunk'), arg(arg='simscores'), arg(arg='prefix')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='')]), body=[Expr(value=Constant(value=' \n    Wrapper function that formats information from a chunk and its similarity scores into a structured dictionary,\n    maintaining the same functionality as the original parse_chunk_qa_dd function while using parse_chunk_all internally.\n    Handles complex data types like lists and empty strings.\n\n    :param chunk: dictionary containing metadata and content of a document chunk.\n    :param simscores: dictionary of similarity scores keyed by chunk id.\n    :param prefix: string of prefix to add to dictionary keys. default is empty string.\n    :return: dictionary containing formatted chunk information with prefixed keys.\n    ')), Assign(targets=[Name(id='general_result', ctx=Store())], value=Call(func=Name(id='parse_chunk_all', ctx=Load()), args=[Name(id='chunk', ctx=Load()), Name(id='simscores', ctx=Load())], keywords=[])), FunctionDef(name='safe_int', args=arguments(posonlyargs=[], args=[arg(arg='value'), arg(arg='default')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0)]), body=[Try(body=[Return(value=IfExp(test=Compare(left=Name(id='value', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='')]), body=Call(func=Name(id='int', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), orelse=Name(id='default', ctx=Load())))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='ValueError', ctx=Load()), Name(id='TypeError', ctx=Load())], ctx=Load()), body=[Return(value=Name(id='default', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='safe_float', args=arguments(posonlyargs=[], args=[arg(arg='value'), arg(arg='default')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0.0)]), body=[Try(body=[Return(value=IfExp(test=Compare(left=Name(id='value', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='')]), body=Call(func=Name(id='float', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), orelse=Name(id='default', ctx=Load())))], handlers=[ExceptHandler(type=Tuple(elts=[Name(id='ValueError', ctx=Load()), Name(id='TypeError', ctx=Load())], ctx=Load()), body=[Return(value=Name(id='default', ctx=Load()))])], orelse=[], finalbody=[])], decorator_list=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Dict(keys=[JoinedStr(values=[FormattedValue(value=Name(id='prefix', ctx=Load()), conversion=-1), Constant(value='source')]), JoinedStr(values=[FormattedValue(value=Name(id='prefix', ctx=Load()), conversion=-1), Constant(value='timestamp')]), JoinedStr(values=[FormattedValue(value=Name(id='prefix', ctx=Load()), conversion=-1), Constant(value='question')]), JoinedStr(values=[FormattedValue(value=Name(id='prefix', ctx=Load()), conversion=-1), Constant(value='answer')]), JoinedStr(values=[FormattedValue(value=Name(id='prefix', ctx=Load()), conversion=-1), Constant(value='sim')]), JoinedStr(values=[FormattedValue(value=Name(id='prefix', ctx=Load()), conversion=-1), Constant(value='stars')])], values=[Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='general_result', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='source'), Constant(value='Unknown source')], keywords=[])], keywords=[]), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='general_result', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='timestamp'), Constant(value='Unknown timestamp')], keywords=[])], keywords=[]), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='general_result', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='question'), Constant(value='Unknown question')], keywords=[])], keywords=[]), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='general_result', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='answer'), Constant(value='Unknown answer')], keywords=[])], keywords=[]), Call(func=Name(id='safe_float', ctx=Load()), args=[Call(func=Attribute(value=Name(id='general_result', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='sim'), Constant(value=0.0)], keywords=[])], keywords=[]), Call(func=Name(id='safe_int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='general_result', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='stars'), Constant(value=0)], keywords=[])], keywords=[])])), Assign(targets=[Name(id='stars', ctx=Store())], value=Subscript(value=Name(id='result', ctx=Load()), slice=JoinedStr(values=[FormattedValue(value=Name(id='prefix', ctx=Load()), conversion=-1), Constant(value='stars')]), ctx=Load())), Assign(targets=[Name(id='sim_score', ctx=Store())], value=Subscript(value=Name(id='result', ctx=Load()), slice=JoinedStr(values=[FormattedValue(value=Name(id='prefix', ctx=Load()), conversion=-1), Constant(value='sim')]), ctx=Load())), Assign(targets=[Subscript(value=Name(id='result', ctx=Load()), slice=JoinedStr(values=[FormattedValue(value=Name(id='prefix', ctx=Load()), conversion=-1), Constant(value='display')]), ctx=Store())], value=JoinedStr(values=[Constant(value='QUOTED ANSWER STARS: '), FormattedValue(value=Name(id='stars', ctx=Load()), conversion=-1), Constant(value='\nQUOTED QUESTION SIMILARITY SCORE: '), FormattedValue(value=Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Name(id='sim_score', ctx=Load()), op=Mult(), right=Constant(value=100))], keywords=[]), conversion=-1), Constant(value='%')])), Return(value=Name(id='result', ctx=Load()))], decorator_list=[]), FunctionDef(name='qrag_routing_call', args=arguments(posonlyargs=[], args=[arg(arg='user_question'), arg(arg='vector_index_name'), arg(arg='routes_dict'), arg(arg='routes_bounds'), arg(arg='llm_model'), arg(arg='user_id'), arg(arg='qrag_version')], kwonlyargs=[], kw_defaults=[], defaults=[List(elts=[Constant(value=0.3), Constant(value=0.9)], ctx=Load()), Name(id='DEFAULT_LLM_MODEL', ctx=Load()), Constant(value='default'), Constant(value='1.0')]), body=[Expr(value=Constant(value=' \n    Routes a user question through a question retrieval augmented generation (QRAG) process.\n\n    :param user_question: string of the user\'s input question.\n    :param routes_dict: dictionary containing routing prompts and templates.\n    :param vector_index_name: string of the name of the pinecone index to use for retrieval.\n    :param routes_bounds: list of two floats representing the lower and upper similarity bounds for routing.\n    :param user_id: string of the user identifier. defaults to \'default\'.\n    :param llm_model: string of the language model to use. defaults to DEFAULT_LLM_MODEL.\n    :param bot_version: string of the bot version. defaults to "1.0".\n    :return: dictionary containing metadata and content of the QRAG process and response.\n\n    Usage:\n    response = qrag_routing_call("What is the capital of France?", routes_dict, "my_index")\n    ')), Assign(targets=[Name(id='routes_flow_name', ctx=Store())], value=Constant(value='3 routes, sim-star double, separate prompts')), Assign(targets=[Tuple(elts=[Name(id='chunks', ctx=Store()), Name(id='simscores', ctx=Store())], ctx=Store())], value=Call(func=Name(id='pinecone_retriever', ctx=Load()), args=[Name(id='user_question', ctx=Load()), Name(id='vector_index_name', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='top_sim_chunk', ctx=Store()), Name(id='top_stars_chunk', ctx=Store())], ctx=Store())], value=Call(func=Name(id='select_chunks_qrag_1or2', ctx=Load()), args=[Name(id='chunks', ctx=Load()), Name(id='simscores', ctx=Load())], keywords=[])), Assign(targets=[Name(id='top_sim_info', ctx=Store())], value=Call(func=Name(id='parse_chunk_qa_dd', ctx=Load()), args=[Name(id='top_sim_chunk', ctx=Load()), Name(id='simscores', ctx=Load()), Constant(value='top_sim_')], keywords=[])), Assign(targets=[Name(id='max_sim', ctx=Store())], value=Subscript(value=Name(id='top_sim_info', ctx=Load()), slice=Constant(value='top_sim_sim'), ctx=Load())), Assign(targets=[Name(id='max_stars', ctx=Store())], value=Subscript(value=Name(id='top_sim_info', ctx=Load()), slice=Constant(value='top_sim_stars'), ctx=Load())), Assign(targets=[Name(id='quoted_qa', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='routes_dict', ctx=Load()), slice=Constant(value='quoted_qa_single'), ctx=Load()), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Name(id='top_sim_info', ctx=Load()))])), If(test=Compare(left=Name(id='top_stars_chunk', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='top_stars_info', ctx=Store())], value=Call(func=Name(id='parse_chunk_qa_dd', ctx=Load()), args=[Name(id='top_stars_chunk', ctx=Load()), Name(id='simscores', ctx=Load()), Constant(value='top_stars_')], keywords=[])), Assign(targets=[Name(id='max_stars', ctx=Store())], value=Subscript(value=Name(id='top_stars_info', ctx=Load()), slice=Constant(value='top_stars_stars'), ctx=Load())), Assign(targets=[Name(id='combined_info', ctx=Store())], value=Dict(keys=[None, None], values=[Name(id='top_stars_info', ctx=Load()), Name(id='top_sim_info', ctx=Load())])), Assign(targets=[Name(id='quoted_qa', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='routes_dict', ctx=Load()), slice=Constant(value='quoted_qa_double'), ctx=Load()), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Name(id='combined_info', ctx=Load()))]))], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='lower_sim_bound', ctx=Store()), Name(id='upper_sim_bound', ctx=Store())], ctx=Store())], value=Name(id='routes_bounds', ctx=Load())), If(test=Compare(left=Name(id='max_sim', ctx=Load()), ops=[GtE()], comparators=[Name(id='upper_sim_bound', ctx=Load())]), body=[Assign(targets=[Name(id='route_preamble', ctx=Store())], value=Subscript(value=Name(id='routes_dict', ctx=Load()), slice=Constant(value='route_preamble_good_match'), ctx=Load()))], orelse=[If(test=Compare(left=Name(id='max_sim', ctx=Load()), ops=[LtE()], comparators=[Name(id='lower_sim_bound', ctx=Load())]), body=[Assign(targets=[Name(id='route_preamble', ctx=Store())], value=Subscript(value=Name(id='routes_dict', ctx=Load()), slice=Constant(value='route_preamble_no_match'), ctx=Load())), Assign(targets=[Name(id='quoted_qa', ctx=Store())], value=Constant(value=''))], orelse=[Assign(targets=[Name(id='route_preamble', ctx=Store())], value=Subscript(value=Name(id='routes_dict', ctx=Load()), slice=Constant(value='route_preamble_partial_match'), ctx=Load()))])]), Return(value=Dict(keys=[Constant(value='metadata'), Constant(value='content')], values=[Dict(keys=[Constant(value='timestamp'), Constant(value='user_id'), Constant(value='vector_index_name'), Constant(value='qrag_version'), Constant(value='llm_model'), Constant(value='routes_info')], values=[Call(func=Attribute(value=Call(func=Attribute(value=Name(id='datetime', ctx=Load()), attr='now', ctx=Load()), args=[], keywords=[]), attr='isoformat', ctx=Load()), args=[], keywords=[]), Name(id='user_id', ctx=Load()), Name(id='vector_index_name', ctx=Load()), Name(id='qrag_version', ctx=Load()), Name(id='llm_model', ctx=Load()), Dict(keys=[Constant(value='routes_flow_name'), Constant(value='upper_sim_bound'), Constant(value='lower_sim_bound'), Constant(value='max_sim'), Constant(value='max_stars'), Constant(value='routes_dict_content')], values=[Name(id='routes_flow_name', ctx=Load()), Name(id='upper_sim_bound', ctx=Load()), Name(id='lower_sim_bound', ctx=Load()), Call(func=Attribute(value=Constant(value='{:.3f}'), attr='format', ctx=Load()), args=[Name(id='max_sim', ctx=Load())], keywords=[]), Name(id='max_stars', ctx=Load()), Name(id='routes_dict', ctx=Load())])]), Dict(keys=[Constant(value='user_question'), Constant(value='route_preamble'), Constant(value='quoted_qa'), Constant(value='ai_answer'), Constant(value='chunks')], values=[Name(id='user_question', ctx=Load()), Name(id='route_preamble', ctx=Load()), Name(id='quoted_qa', ctx=Load()), Constant(value='WAITING FOR AI ANSWER...'), Dict(keys=[Constant(value='max_sim'), Constant(value='max_stars'), Constant(value='chunks')], values=[Call(func=Attribute(value=Constant(value='{:.3f}'), attr='format', ctx=Load()), args=[Name(id='max_sim', ctx=Load())], keywords=[]), Name(id='max_stars', ctx=Load()), BinOp(left=List(elts=[Dict(keys=[Constant(value='question'), Constant(value='source'), Constant(value='timestamp'), Constant(value='answer'), Constant(value='stars'), Constant(value='sim')], values=[Subscript(value=Name(id='top_sim_info', ctx=Load()), slice=Constant(value='top_sim_question'), ctx=Load()), Subscript(value=Name(id='top_sim_info', ctx=Load()), slice=Constant(value='top_sim_source'), ctx=Load()), Subscript(value=Name(id='top_sim_info', ctx=Load()), slice=Constant(value='top_sim_timestamp'), ctx=Load()), Subscript(value=Name(id='top_sim_info', ctx=Load()), slice=Constant(value='top_sim_answer'), ctx=Load()), Subscript(value=Name(id='top_sim_info', ctx=Load()), slice=Constant(value='top_sim_stars'), ctx=Load()), Call(func=Attribute(value=Constant(value='{:.3f}'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='top_sim_info', ctx=Load()), slice=Constant(value='top_sim_sim'), ctx=Load())], keywords=[])])], ctx=Load()), op=Add(), right=IfExp(test=Compare(left=Name(id='top_stars_chunk', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=List(elts=[Dict(keys=[Constant(value='question'), Constant(value='source'), Constant(value='timestamp'), Constant(value='answer'), Constant(value='stars'), Constant(value='sim')], values=[Subscript(value=Name(id='top_stars_info', ctx=Load()), slice=Constant(value='top_stars_question'), ctx=Load()), Subscript(value=Name(id='top_stars_info', ctx=Load()), slice=Constant(value='top_stars_source'), ctx=Load()), Subscript(value=Name(id='top_stars_info', ctx=Load()), slice=Constant(value='top_stars_timestamp'), ctx=Load()), Subscript(value=Name(id='top_stars_info', ctx=Load()), slice=Constant(value='top_stars_answer'), ctx=Load()), Subscript(value=Name(id='top_stars_info', ctx=Load()), slice=Constant(value='top_stars_stars'), ctx=Load()), Call(func=Attribute(value=Constant(value='{:.3f}'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='top_stars_info', ctx=Load()), slice=Constant(value='top_stars_sim'), ctx=Load())], keywords=[])])], ctx=Load()), orelse=List(elts=[], ctx=Load())))])])]))], decorator_list=[]), FunctionDef(name='qrag_llm_call', args=arguments(posonlyargs=[], args=[arg(arg='json_object')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=' \n    Generates an AI answer for a given JSON object containing question and context information.\n\n    :param json_object: dictionary containing the question, context, and metadata for generating an AI answer.\n    :return: dictionary with the updated JSON object including the AI-generated answer.\n    ')), Assign(targets=[Name(id='required_fields', ctx=Store())], value=List(elts=[Constant(value='user_question'), Constant(value='route_preamble'), Constant(value='quoted_qa'), Constant(value='ai_answer')], ctx=Load())), Assign(targets=[Name(id='missing_fields', ctx=Store())], value=ListComp(elt=Name(id='field', ctx=Load()), generators=[comprehension(target=Name(id='field', ctx=Store()), iter=Name(id='required_fields', ctx=Load()), ifs=[Compare(left=Name(id='field', ctx=Load()), ops=[NotIn()], comparators=[Subscript(value=Name(id='json_object', ctx=Load()), slice=Constant(value='content'), ctx=Load())])], is_async=0)])), If(test=Name(id='missing_fields', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Missing required fields in JSON object: '), FormattedValue(value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Name(id='missing_fields', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='user_question', ctx=Store())], value=Subscript(value=Subscript(value=Name(id='json_object', ctx=Load()), slice=Constant(value='content'), ctx=Load()), slice=Constant(value='user_question'), ctx=Load())), Assign(targets=[Name(id='route_preamble', ctx=Store())], value=Subscript(value=Subscript(value=Name(id='json_object', ctx=Load()), slice=Constant(value='content'), ctx=Load()), slice=Constant(value='route_preamble'), ctx=Load())), Assign(targets=[Name(id='quoted_qa', ctx=Store())], value=Subscript(value=Subscript(value=Name(id='json_object', ctx=Load()), slice=Constant(value='content'), ctx=Load()), slice=Constant(value='quoted_qa'), ctx=Load())), Assign(targets=[Name(id='llm_prompt', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Name(id='route_preamble', ctx=Load()), op=Add(), right=Constant(value='\n')), op=Add(), right=Name(id='quoted_qa', ctx=Load())), op=Add(), right=Constant(value='\nUSER QUESTION: ')), op=Add(), right=Name(id='user_question', ctx=Load())), op=Add(), right=Constant(value='\n\nAI ANSWER: '))), Assign(targets=[Name(id='llm_model', ctx=Store())], value=Subscript(value=Subscript(value=Name(id='json_object', ctx=Load()), slice=Constant(value='metadata'), ctx=Load()), slice=Constant(value='llm_model'), ctx=Load())), Assign(targets=[Name(id='llm_answer', ctx=Store())], value=Call(func=Name(id='simple_openai_chat_completion_request', ctx=Load()), args=[Name(id='llm_prompt', ctx=Load())], keywords=[keyword(arg='model', value=Name(id='llm_model', ctx=Load()))])), Assign(targets=[Subscript(value=Subscript(value=Name(id='json_object', ctx=Load()), slice=Constant(value='content'), ctx=Load()), slice=Constant(value='ai_answer'), ctx=Store())], value=Name(id='llm_answer', ctx=Load())), Return(value=Name(id='json_object', ctx=Load()))], decorator_list=[]), FunctionDef(name='print_qrag_display_text', args=arguments(posonlyargs=[], args=[arg(arg='json_object')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=" \n    Prints a formatted display text for QRAG (Question Retrieval Augmented Generation) results.\n\n    :param json_object: dictionary containing QRAG results with 'content' key.\n    :return: None.\n    ")), Assign(targets=[Name(id='user_question', ctx=Store())], value=Subscript(value=Subscript(value=Name(id='json_object', ctx=Load()), slice=Constant(value='content'), ctx=Load()), slice=Constant(value='user_question'), ctx=Load())), Assign(targets=[Name(id='route_preamble', ctx=Store())], value=Subscript(value=Subscript(value=Name(id='json_object', ctx=Load()), slice=Constant(value='content'), ctx=Load()), slice=Constant(value='route_preamble'), ctx=Load())), Assign(targets=[Name(id='quoted_qa', ctx=Store())], value=Subscript(value=Subscript(value=Name(id='json_object', ctx=Load()), slice=Constant(value='content'), ctx=Load()), slice=Constant(value='quoted_qa'), ctx=Load())), Assign(targets=[Name(id='ai_answer', ctx=Store())], value=Subscript(value=Subscript(value=Name(id='json_object', ctx=Load()), slice=Constant(value='content'), ctx=Load()), slice=Constant(value='ai_answer'), ctx=Load())), Assign(targets=[Name(id='display_text', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Constant(value='USER QUESTION: '), op=Add(), right=Name(id='user_question', ctx=Load())), op=Add(), right=Constant(value='\n\n')), op=Add(), right=Constant(value='ROUTE PREAMBLE: ')), op=Add(), right=Name(id='route_preamble', ctx=Load())), op=Add(), right=Constant(value='\n\n')), op=Add(), right=Name(id='quoted_qa', ctx=Load())), op=Add(), right=Constant(value='AI ANSWER: ')), op=Add(), right=Name(id='ai_answer', ctx=Load()))), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='display_text', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='qrag_2step', args=arguments(posonlyargs=[], args=[arg(arg='user_question'), arg(arg='routes_dict'), arg(arg='vector_index_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=" \n    Performs a two-step question-answering process using QRAG (Question Retrieval Augmented Generation).\n\n    :param user_question: string of the user's input question.\n    :return: None\n    ")), Assign(targets=[Name(id='routing_json_obj', ctx=Store())], value=Call(func=Name(id='qrag_routing_call', ctx=Load()), args=[Name(id='user_question', ctx=Load()), Name(id='routes_dict', ctx=Load()), Name(id='vector_index_name', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print_qrag_display_text', ctx=Load()), args=[Name(id='routing_json_obj', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ai_answer', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Name(id='qrag_llm_call', ctx=Load()), args=[Name(id='routing_json_obj', ctx=Load())], keywords=[]), slice=Constant(value='content'), ctx=Load()), slice=Constant(value='ai_answer'), ctx=Load())), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='ai_answer', ctx=Load())], keywords=[]))], decorator_list=[])], type_ignores=[])

Module(body=[Import(names=[alias(name='os')]), Import(names=[alias(name='re')]), Import(names=[alias(name='logging')]), Import(names=[alias(name='pypandoc')]), ImportFrom(module='llama_parse', names=[alias(name='LlamaParse')], level=0), ImportFrom(module='llama_index.core', names=[alias(name='SummaryIndex')], level=0), ImportFrom(module='llama_index.readers.google', names=[alias(name='GoogleDocsReader')], level=0), ImportFrom(module='config', names=[alias(name='LLAMA_CLOUD_API_KEY')], level=0), FunctionDef(name='convert_llamaparse_pdf_to_md', args=arguments(posonlyargs=[], args=[arg(arg='file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='suffix_append', ctx=Store())], value=Constant(value='_llamaparse')), Assign(targets=[Name(id='documents', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='LlamaParse', ctx=Load()), args=[], keywords=[keyword(arg='api_key', value=Name(id='LLAMA_CLOUD_API_KEY', ctx=Load())), keyword(arg='result_type', value=Constant(value='markdown')), keyword(arg='verbose', value=Constant(value=True))]), attr='load_data', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Subscript(value=Attribute(value=Subscript(value=Name(id='documents', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='text', ctx=Load()), slice=Slice(lower=Constant(value=0), upper=Constant(value=1000)), ctx=Load())], keywords=[])), Assign(targets=[Name(id='md_file_path', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Call(func=Attribute(value=Name(id='file_path', ctx=Load()), attr='rsplit', ctx=Load()), args=[Constant(value='.'), Constant(value=1)], keywords=[]), slice=Constant(value=0), ctx=Load()), op=Add(), right=Name(id='suffix_append', ctx=Load())), op=Add(), right=Constant(value='.md'))), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='md_file_path', ctx=Load()), Constant(value='w')], keywords=[keyword(arg='encoding', value=Constant(value='utf-8'))]), optional_vars=Name(id='md_file', ctx=Store()))], body=[Expr(value=Call(func=Attribute(value=Name(id='md_file', ctx=Load()), attr='write', ctx=Load()), args=[Attribute(value=Subscript(value=Name(id='documents', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='text', ctx=Load())], keywords=[]))]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Constant(value='Completed LlamaParse pdf to md conversion and appended suffix: '), op=Add(), right=Name(id='suffix_append', ctx=Load())), op=Add(), right=Constant(value=' on input file_path: ')), op=Add(), right=Name(id='file_path', ctx=Load()))], keywords=[])), Return(value=Name(id='md_file_path', ctx=Load()))], decorator_list=[]), FunctionDef(name='convert_llamaindex_gdocs_to_md', args=arguments(posonlyargs=[], args=[arg(arg='gdoc_id_list')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Converts Google Docs to Markdown using Llama Index.\n\n    :param gdoc_id_list: list of Google Docs document IDs.\n    :return: Markdown representation of the Google Docs.\n    ')), Expr(value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='basicConfig', ctx=Load()), args=[], keywords=[keyword(arg='level', value=Attribute(value=Name(id='logging', ctx=Load()), attr='INFO', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[], keywords=[]), attr='addHandler', ctx=Load()), args=[Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='StreamHandler', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='credentials_file', ctx=Store())], value=Constant(value='credentials_new.json')), Assign(targets=[Tuple(elts=[Name(id='credentials_dir', ctx=Store()), Name(id='original_filename', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='credentials_file', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='rename', ctx=Load()), args=[Name(id='original_filename', ctx=Load()), Constant(value='credentials.json')], keywords=[])), Assign(targets=[Name(id='documents', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='GoogleDocsReader', ctx=Load()), args=[], keywords=[]), attr='load_data', ctx=Load()), args=[], keywords=[keyword(arg='gdoc_id_list', value=Name(id='gdoc_id_list', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='rename', ctx=Load()), args=[Constant(value='credentials.json'), Name(id='original_filename', ctx=Load())], keywords=[])), Assign(targets=[Name(id='index', ctx=Store())], value=Call(func=Attribute(value=Name(id='SummaryIndex', ctx=Load()), attr='from_documents', ctx=Load()), args=[Name(id='documents', ctx=Load())], keywords=[]))], decorator_list=[]), Expr(value=Constant(value=' To confirm installation, run: pandoc --version\nShould see:\npandoc 3.2\nFeatures: +server +lua\nScripting engine: Lua 5.4\n')), FunctionDef(name='convert_file_to_md_pandoc', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='suffix_new')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='_pandoc')]), body=[Expr(value=Constant(value='\n    Converts any pandoc supported file format to a markdown file using pypandoc.\n    Including but not limited to: doc, docx, html, latex, epub, odt, rtf, ascii doc.\n    pdf has limitations.\n\n    :param file_path: string of the path to the file to be converted.\n    ')), Assign(targets=[Name(id='output_markdown_file_path', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load()), op=Add(), right=Name(id='suffix_new', ctx=Load())), op=Add(), right=Constant(value='.md'))), Assign(targets=[Name(id='extra_args', ctx=Store())], value=List(elts=[Constant(value='--wrap=none'), Constant(value='--to=markdown_strict+pipe_tables'), Constant(value='--extract-media=./media')], ctx=Load())), Assign(targets=[Name(id='output', ctx=Store())], value=Call(func=Attribute(value=Name(id='pypandoc', ctx=Load()), attr='convert_file', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='markdown')], keywords=[keyword(arg='outputfile', value=Name(id='output_markdown_file_path', ctx=Load())), keyword(arg='extra_args', value=Name(id='extra_args', ctx=Load()))])), Assert(test=Compare(left=Name(id='output', ctx=Load()), ops=[Eq()], comparators=[Constant(value='')])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Successful file conversion to markdown using pypandoc for file: '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Name(id='output_markdown_file_path', ctx=Load()))], decorator_list=[])], type_ignores=[])

Module(body=[Import(names=[alias(name='os')]), Import(names=[alias(name='re')]), FunctionDef(name='load_custom_dictionary', args=arguments(posonlyargs=[], args=[arg(arg='file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    # import nltk\n    # nltk.download('words')\n    # nltk.download('punkt')  # Added to download the 'punkt' tokenizer models\n    # from nltk.corpus import words\n# TODO rename and comment this function so it's more clear what it does\n    ")), Expr(value=Constant(value=' Load a custom dictionary from a file. ')), Try(body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Return(value=Call(func=Name(id='set', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='word', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='word', ctx=Store()), iter=Name(id='file', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))])], handlers=[ExceptHandler(type=Name(id='FileNotFoundError', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Custom dictionary file not found.')], keywords=[])), Return(value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='replace_colon_for_non_speaker', args=arguments(posonlyargs=[], args=[arg(arg='text')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Replaces colons that do not form part of speaker names with a space and a dash.\n\n    :param text: string of the transcript text that needs cleaning.\n    :return: string of the cleaned transcript text.\n    ')), Assign(targets=[Name(id='non_speaker_words', ctx=Store())], value=List(elts=[Constant(value='question'), Constant(value='up'), Constant(value='this')], ctx=Load())), For(target=Name(id='word', ctx=Store()), iter=Name(id='non_speaker_words', ctx=Load()), body=[Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='replace', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='word', ctx=Load()), conversion=-1), Constant(value=':')]), JoinedStr(values=[FormattedValue(value=Name(id='word', ctx=Load()), conversion=-1), Constant(value=' -')])], keywords=[]))], orelse=[]), Return(value=Name(id='text', ctx=Load()))], decorator_list=[]), FunctionDef(name='reformat_transcript_text', args=arguments(posonlyargs=[], args=[arg(arg='original_text')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Reformats and cleans transcript text by separating speaker names from their dialogue.\n\n    This function performs the following operations:\n    1. Removes parentheses from the text.\n    2. Replaces colons in non-speaker contexts.\n    3. Identifies speaker names and separates them from their dialogue.\n    4. Formats the text so that each speaker name is on its own line, followed by their dialogue.\n    5. Removes extra spaces and ensures consistent formatting.\n\n    :param original_text: string of the raw transcript text to be cleaned and reformatted.\n    :return: string of the cleaned and restructured transcript text, with speaker names clearly separated from dialogue.\n    ')), Assign(targets=[Name(id='speaker_dialogue_pattern', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='^([^\\d]*[a-zA-Z\\d]+[^\\d]*):\\s*(.*)$'), Attribute(value=Name(id='re', ctx=Load()), attr='MULTILINE', ctx=Load())], keywords=[])), Assign(targets=[Name(id='time_reject_pattern', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='.*\\d:\\d.*'), Attribute(value=Name(id='re', ctx=Load()), attr='MULTILINE', ctx=Load())], keywords=[])), Assign(targets=[Name(id='processed_text', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='original_text', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='('), Constant(value='')], keywords=[]), attr='replace', ctx=Load()), args=[Constant(value=')'), Constant(value='')], keywords=[])), Assign(targets=[Name(id='processed_text', ctx=Store())], value=Call(func=Name(id='replace_colon_for_non_speaker', ctx=Load()), args=[Name(id='processed_text', ctx=Load())], keywords=[])), Assign(targets=[Name(id='lines', ctx=Store())], value=Call(func=Attribute(value=Name(id='processed_text', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='fixed_lines', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='current_speaker', ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='current_dialogue', ctx=Store())], value=List(elts=[], ctx=Load())), FunctionDef(name='flush_current_dialogue', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Helper function to flush the current dialogue to the fixed_lines.')), If(test=Name(id='current_speaker', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='fixed_lines', ctx=Load()), attr='append', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='current_speaker', ctx=Load()), conversion=-1), Constant(value=':')])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='fixed_lines', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Call(func=Attribute(value=Constant(value=' '), attr='join', ctx=Load()), args=[Name(id='current_dialogue', ctx=Load())], keywords=[]), attr='strip', ctx=Load()), args=[], keywords=[]), op=Add(), right=Constant(value='\n'))], keywords=[]))], orelse=[])], decorator_list=[]), For(target=Name(id='line', ctx=Store()), iter=Name(id='lines', ctx=Load()), body=[Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='speaker_dialogue_pattern', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])), If(test=Name(id='match', ctx=Load()), body=[If(test=Call(func=Attribute(value=Name(id='time_reject_pattern', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='current_dialogue', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='flush_current_dialogue', ctx=Load()), args=[], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='current_speaker', ctx=Store()), Name(id='dialogue_part', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='match', ctx=Load()), attr='groups', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='current_dialogue', ctx=Store())], value=IfExp(test=Name(id='dialogue_part', ctx=Load()), body=List(elts=[Name(id='dialogue_part', ctx=Load())], ctx=Load()), orelse=List(elts=[], ctx=Load())))])], orelse=[If(test=Name(id='current_speaker', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='current_dialogue', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[]))], orelse=[])])], orelse=[]), Expr(value=Call(func=Name(id='flush_current_dialogue', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='rejoined_text', ctx=Store())], value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='fixed_lines', ctx=Load())], keywords=[])), Assign(targets=[Name(id='final_text', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[Constant(value=' {2,}'), Constant(value=' '), Name(id='rejoined_text', ctx=Load())], keywords=[])), Return(value=Name(id='final_text', ctx=Load()))], decorator_list=[]), FunctionDef(name='validate_transcript', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='verbose')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='\n    Validates the speaker segments in a single transcript file by checking the format of speaker segments.\n\n    :param file_path: string of path to the transcript file.\n    :param verbose: boolean indicating whether to print detailed response text\n    :return: boolean indicating whether the file passed the validation.\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='get_heading'), alias(name='verbose_print')], level=0), Assign(targets=[Name(id='transcript', ctx=Store())], value=Call(func=Name(id='get_heading', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='### transcript')], keywords=[])), Assign(targets=[Name(id='banned_characters', ctx=Store())], value=List(elts=[Constant(value=':')], ctx=Load())), Assign(targets=[Name(id='valid_format', ctx=Store())], value=Constant(value=True)), Assign(targets=[Name(id='lines', ctx=Store())], value=Call(func=Attribute(value=Name(id='transcript', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[])), Assign(targets=[Name(id='line_number', ctx=Store())], value=Constant(value=2)), While(test=Compare(left=Name(id='line_number', ctx=Load()), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[])]), body=[Assign(targets=[Name(id='line', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='lines', ctx=Load()), slice=Name(id='line_number', ctx=Load()), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Constant(value=':'), ops=[In()], comparators=[Name(id='line', ctx=Load())]), body=[Assign(targets=[Tuple(elts=[Name(id='speaker', ctx=Store()), Name(id='text_spoken', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=':'), Constant(value=1)], keywords=[])), Assign(targets=[Name(id='speaker', ctx=Store())], value=Call(func=Attribute(value=Name(id='speaker', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='speaker', ctx=Load())), body=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='FAILED VALIDATION -  Empty speaker name at line:\n'), FormattedValue(value=Name(id='line', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='valid_format', ctx=Store())], value=Constant(value=False))], orelse=[]), If(test=Compare(left=BinOp(left=Name(id='line_number', ctx=Load()), op=Add(), right=Constant(value=1)), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[])]), body=[Assign(targets=[Name(id='text_line', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='lines', ctx=Load()), slice=BinOp(left=Name(id='line_number', ctx=Load()), op=Add(), right=Constant(value=1)), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), For(target=Name(id='char', ctx=Store()), iter=Name(id='banned_characters', ctx=Load()), body=[If(test=Compare(left=Name(id='char', ctx=Load()), ops=[In()], comparators=[Name(id='text_line', ctx=Load())]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='char', ctx=Load()), ops=[Eq()], comparators=[Constant(value=':')]), Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='search', ctx=Load()), args=[Constant(value='\\d:\\d{2}'), Name(id='text_line', ctx=Load())], keywords=[])]), body=[Continue()], orelse=[]), Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='FAILED VALIDATION -  Banned character "'), FormattedValue(value=Name(id='char', ctx=Load()), conversion=-1), Constant(value='" found in transcript at line:\n'), FormattedValue(value=Name(id='line', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='valid_format', ctx=Store())], value=Constant(value=False))], orelse=[])], orelse=[])], orelse=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='FAILED VALIDATION -  Missing transcription after speaker name at line:\n'), FormattedValue(value=Name(id='line', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='valid_format', ctx=Store())], value=Constant(value=False))]), If(test=BoolOp(op=Or(), values=[Compare(left=BinOp(left=Name(id='line_number', ctx=Load()), op=Add(), right=Constant(value=2)), ops=[GtE()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[])]), Call(func=Attribute(value=Subscript(value=Name(id='lines', ctx=Load()), slice=BinOp(left=Name(id='line_number', ctx=Load()), op=Add(), right=Constant(value=2)), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])]), body=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='FAILED VALIDATION -  Missing empty line after segment at line:\n'), FormattedValue(value=Name(id='line', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='valid_format', ctx=Store())], value=Constant(value=False))], orelse=[]), AugAssign(target=Name(id='line_number', ctx=Store()), op=Add(), value=Constant(value=3))], orelse=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='FAILED VALIDATION -  Invalid format (missing speaker name) at line:\n'), FormattedValue(value=Name(id='line', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='valid_format', ctx=Store())], value=Constant(value=False)), AugAssign(target=Name(id='line_number', ctx=Store()), op=Add(), value=Constant(value=1))])], orelse=[]), If(test=Name(id='valid_format', ctx=Load()), body=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='PASSED validation of speaker segments for file: '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Constant(value=True))], orelse=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), JoinedStr(values=[Constant(value='FAILED validation of speaker segments for file: '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Constant(value=False))])], decorator_list=[]), FunctionDef(name='extract_transcript_data', args=arguments(posonlyargs=[], args=[arg(arg='file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Extracts detailed transcript information into a list of dictionaries.\n    Each dictionary contains speaker_name, speaker_role, timestamp, timestamp_link, and dialogue.\n    Speaker lines can end in a colon (FDA Townhalls) or include a timestamp (Deutsch, PV).\n    Speaker role is extracted from text within parentheses preceding the colon or timestamp.\n\n    :param file_path: string of the path to the file to be processed.\n    :return: list of dictionaries with keys ['speaker_name', 'speaker_role', 'timestamp', 'timestamp_link', 'dialogue'].\n        ")), ImportFrom(module='primary.fileops', names=[alias(name='get_heading'), alias(name='get_timestamp')], level=0), Assign(targets=[Name(id='transcript_data', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='transcript_text', ctx=Store())], value=Call(func=Name(id='get_heading', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='### transcript')], keywords=[])), If(test=Compare(left=Name(id='transcript_text', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='NO TRANSCRIPT from in extract_transcript_data on '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Constant(value=None))], orelse=[]), Assign(targets=[Name(id='lines', ctx=Store())], value=Call(func=Attribute(value=Name(id='transcript_text', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[])], keywords=[]), body=[Assign(targets=[Name(id='line', ctx=Store())], value=Subscript(value=Name(id='lines', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='data_dict', ctx=Store())], value=Dict(keys=[Constant(value='speaker_full'), Constant(value='speaker_name'), Constant(value='speaker_role'), Constant(value='timestamp'), Constant(value='timestamp_link'), Constant(value='dialogue')], values=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)])), If(test=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value=':')], keywords=[]), body=[Assign(targets=[Name(id='speaker_full', ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='rstrip', ctx=Load()), args=[Constant(value=' :')], keywords=[])), Assign(targets=[Subscript(value=Name(id='data_dict', ctx=Load()), slice=Constant(value='speaker_full'), ctx=Store())], value=Name(id='speaker_full', ctx=Load())), If(test=BoolOp(op=And(), values=[Compare(left=Constant(value='('), ops=[In()], comparators=[Name(id='speaker_full', ctx=Load())]), Compare(left=Constant(value=')'), ops=[In()], comparators=[Name(id='speaker_full', ctx=Load())])]), body=[Assign(targets=[Name(id='speaker_role_start', ctx=Store())], value=Call(func=Attribute(value=Name(id='speaker_full', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value='(')], keywords=[])), Assign(targets=[Name(id='speaker_role_end', ctx=Store())], value=Call(func=Attribute(value=Name(id='speaker_full', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value=')')], keywords=[])), Assign(targets=[Subscript(value=Name(id='data_dict', ctx=Load()), slice=Constant(value='speaker_role'), ctx=Store())], value=Subscript(value=Name(id='speaker_full', ctx=Load()), slice=Slice(lower=BinOp(left=Name(id='speaker_role_start', ctx=Load()), op=Add(), right=Constant(value=1)), upper=Name(id='speaker_role_end', ctx=Load())), ctx=Load())), Assign(targets=[Subscript(value=Name(id='data_dict', ctx=Load()), slice=Constant(value='speaker_name'), ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='speaker_full', ctx=Load()), slice=Slice(upper=Name(id='speaker_role_start', ctx=Load())), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Subscript(value=Name(id='data_dict', ctx=Load()), slice=Constant(value='speaker_name'), ctx=Store())], value=Name(id='speaker_full', ctx=Load()))]), If(test=Compare(left=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1)), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[])]), body=[Assign(targets=[Subscript(value=Name(id='data_dict', ctx=Load()), slice=Constant(value='dialogue'), ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='lines', ctx=Load()), slice=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1)), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]))], orelse=[])], orelse=[Assign(targets=[Tuple(elts=[Name(id='timestamp', ctx=Store()), Name(id='index', ctx=Store())], ctx=Store())], value=Call(func=Name(id='get_timestamp', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='index', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='speaker_full', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='line', ctx=Load()), slice=Slice(upper=Name(id='index', ctx=Load())), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Name(id='data_dict', ctx=Load()), slice=Constant(value='speaker_full'), ctx=Store())], value=Name(id='speaker_full', ctx=Load())), If(test=BoolOp(op=And(), values=[Compare(left=Constant(value='('), ops=[In()], comparators=[Name(id='speaker_full', ctx=Load())]), Compare(left=Constant(value=')'), ops=[In()], comparators=[Name(id='speaker_full', ctx=Load())])]), body=[Assign(targets=[Name(id='speaker_role_start', ctx=Store())], value=Call(func=Attribute(value=Name(id='speaker_full', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value='(')], keywords=[])), Assign(targets=[Name(id='speaker_role_end', ctx=Store())], value=Call(func=Attribute(value=Name(id='speaker_full', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value=')')], keywords=[])), Assign(targets=[Subscript(value=Name(id='data_dict', ctx=Load()), slice=Constant(value='speaker_role'), ctx=Store())], value=Subscript(value=Name(id='speaker_full', ctx=Load()), slice=Slice(lower=BinOp(left=Name(id='speaker_role_start', ctx=Load()), op=Add(), right=Constant(value=1)), upper=Name(id='speaker_role_end', ctx=Load())), ctx=Load())), Assign(targets=[Subscript(value=Name(id='data_dict', ctx=Load()), slice=Constant(value='speaker_name'), ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='speaker_full', ctx=Load()), slice=Slice(upper=Name(id='speaker_role_start', ctx=Load())), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Subscript(value=Name(id='data_dict', ctx=Load()), slice=Constant(value='speaker_name'), ctx=Store())], value=Name(id='speaker_full', ctx=Load()))]), Assign(targets=[Subscript(value=Name(id='data_dict', ctx=Load()), slice=Constant(value='timestamp'), ctx=Store())], value=Name(id='timestamp', ctx=Load())), Assign(targets=[Name(id='link_start', ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value='('), Name(id='index', ctx=Load())], keywords=[])), Assign(targets=[Name(id='link_end', ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='find', ctx=Load()), args=[Constant(value=')'), Name(id='link_start', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='link_start', ctx=Load()), ops=[NotEq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), Compare(left=Name(id='link_end', ctx=Load()), ops=[NotEq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))])]), body=[Assign(targets=[Subscript(value=Name(id='data_dict', ctx=Load()), slice=Constant(value='timestamp_link'), ctx=Store())], value=Subscript(value=Name(id='line', ctx=Load()), slice=Slice(lower=BinOp(left=Name(id='link_start', ctx=Load()), op=Add(), right=Constant(value=1)), upper=Name(id='link_end', ctx=Load())), ctx=Load()))], orelse=[]), If(test=Compare(left=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1)), ops=[Lt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='lines', ctx=Load())], keywords=[])]), body=[Assign(targets=[Subscript(value=Name(id='data_dict', ctx=Load()), slice=Constant(value='dialogue'), ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='lines', ctx=Load()), slice=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1)), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]))], orelse=[])], orelse=[])]), If(test=Subscript(value=Name(id='data_dict', ctx=Load()), slice=Constant(value='speaker_name'), ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='transcript_data', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='data_dict', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='transcript_data', ctx=Load()))], decorator_list=[]), FunctionDef(name='create_speaker_triples', args=arguments(posonlyargs=[], args=[arg(arg='file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Creates a list of speaker triples from a given file using extracted transcript data.\n    Works with speaker lines that end in a colon (FDA Townhalls) or have timestamp (Deutsch, PV).\n    Utilizes the extract_transcript_data function to parse the file and count occurrences of each speaker.\n    Then creates a list of triples in the format "speaker name, file_stem, count"\n    file_stem is the filename without extension, and count is the number of times the speaker appears in the file.\n\n    :param file_path: string of the path to the file to be processed.\n    :return: string of speaker triples separated by newlines.\n    ')), ImportFrom(module='primary.docwork', names=[alias(name='extract_transcript_data')], level=0), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='create_speaker_triples on '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='transcript_data', ctx=Store())], value=Call(func=Name(id='extract_transcript_data', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='transcript_data', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='NO TRANSCRIPT so create_speaker_triples is returning an empty string on '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Constant(value=''))], orelse=[]), Assign(targets=[Name(id='speaker_dict', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='entry', ctx=Store()), iter=Name(id='transcript_data', ctx=Load()), body=[Assign(targets=[Name(id='speaker_full', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='entry', ctx=Load()), slice=Constant(value='speaker_full'), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), If(test=Name(id='speaker_full', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='speaker_dict', ctx=Load()), slice=Name(id='speaker_full', ctx=Load()), ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='speaker_dict', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='speaker_full', ctx=Load()), Constant(value=0)], keywords=[]), op=Add(), right=Constant(value=1)))], orelse=[])], orelse=[]), Assign(targets=[Name(id='file_stem', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='speaker_triples', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='speaker', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='speaker_dict', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='speaker_triples', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='speaker', ctx=Load()), Name(id='file_stem', ctx=Load()), Name(id='count', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='speaker_triples', ctx=Load()), attr='sort', ctx=Load()), args=[], keywords=[keyword(arg='key', value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Tuple(elts=[UnaryOp(op=USub(), operand=Subscript(value=Name(id='x', ctx=Load()), slice=Constant(value=2), ctx=Load())), Subscript(value=Name(id='x', ctx=Load()), slice=Constant(value=0), ctx=Load())], ctx=Load())))])), Assign(targets=[Name(id='formatted_triples', ctx=Store())], value=ListComp(elt=JoinedStr(values=[FormattedValue(value=Name(id='speaker', ctx=Load()), conversion=-1), Constant(value=', '), FormattedValue(value=Name(id='file_stem', ctx=Load()), conversion=-1), Constant(value=', '), FormattedValue(value=Name(id='count', ctx=Load()), conversion=-1)]), generators=[comprehension(target=Tuple(elts=[Name(id='speaker', ctx=Store()), Name(id='file_stem', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Name(id='speaker_triples', ctx=Load()), ifs=[], is_async=0)])), Return(value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='formatted_triples', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='create_speaker_matrix', args=arguments(posonlyargs=[], args=[arg(arg='folder_path'), arg(arg='suffix_include'), arg(arg='target_file_path')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value='speaker_matrix.csv')]), body=[Expr(value=Constant(value='\n    Creates a matrix of speaker names from files in a given folder and writes it to a CSV file.\n\n    This function processes all files in the specified folder that have the specified suffix, identifies the speakers \n    and counts their occurrences. It then creates a matrix of speaker triples in the format "speaker, file_stem, count" \n    where speaker is the speaker\'s name, file_stem is the filename without extension, and count is the number of times \n    the speaker appears in the file. The matrix is written to a CSV file at the specified target file path.\n\n    :param folder_path: string of the path to the folder containing the files to be processed.\n    :param target_file_path: string of the path to the target CSV file. If no folder component is specified, the folder_path is used.\n    :param suffix_include: string of the suffix to include in the file processing.\n    :return: string of the path to the created csv file.\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='apply_to_folder'), alias(name='create_csv_matrix_from_triples')], level=0), Assign(targets=[Name(id='speaker_triples_results', ctx=Store())], value=Call(func=Name(id='apply_to_folder', ctx=Load()), args=[Name(id='create_speaker_triples', ctx=Load()), Name(id='folder_path', ctx=Load())], keywords=[keyword(arg='suffix_include', value=Name(id='suffix_include', ctx=Load()))])), Assign(targets=[Name(id='triples_text', ctx=Store())], value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Call(func=Name(id='filter', ctx=Load()), args=[Constant(value=None), Call(func=Attribute(value=Name(id='speaker_triples_results', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Name(id='target_file_path', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='target_file_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='folder_path', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='target_file_path', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='target_file_path', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='overwrite', ctx=Store())], value=Call(func=Name(id='input', ctx=Load()), args=[JoinedStr(values=[Constant(value='The file '), FormattedValue(value=Name(id='target_file_path', ctx=Load()), conversion=-1), Constant(value=' already exists. Do you want to overwrite it? (y/n): ')])], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='overwrite', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[NotEq()], comparators=[Constant(value='y')]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Operation cancelled by the user.')], keywords=[])), Return(value=Constant(value=None))], orelse=[])], orelse=[]), Return(value=Call(func=Name(id='create_csv_matrix_from_triples', ctx=Load()), args=[Name(id='triples_text', ctx=Load()), Name(id='target_file_path', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='extract_proper_names', args=arguments(posonlyargs=[], args=[arg(arg='text'), arg(arg='custom_proper_names_files'), arg(arg='bool_include_custom'), arg(arg='verbose')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False), Constant(value=False)]), body=[Expr(value=Constant(value='\n    Extract proper names from the input text based on capitalization and dictionaries.\n    \n    :param text: string containing the input text.\n    :return: list of proper names identified.\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='verbose_print')], level=0), Assign(targets=[Name(id='english_words', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Name(id='words', ctx=Load()), attr='words', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='proper_names', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='sentences', ctx=Store())], value=Call(func=Attribute(value=Name(id='nltk', ctx=Load()), attr='sent_tokenize', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[])), For(target=Name(id='sentence', ctx=Store()), iter=Name(id='sentences', ctx=Load()), body=[Assign(targets=[Name(id='words_in_sentence', ctx=Store())], value=Call(func=Attribute(value=Name(id='nltk', ctx=Load()), attr='word_tokenize', ctx=Load()), args=[Name(id='sentence', ctx=Load())], keywords=[])), Assign(targets=[Name(id='combined_name', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='word', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='words_in_sentence', ctx=Load())], keywords=[]), body=[If(test=Call(func=Attribute(value=Subscript(value=Name(id='word', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='isupper', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='combined_name', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='word', ctx=Load())], keywords=[]))], orelse=[If(test=Name(id='combined_name', ctx=Load()), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Attribute(value=Constant(value=' '), attr='join', ctx=Load()), args=[Name(id='combined_name', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Call(func=Attribute(value=Subscript(value=Name(id='combined_name', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[In()], comparators=[Name(id='english_words', ctx=Load())]), Compare(left=Name(id='i', ctx=Load()), ops=[Eq()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='combined_name', ctx=Load())], keywords=[])])]), body=[Assign(targets=[Name(id='combined_name', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='proper_names', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[])), Assign(targets=[Name(id='combined_name', ctx=Store())], value=List(elts=[], ctx=Load()))])], orelse=[])])], orelse=[]), If(test=Name(id='combined_name', ctx=Load()), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Call(func=Attribute(value=Constant(value=' '), attr='join', ctx=Load()), args=[Name(id='combined_name', ctx=Load())], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Call(func=Attribute(value=Subscript(value=Name(id='combined_name', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[NotIn()], comparators=[Name(id='english_words', ctx=Load())]), Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='combined_name', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Constant(value=1)])]), body=[Expr(value=Call(func=Attribute(value=Name(id='proper_names', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Assign(targets=[Name(id='proper_names', ctx=Store())], value=Call(func=Name(id='sorted', ctx=Load()), args=[Call(func=Name(id='set', ctx=Load()), args=[Name(id='proper_names', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='proper_names_in_custom_dict', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[])), If(test=Name(id='custom_proper_names_files', ctx=Load()), body=[For(target=Name(id='custom_list_path', ctx=Store()), iter=Name(id='custom_proper_names_files', ctx=Load()), body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='custom_list_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[For(target=Name(id='line', ctx=Store()), iter=Name(id='file', ctx=Load()), body=[Assign(targets=[Name(id='line_words', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), attr='split', ctx=Load()), args=[], keywords=[])), For(target=Name(id='word', ctx=Store()), iter=Name(id='line_words', ctx=Load()), body=[If(test=Call(func=Attribute(value=Subscript(value=Name(id='word', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='isupper', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='proper_names_in_custom_dict', ctx=Load()), attr='add', ctx=Load()), args=[Call(func=Attribute(value=Constant(value=' '), attr='join', ctx=Load()), args=[Name(id='line_words', ctx=Load())], keywords=[])], keywords=[])), Break()], orelse=[])], orelse=[])], orelse=[])])], orelse=[])], orelse=[]), Assign(targets=[Name(id='not_proper_names_path', ctx=Store())], value=Constant(value='data/capitalized_words_not_proper_names.txt')), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='not_proper_names_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='not_proper_names', ctx=Store())], value=SetComp(elt=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='line', ctx=Store()), iter=Name(id='file', ctx=Load()), ifs=[], is_async=0)]))]), Assign(targets=[Name(id='filtered_proper_names', ctx=Store())], value=ListComp(elt=Name(id='name', ctx=Load()), generators=[comprehension(target=Name(id='name', ctx=Store()), iter=Name(id='proper_names', ctx=Load()), ifs=[BoolOp(op=And(), values=[BoolOp(op=Or(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='split', ctx=Load()), args=[], keywords=[])], keywords=[]), ops=[Gt()], comparators=[Constant(value=1)]), Compare(left=Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), ops=[NotIn()], comparators=[Name(id='english_words', ctx=Load())]), BoolOp(op=And(), values=[Name(id='bool_include_custom', ctx=Load()), Compare(left=Name(id='name', ctx=Load()), ops=[In()], comparators=[Name(id='proper_names_in_custom_dict', ctx=Load())])])]), Compare(left=Name(id='name', ctx=Load()), ops=[NotIn()], comparators=[Name(id='not_proper_names', ctx=Load())])])], is_async=0)])), If(test=UnaryOp(op=Not(), operand=Name(id='bool_include_custom', ctx=Load())), body=[Assign(targets=[Name(id='filtered_proper_names', ctx=Store())], value=ListComp(elt=Name(id='name', ctx=Load()), generators=[comprehension(target=Name(id='name', ctx=Store()), iter=Name(id='filtered_proper_names', ctx=Load()), ifs=[Compare(left=Name(id='name', ctx=Load()), ops=[NotIn()], comparators=[Name(id='proper_names_in_custom_dict', ctx=Load())])], is_async=0)]))], orelse=[]), Assign(targets=[Name(id='common_words_removed', ctx=Store())], value=Call(func=Name(id='sorted', ctx=Load()), args=[BinOp(left=Call(func=Name(id='set', ctx=Load()), args=[Name(id='proper_names', ctx=Load())], keywords=[]), op=Sub(), right=Call(func=Name(id='set', ctx=Load()), args=[Name(id='filtered_proper_names', ctx=Load())], keywords=[]))], keywords=[])), Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), Constant(value='\n\nRemoved Common Words')], keywords=[])), For(target=Name(id='common_word', ctx=Store()), iter=Name(id='common_words_removed', ctx=Load()), body=[Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), Name(id='common_word', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='verbose_print', ctx=Load()), args=[Name(id='verbose', ctx=Load()), Constant(value='\n\n')], keywords=[])), Return(value=Name(id='filtered_proper_names', ctx=Load()))], decorator_list=[]), FunctionDef(name='create_proper_names_triples', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='custom_proper_names_files'), arg(arg='bool_include_custom'), arg(arg='verbose')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False), Constant(value=False)]), body=[Expr(value=Constant(value='\n    Creates a list of proper name triples from a given file using extracted text data.\n    Utilizes the extract_proper_names function to parse the file and count occurrences of each proper name.\n    Then creates a list of triples in the format "proper name, file_stem, count"\n    file_stem is the filename without extension, and count is the number of times the proper name appears in the file.\n\n    :param file_path: string of the path to the file to be processed.\n    :return: string of proper name triples separated by newlines.\n    ')), Try(body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Attribute(value=Name(id='file', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))])], handlers=[ExceptHandler(type=Name(id='FileNotFoundError', ctx=Load()), body=[Return(value=Constant(value='File not found.'))])], orelse=[], finalbody=[]), Assign(targets=[Name(id='proper_names', ctx=Store())], value=Call(func=Name(id='extract_proper_names', ctx=Load()), args=[Name(id='text', ctx=Load()), Name(id='custom_proper_names_files', ctx=Load()), Name(id='bool_include_custom', ctx=Load()), Name(id='verbose', ctx=Load())], keywords=[])), Assign(targets=[Name(id='proper_name_dict', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='proper_name', ctx=Store()), iter=Name(id='proper_names', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='proper_name_dict', ctx=Load()), slice=Name(id='proper_name', ctx=Load()), ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='proper_name_dict', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='proper_name', ctx=Load()), Constant(value=0)], keywords=[]), op=Add(), right=Constant(value=1)))], orelse=[]), Assign(targets=[Name(id='file_stem', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='proper_triples', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='proper_name', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='proper_name_dict', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='proper_triples', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='proper_name', ctx=Load()), Name(id='file_stem', ctx=Load()), Name(id='count', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='proper_triples', ctx=Load()), attr='sort', ctx=Load()), args=[], keywords=[keyword(arg='key', value=Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Tuple(elts=[UnaryOp(op=USub(), operand=Subscript(value=Name(id='x', ctx=Load()), slice=Constant(value=2), ctx=Load())), Subscript(value=Name(id='x', ctx=Load()), slice=Constant(value=0), ctx=Load())], ctx=Load())))])), Assign(targets=[Name(id='formatted_triples', ctx=Store())], value=ListComp(elt=JoinedStr(values=[FormattedValue(value=Name(id='proper_name', ctx=Load()), conversion=-1), Constant(value=', '), FormattedValue(value=Name(id='file_stem', ctx=Load()), conversion=-1), Constant(value=', '), FormattedValue(value=Name(id='count', ctx=Load()), conversion=-1)]), generators=[comprehension(target=Tuple(elts=[Name(id='proper_name', ctx=Store()), Name(id='file_stem', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Name(id='proper_triples', ctx=Load()), ifs=[], is_async=0)])), Return(value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='formatted_triples', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='print_proper_names', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='custom_proper_names_files'), arg(arg='bool_include_custom'), arg(arg='verbose')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=False), Constant(value=False)]), body=[Assign(targets=[Name(id='proper_names_output', ctx=Store())], value=Call(func=Name(id='create_proper_names_triples', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='custom_proper_names_files', ctx=Load()), Name(id='bool_include_custom', ctx=Load()), Name(id='verbose', ctx=Load())], keywords=[])), Assign(targets=[Name(id='proper_names_list', ctx=Store())], value=ListComp(elt=Subscript(value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=',')], keywords=[]), slice=Constant(value=0), ctx=Load()), generators=[comprehension(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Name(id='proper_names_output', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[]), ifs=[], is_async=0)])), Assign(targets=[Name(id='proper_names_list_sorted', ctx=Store())], value=Call(func=Name(id='sorted', ctx=Load()), args=[Name(id='proper_names_list', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='\n\nFiltered Proper Names')], keywords=[])), For(target=Name(id='name', ctx=Store()), iter=Name(id='proper_names_list_sorted', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='name', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Total proper names: '), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='proper_names_list_sorted', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[]))], decorator_list=[])], type_ignores=[])

Module(body=[Import(names=[alias(name='os')]), Import(names=[alias(name='re')]), Import(names=[alias(name='csv')]), Import(names=[alias(name='subprocess')]), Import(names=[alias(name='pyperclip')]), Import(names=[alias(name='pyautogui')]), Import(names=[alias(name='time')]), ImportFrom(module='primary.fileops', names=[alias(name='*')], level=0), Import(names=[alias(name='warnings')]), Assign(targets=[Attribute(value=Name(id='warnings', ctx=Load()), attr='formatwarning', ctx=Store())], value=Name(id='custom_formatwarning', ctx=Load())), FunctionDef(name='get_blocks_from_file', args=arguments(posonlyargs=[], args=[arg(arg='qa_file_path'), arg(arg='verbose')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='\n    Extracts and validates blocks of text from a file.\n\n    :param qa_file_path: string of the path to the file to be read.\n    :param verbose: boolean, if True, prints verbose messages. Default is False.\n    :return: list of valid blocks from the file.\n        ')), ImportFrom(module='primary.fileops', names=[alias(name='get_heading'), alias(name='verbose_print')], level=0), Assign(targets=[Name(id='block_delimiter', ctx=Store())], value=Constant(value='\n\n')), Assign(targets=[Name(id='qa_text', ctx=Store())], value=Call(func=Name(id='get_heading', ctx=Load()), args=[Name(id='qa_file_path', ctx=Load()), Constant(value='### qa')], keywords=[])), Assign(targets=[Name(id='qa_text', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[Constant(value='^#.*\\n?'), Constant(value=''), Name(id='qa_text', ctx=Load())], keywords=[keyword(arg='flags', value=Attribute(value=Name(id='re', ctx=Load()), attr='MULTILINE', ctx=Load()))])), Assign(targets=[Name(id='qa_text', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='sub', ctx=Load()), args=[Constant(value='\\n{3,}'), Constant(value='\n\n'), Name(id='qa_text', ctx=Load())], keywords=[])), Assign(targets=[Name(id='blocks_list', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='blocks', ctx=Store())], value=Call(func=Attribute(value=Name(id='qa_text', ctx=Load()), attr='split', ctx=Load()), args=[Name(id='block_delimiter', ctx=Load())], keywords=[])), For(target=Name(id='block', ctx=Store()), iter=Name(id='blocks', ctx=Load()), body=[If(test=Call(func=Attribute(value=Name(id='block', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='blocks_list', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='block', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='blocks_list', ctx=Load()))], decorator_list=[]), FunctionDef(name='get_field_value', args=arguments(posonlyargs=[], args=[arg(arg='block'), arg(arg='field')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Extracts the content of a specified field from a block of text.\n\n    :param block: string of the block of text to be processed.\n    :param field: string of the field to be extracted from the block.\n    :return: the content of the field in its appropriate data type, or None if the field is not found.\n    ')), Assign(targets=[Name(id='lines', ctx=Store())], value=Call(func=Attribute(value=Name(id='block', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[])), For(target=Name(id='line', ctx=Store()), iter=Name(id='lines', ctx=Load()), body=[If(test=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='startswith', ctx=Load()), args=[BinOp(left=Name(id='field', ctx=Load()), op=Add(), right=Constant(value=':'))], keywords=[]), body=[Assign(targets=[Name(id='field_content', ctx=Store())], value=Subscript(value=Name(id='line', ctx=Load()), slice=Slice(lower=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='field', ctx=Load())], keywords=[]), op=Add(), right=Constant(value=2))), ctx=Load())), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='field', ctx=Load()), ops=[Eq()], comparators=[Constant(value='STARS')]), Compare(left=Name(id='field', ctx=Load()), ops=[Eq()], comparators=[Constant(value='TRANSCRIPT START POSITION')]), Compare(left=Name(id='field', ctx=Load()), ops=[Eq()], comparators=[Constant(value='TRANSCRIPT END POSITION')])]), body=[Return(value=Call(func=Name(id='int', ctx=Load()), args=[Name(id='field_content', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='field', ctx=Load()), ops=[Eq()], comparators=[Constant(value='TOPICS')]), body=[Return(value=ListComp(elt=Call(func=Attribute(value=Name(id='topic', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='topic', ctx=Store()), iter=Call(func=Attribute(value=Name(id='field_content', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=',')], keywords=[]), ifs=[], is_async=0)]))], orelse=[Return(value=Name(id='field_content', ctx=Load()))])])], orelse=[])], orelse=[]), Return(value=Constant(value=None))], decorator_list=[]), FunctionDef(name='get_all_fields_dict', args=arguments(posonlyargs=[], args=[arg(arg='block')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Extracts all fields and their contents from a block of text.\n\n    :param block: string of the block of text to be processed.\n    :return: dictionary of fields and their contents in their appropriate data types.\n    ')), Assign(targets=[Name(id='lines', ctx=Store())], value=Call(func=Attribute(value=Name(id='block', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[])), Assign(targets=[Name(id='fields_dict', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='line', ctx=Store()), iter=Name(id='lines', ctx=Load()), body=[Assign(targets=[Name(id='parts', ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=':'), Constant(value=1)], keywords=[])), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='parts', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=2)]), body=[Assign(targets=[Tuple(elts=[Name(id='field', ctx=Store()), Name(id='field_content', ctx=Store())], ctx=Store())], value=Name(id='parts', ctx=Load())), Assign(targets=[Name(id='field', ctx=Store())], value=Call(func=Attribute(value=Name(id='field', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='field_content', ctx=Store())], value=Call(func=Attribute(value=Name(id='field_content', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='field', ctx=Load()), ops=[Eq()], comparators=[Constant(value='STARS')]), body=[Assign(targets=[Subscript(value=Name(id='fields_dict', ctx=Load()), slice=Name(id='field', ctx=Load()), ctx=Store())], value=Name(id='field_content', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='field', ctx=Load()), ops=[Eq()], comparators=[Constant(value='TOPICS')]), body=[Assign(targets=[Subscript(value=Name(id='fields_dict', ctx=Load()), slice=Name(id='field', ctx=Load()), ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='topic', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='topic', ctx=Store()), iter=Call(func=Attribute(value=Name(id='field_content', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=',')], keywords=[]), ifs=[], is_async=0)]))], orelse=[Assign(targets=[Subscript(value=Name(id='fields_dict', ctx=Load()), slice=Name(id='field', ctx=Load()), ctx=Store())], value=Name(id='field_content', ctx=Load()))])])], orelse=[])], orelse=[]), Return(value=Name(id='fields_dict', ctx=Load()))], decorator_list=[]), FunctionDef(name='count_blocks', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='heading')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='## content')]), body=[Expr(value=Constant(value='\n    Counts the number of blocks in a specific section of a file, skipping comment lines.\n\n    :param file_path: string of the path to the file to be processed.\n    :param heading: string of the markdown heading to search for. Default is "## content".\n    :return: integer representing the total number of blocks found.\n    ')), Assign(targets=[Name(id='content', ctx=Store())], value=Call(func=Name(id='get_heading', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='heading', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='content', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Return(value=Constant(value=0))], orelse=[]), Assign(targets=[Name(id='content_lines', ctx=Store())], value=ListComp(elt=Name(id='line', ctx=Load()), generators=[comprehension(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Name(id='content', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[]), ifs=[UnaryOp(op=Not(), operand=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='lstrip', ctx=Load()), args=[], keywords=[]), attr='startswith', ctx=Load()), args=[Constant(value='#')], keywords=[]))], is_async=0)])), Assign(targets=[Name(id='content_without_comments', ctx=Store())], value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='content_lines', ctx=Load())], keywords=[])), Assign(targets=[Name(id='blocks', ctx=Store())], value=Call(func=Attribute(value=Name(id='content_without_comments', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n\n')], keywords=[])), Assign(targets=[Name(id='total_blocks', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Constant(value=1), generators=[comprehension(target=Name(id='block', ctx=Store()), iter=Name(id='blocks', ctx=Load()), ifs=[Call(func=Attribute(value=Name(id='block', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])], is_async=0)])], keywords=[])), Return(value=Name(id='total_blocks', ctx=Load()))], decorator_list=[]), FunctionDef(name='extract_topic_counts_triples', args=arguments(posonlyargs=[], args=[arg(arg='qa_file_path'), arg(arg='verbose')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='\n    Extracts topics from QA blocks in a file and counts their occurrences. \n\n    :param qa_file_path: string of the path to the QA file.\n    :param verbose: boolean, if True, prints additional information during execution. Default is False.\n    :return: string of CSV lines with each line in the format "topic, file_stem, count".\n    ')), Assign(targets=[Name(id='blocks', ctx=Store())], value=Call(func=Name(id='get_blocks_from_file', ctx=Load()), args=[Name(id='qa_file_path', ctx=Load()), Name(id='verbose', ctx=Load())], keywords=[])), Assign(targets=[Name(id='topic_dict', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='block', ctx=Store()), iter=Name(id='blocks', ctx=Load()), body=[Assign(targets=[Name(id='topics', ctx=Store())], value=Call(func=Name(id='get_field_value', ctx=Load()), args=[Name(id='block', ctx=Load()), Constant(value='TOPICS')], keywords=[])), If(test=Name(id='topics', ctx=Load()), body=[For(target=Name(id='topic', ctx=Store()), iter=Name(id='topics', ctx=Load()), body=[If(test=Name(id='topic', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='topic_dict', ctx=Load()), slice=Name(id='topic', ctx=Load()), ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='topic_dict', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='topic', ctx=Load()), Constant(value=0)], keywords=[]), op=Add(), right=Constant(value=1)))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value='Warning: TOPIC is blank and should have been previously validated before calling this function for file '), FormattedValue(value=Name(id='qa_file_path', ctx=Load()), conversion=-1), Constant(value='\n'), FormattedValue(value=Name(id='block', ctx=Load()), conversion=-1), Constant(value='\n\n')])], keywords=[]))])], orelse=[])], orelse=[])], orelse=[]), Assign(targets=[Name(id='file_stem', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='qa_file_path', ctx=Load())], keywords=[])], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='topic_counts_csv_lines', ctx=Store())], value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[ListComp(elt=JoinedStr(values=[FormattedValue(value=Name(id='topic', ctx=Load()), conversion=-1), Constant(value=', '), FormattedValue(value=Name(id='file_stem', ctx=Load()), conversion=-1), Constant(value=', '), FormattedValue(value=Name(id='count', ctx=Load()), conversion=-1)]), generators=[comprehension(target=Tuple(elts=[Name(id='topic', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='topic_dict', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[])), Return(value=Name(id='topic_counts_csv_lines', ctx=Load()))], decorator_list=[]), FunctionDef(name='create_topics_matrix', args=arguments(posonlyargs=[], args=[arg(arg='folder_paths'), arg(arg='target_file_path'), arg(arg='suffixpat_include')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='matrix_topics.csv'), Constant(value='_qafixed')]), body=[Expr(value=Constant(value='\n    Collects topics from files in specified folders and creates a CSV matrix file at the target file path.\n\n    :param folder_paths: list of strings of folder paths to search for files.\n    :param target_file_path: string of the path where the resulting CSV file will be created. If no folder is provided in the path, the parent folder of the first folder in the folder_paths list will be used.\n    :param suffix_include: string of the suffix to include in file search. Default is "_qafixed".\n    :return: string of the path to the created csv file.\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='apply_to_folder'), alias(name='create_csv_matrix_from_triples')], level=0), Assign(targets=[Name(id='all_topics_results', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='folder_path', ctx=Store()), iter=Name(id='folder_paths', ctx=Load()), body=[Assign(targets=[Name(id='topics_results', ctx=Store())], value=Call(func=Name(id='apply_to_folder', ctx=Load()), args=[Name(id='extract_topic_counts_triples', ctx=Load()), Name(id='folder_path', ctx=Load())], keywords=[keyword(arg='suffixpat_include', value=Name(id='suffixpat_include', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='all_topics_results', ctx=Load()), attr='extend', ctx=Load()), args=[Call(func=Attribute(value=Name(id='topics_results', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='triples_text', ctx=Store())], value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='all_topics_results', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Name(id='target_file_path', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='parent_folder', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Subscript(value=Name(id='folder_paths', ctx=Load()), slice=Constant(value=0), ctx=Load())], keywords=[])), Assign(targets=[Name(id='target_file_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='parent_folder', ctx=Load()), Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='target_file_path', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='create_csv_matrix_from_triples', ctx=Load()), args=[Name(id='triples_text', ctx=Load()), Name(id='target_file_path', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='change_topic_in_file', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='find_topic'), arg(arg='replace_topic')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Replaces a specified topic with another in a single file.\n\n    :param file_path: string of the file path to process.\n    :param find_topic: string of the topic to find.\n    :param replace_topic: string of the topic to use as a replacement.\n    :return: tuple of (int, int) representing (replacements_in_file, total_replacements)\n    ')), If(test=Compare(left=Name(id='find_topic', ctx=Load()), ops=[Eq()], comparators=[Name(id='replace_topic', ctx=Load())]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value="Aborting: find_topic '"), FormattedValue(value=Name(id='find_topic', ctx=Load()), conversion=-1), Constant(value="' and replace_topic '"), FormattedValue(value=Name(id='replace_topic', ctx=Load()), conversion=-1), Constant(value="' are the same.")])], keywords=[])), Return(value=Constant(value=0))], orelse=[]), ImportFrom(module='primary.fileops', names=[alias(name='read_metadata_and_content'), alias(name='write_metadata_and_content')], level=0), Assign(targets=[Tuple(elts=[Name(id='metadata', ctx=Store()), Name(id='content', ctx=Store())], ctx=Store())], value=Call(func=Name(id='read_metadata_and_content', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='blocks', ctx=Store())], value=Call(func=Name(id='get_blocks_from_file', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='content_lines', ctx=Store())], value=Call(func=Attribute(value=Name(id='content', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[])), Assign(targets=[Name(id='replacements_in_file', ctx=Store())], value=Constant(value=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='line', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='content_lines', ctx=Load())], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='TOPICS:')], keywords=[]), body=[Assign(targets=[Name(id='topics', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Subscript(value=Name(id='line', ctx=Load()), slice=Slice(lower=Call(func=Name(id='len', ctx=Load()), args=[Constant(value='TOPICS:')], keywords=[])), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), attr='split', ctx=Load()), args=[Constant(value=', ')], keywords=[])), If(test=Compare(left=Name(id='find_topic', ctx=Load()), ops=[In()], comparators=[Name(id='topics', ctx=Load())]), body=[Assign(targets=[Name(id='topics', ctx=Store())], value=ListComp(elt=IfExp(test=Compare(left=Name(id='topic', ctx=Load()), ops=[Eq()], comparators=[Name(id='find_topic', ctx=Load())]), body=Name(id='replace_topic', ctx=Load()), orelse=Name(id='topic', ctx=Load())), generators=[comprehension(target=Name(id='topic', ctx=Store()), iter=Name(id='topics', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='new_line', ctx=Store())], value=BinOp(left=Constant(value='TOPICS: '), op=Add(), right=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Name(id='topics', ctx=Load())], keywords=[]))), Assign(targets=[Subscript(value=Name(id='content_lines', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Store())], value=Name(id='new_line', ctx=Load())), AugAssign(target=Name(id='replacements_in_file', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='topics', ctx=Load()), attr='count', ctx=Load()), args=[Name(id='replace_topic', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='replacements_in_file', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='new_content', ctx=Store())], value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='content_lines', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='write_metadata_and_content', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='metadata', ctx=Load()), Name(id='new_content', ctx=Load())], keywords=[keyword(arg='overwrite', value=Constant(value='yes'))]))], orelse=[]), Return(value=Name(id='replacements_in_file', ctx=Load()))], decorator_list=[]), FunctionDef(name='change_topic_in_folders', args=arguments(posonlyargs=[], args=[arg(arg='folder_paths'), arg(arg='find_topic'), arg(arg='replace_topic'), arg(arg='suffixpat_include')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='_qafixed')]), body=[Expr(value=Constant(value='\n    Replaces a specified topic with another across files in given folders.\n\n    :param folder_paths: list of strings of folder paths to search for files.\n    :param find_topic: string of the topic to find.\n    :param replace_topic: string of the topic to use as a replacement.\n    :param suffix_include: string of the suffix to include in file search.\n    :return: None.\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='apply_to_folder')], level=0), Assign(targets=[Name(id='total_replacements', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='files_with_replacements', ctx=Store())], value=List(elts=[], ctx=Load())), FunctionDef(name='process_file', args=arguments(posonlyargs=[], args=[arg(arg='file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Nonlocal(names=['total_replacements', 'files_with_replacements']), Assign(targets=[Name(id='replacements_in_file', ctx=Store())], value=Call(func=Name(id='change_topic_in_file', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='find_topic', ctx=Load()), Name(id='replace_topic', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='replacements_in_file', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[AugAssign(target=Name(id='total_replacements', ctx=Store()), op=Add(), value=Name(id='replacements_in_file', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='files_with_replacements', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Name(id='file_path', ctx=Load()), Name(id='replacements_in_file', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), For(target=Name(id='folder_path', ctx=Store()), iter=Name(id='folder_paths', ctx=Load()), body=[Expr(value=Call(func=Name(id='apply_to_folder', ctx=Load()), args=[Name(id='process_file', ctx=Load()), Name(id='folder_path', ctx=Load())], keywords=[keyword(arg='suffixpat_include', value=Name(id='suffixpat_include', ctx=Load()))]))], orelse=[]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Total replacements done: '), FormattedValue(value=Name(id='total_replacements', ctx=Load()), conversion=-1)])], keywords=[])), For(target=Tuple(elts=[Name(id='file_path', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Name(id='files_with_replacements', ctx=Load()), body=[Assign(targets=[Name(id='file_name', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='count', ctx=Load()), conversion=-1), Constant(value=' '), FormattedValue(value=Name(id='file_name', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='review_singlet_topic_SONNET', args=arguments(posonlyargs=[], args=[arg(arg='folder_paths'), arg(arg='matrix_csv_file_path'), arg(arg='starting_letter')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='a')]), body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='matrix_csv_file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='csvfile', ctx=Store()))], body=[Assign(targets=[Name(id='reader', ctx=Store())], value=Call(func=Attribute(value=Name(id='csv', ctx=Load()), attr='DictReader', ctx=Load()), args=[Name(id='csvfile', ctx=Load())], keywords=[])), Assign(targets=[Name(id='topics', ctx=Store())], value=DictComp(key=Subscript(value=Name(id='row', ctx=Load()), slice=Constant(value='row title'), ctx=Load()), value=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='int', ctx=Load()), args=[Name(id='count', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='count', ctx=Store()), iter=Call(func=Attribute(value=Name(id='row', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='count', ctx=Load()), attr='isdigit', ctx=Load()), args=[], keywords=[])], is_async=0)])], keywords=[]), generators=[comprehension(target=Name(id='row', ctx=Store()), iter=Name(id='reader', ctx=Load()), ifs=[], is_async=0)]))]), Assign(targets=[Name(id='singlet_topics', ctx=Store())], value=DictComp(key=Name(id='topic', ctx=Load()), value=Constant(value=None), generators=[comprehension(target=Tuple(elts=[Name(id='topic', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='topics', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[BoolOp(op=And(), values=[Compare(left=Name(id='count', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='topic', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]), attr='startswith', ctx=Load()), args=[Name(id='starting_letter', ctx=Load())], keywords=[])])], is_async=0)])), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='matrix_csv_file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='csvfile', ctx=Store()))], body=[Assign(targets=[Name(id='reader', ctx=Store())], value=Call(func=Attribute(value=Name(id='csv', ctx=Load()), attr='DictReader', ctx=Load()), args=[Name(id='csvfile', ctx=Load())], keywords=[])), For(target=Name(id='topic', ctx=Store()), iter=Call(func=Attribute(value=Name(id='singlet_topics', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='csvfile', ctx=Load()), attr='seek', ctx=Load()), args=[Constant(value=0)], keywords=[])), Assign(targets=[Name(id='file_with_topic', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[GeneratorExp(elt=Name(id='col', ctx=Load()), generators=[comprehension(target=Name(id='col', ctx=Store()), iter=Subscript(value=Attribute(value=Name(id='reader', ctx=Load()), attr='fieldnames', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()), ifs=[Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Call(func=Name(id='int', ctx=Load()), args=[Subscript(value=Name(id='row', ctx=Load()), slice=Name(id='col', ctx=Load()), ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Constant(value=0)]), generators=[comprehension(target=Name(id='row', ctx=Store()), iter=Name(id='reader', ctx=Load()), ifs=[Compare(left=Subscript(value=Name(id='row', ctx=Load()), slice=Constant(value='row title'), ctx=Load()), ops=[Eq()], comparators=[Name(id='topic', ctx=Load())])], is_async=0)])], keywords=[])], is_async=0)]), Constant(value=None)], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='csvfile', ctx=Load()), attr='seek', ctx=Load()), args=[Constant(value=0)], keywords=[])), If(test=Name(id='file_with_topic', ctx=Load()), body=[Assign(targets=[Name(id='file_path', ctx=Store())], value=Constant(value=None)), For(target=Name(id='folder', ctx=Store()), iter=Name(id='folder_paths', ctx=Load()), body=[Assign(targets=[Name(id='potential_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='folder', ctx=Load()), Name(id='file_with_topic', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='potential_path', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='file_path', ctx=Store())], value=Name(id='potential_path', ctx=Load())), Break()], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='file_path', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value="Could not find file '"), FormattedValue(value=Name(id='file_with_topic', ctx=Load()), conversion=-1), Constant(value="' in any of the provided folders.")])], keywords=[])), Continue()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='subprocess', ctx=Load()), attr='run', ctx=Load()), args=[List(elts=[Constant(value='code'), Constant(value='--goto'), JoinedStr(values=[FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value=':1')]), Constant(value='--search'), Name(id='topic', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='action', ctx=Store())], value=Call(func=Name(id='input', ctx=Load()), args=[JoinedStr(values=[Constant(value="Topic '"), FormattedValue(value=Name(id='topic', ctx=Load()), conversion=-1), Constant(value="' found in "), FormattedValue(value=Name(id='file_with_topic', ctx=Load()), conversion=-1), Constant(value=". Enter 'DEL' to delete, press Enter to skip, or enter a new topic name to change: ")])], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='action', ctx=Load()), attr='upper', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Constant(value='DEL')]), body=[Expr(value=Call(func=Name(id='change_topic_in_file', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='topic', ctx=Load()), Constant(value='')], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value="Topic '"), FormattedValue(value=Name(id='topic', ctx=Load()), conversion=-1), Constant(value="' deleted from "), FormattedValue(value=Name(id='file_with_topic', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[If(test=BoolOp(op=And(), values=[Name(id='action', ctx=Load()), Compare(left=Call(func=Attribute(value=Name(id='action', ctx=Load()), attr='upper', ctx=Load()), args=[], keywords=[]), ops=[NotEq()], comparators=[Constant(value='d')])]), body=[Expr(value=Call(func=Name(id='change_topic_in_file', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='topic', ctx=Load()), Name(id='action', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value="Topic '"), FormattedValue(value=Name(id='topic', ctx=Load()), conversion=-1), Constant(value="' changed to '"), FormattedValue(value=Name(id='action', ctx=Load()), conversion=-1), Constant(value="' in "), FormattedValue(value=Name(id='file_with_topic', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value="Skipped topic '"), FormattedValue(value=Name(id='topic', ctx=Load()), conversion=-1), Constant(value="' in "), FormattedValue(value=Name(id='file_with_topic', ctx=Load()), conversion=-1)])], keywords=[]))])])], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value="Could not find file for topic '"), FormattedValue(value=Name(id='topic', ctx=Load()), conversion=-1), Constant(value="'")])], keywords=[]))])], orelse=[])]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Review of singlet topics completed.')], keywords=[]))], decorator_list=[]), FunctionDef(name='review_singlet_topic', args=arguments(posonlyargs=[], args=[arg(arg='folder_paths'), arg(arg='matrix_csv_file_path'), arg(arg='starting_letter')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='a')]), body=[Import(names=[alias(name='os')]), Import(names=[alias(name='csv')]), Import(names=[alias(name='subprocess')]), Assign(targets=[Name(id='topic_counts', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='topic_file_stems', ctx=Store())], value=Dict(keys=[], values=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Reading topics from CSV file: '), FormattedValue(value=Name(id='matrix_csv_file_path', ctx=Load()), conversion=-1)])], keywords=[])), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='matrix_csv_file_path', ctx=Load())], keywords=[keyword(arg='newline', value=Constant(value='')), keyword(arg='encoding', value=Constant(value='utf-8'))]), optional_vars=Name(id='csvfile', ctx=Store()))], body=[Assign(targets=[Name(id='csvreader', ctx=Store())], value=Call(func=Attribute(value=Name(id='csv', ctx=Load()), attr='reader', ctx=Load()), args=[Name(id='csvfile', ctx=Load())], keywords=[])), Assign(targets=[Name(id='headers', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='csvreader', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='headers', ctx=Load())), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='CSV file is empty or missing headers.')], keywords=[])), Return()], orelse=[]), Assign(targets=[Name(id='file_stems', ctx=Store())], value=Subscript(value=Name(id='headers', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load())), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='File stems extracted: '), FormattedValue(value=Name(id='file_stems', ctx=Load()), conversion=-1)])], keywords=[])), For(target=Name(id='row', ctx=Store()), iter=Name(id='csvreader', ctx=Load()), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='row', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Constant(value=2)]), body=[Continue()], orelse=[]), Assign(targets=[Name(id='topic', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='row', ctx=Load()), slice=Constant(value=0), ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='counts', ctx=Store())], value=ListComp(elt=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='count', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='count', ctx=Store()), iter=Subscript(value=Name(id='row', ctx=Load()), slice=Slice(lower=Constant(value=1)), ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='total_count', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[Name(id='counts', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='topic_counts', ctx=Load()), slice=Name(id='topic', ctx=Load()), ctx=Store())], value=Name(id='total_count', ctx=Load())), Assign(targets=[Name(id='file_indices', ctx=Store())], value=ListComp(elt=Name(id='i', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='counts', ctx=Load())], keywords=[]), ifs=[Compare(left=Name(id='count', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)])], is_async=0)])), If(test=Compare(left=Name(id='topic', ctx=Load()), ops=[NotIn()], comparators=[Name(id='topic_file_stems', ctx=Load())]), body=[Assign(targets=[Subscript(value=Name(id='topic_file_stems', ctx=Load()), slice=Name(id='topic', ctx=Load()), ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[]), For(target=Name(id='idx', ctx=Store()), iter=Name(id='file_indices', ctx=Load()), body=[Assign(targets=[Name(id='file_stem', ctx=Store())], value=Subscript(value=Name(id='file_stems', ctx=Load()), slice=Name(id='idx', ctx=Load()), ctx=Load())), Expr(value=Call(func=Attribute(value=Subscript(value=Name(id='topic_file_stems', ctx=Load()), slice=Name(id='topic', ctx=Load()), ctx=Load()), attr='append', ctx=Load()), args=[Name(id='file_stem', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Total topics read: '), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='topic_counts', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='file_stem_to_path', ctx=Store())], value=Dict(keys=[], values=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Building file stem to path mapping...')], keywords=[])), For(target=Name(id='folder_path', ctx=Store()), iter=Name(id='folder_paths', ctx=Load()), body=[For(target=Tuple(elts=[Name(id='root', ctx=Store()), Name(id='dirs', ctx=Store()), Name(id='files', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='walk', ctx=Load()), args=[Name(id='folder_path', ctx=Load())], keywords=[]), body=[For(target=Name(id='filename', ctx=Store()), iter=Name(id='files', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='stem', ctx=Store()), Name(id='ext', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Name(id='filename', ctx=Load())], keywords=[])), Assign(targets=[Name(id='full_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='root', ctx=Load()), Name(id='filename', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='stem', ctx=Load()), ops=[NotIn()], comparators=[Name(id='file_stem_to_path', ctx=Load())]), body=[Assign(targets=[Subscript(value=Name(id='file_stem_to_path', ctx=Load()), slice=Name(id='stem', ctx=Load()), ctx=Store())], value=Name(id='full_path', ctx=Load()))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), Assign(targets=[Name(id='matching_topics', ctx=Store())], value=ListComp(elt=Name(id='topic', ctx=Load()), generators=[comprehension(target=Name(id='topic', ctx=Store()), iter=Name(id='topic_counts', ctx=Load()), ifs=[BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='topic_counts', ctx=Load()), slice=Name(id='topic', ctx=Load()), ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), Call(func=Attribute(value=Name(id='topic', ctx=Load()), attr='startswith', ctx=Load()), args=[Name(id='starting_letter', ctx=Load())], keywords=[])])], is_async=0)])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value="Total topics with count == 1 and starting with '"), FormattedValue(value=Name(id='starting_letter', ctx=Load()), conversion=-1), Constant(value="': "), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='matching_topics', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='matching_topics', ctx=Load())), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='No topics to process.')], keywords=[])), Return()], orelse=[]), For(target=Name(id='topic', ctx=Store()), iter=Call(func=Name(id='sorted', ctx=Load()), args=[Name(id='matching_topics', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='total_count', ctx=Store())], value=Subscript(value=Name(id='topic_counts', ctx=Load()), slice=Name(id='topic', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='file_stems', ctx=Store())], value=Subscript(value=Name(id='topic_file_stems', ctx=Load()), slice=Name(id='topic', ctx=Load()), ctx=Load())), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='file_stems', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Constant(value=1)]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value="Warning: Topic '"), FormattedValue(value=Name(id='topic', ctx=Load()), conversion=-1), Constant(value="' occurs in multiple files but total count is 1.")])], keywords=[])), Continue()], orelse=[]), Assign(targets=[Name(id='file_stem', ctx=Store())], value=Subscript(value=Name(id='file_stems', ctx=Load()), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='file_path', ctx=Store())], value=Call(func=Attribute(value=Name(id='file_stem_to_path', ctx=Load()), attr='get', ctx=Load()), args=[Name(id='file_stem', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Name(id='file_path', ctx=Load())), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value="File for file stem '"), FormattedValue(value=Name(id='file_stem', ctx=Load()), conversion=-1), Constant(value="' not found.")])], keywords=[])), Continue()], orelse=[]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value="\nProcessing topic '"), FormattedValue(value=Name(id='topic', ctx=Load()), conversion=-1), Constant(value="' in file '"), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value="'")])], keywords=[])), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='subprocess', ctx=Load()), attr='run', ctx=Load()), args=[List(elts=[Constant(value='code'), Name(id='file_path', ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pyperclip', ctx=Load()), attr='copy', ctx=Load()), args=[Name(id='topic', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='time', ctx=Load()), attr='sleep', ctx=Load()), args=[Constant(value=1)], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pyautogui', ctx=Load()), attr='hotkey', ctx=Load()), args=[Constant(value='command'), Constant(value='f')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pyautogui', ctx=Load()), attr='hotkey', ctx=Load()), args=[Constant(value='command'), Constant(value='v')], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Error opening file in VS Code: '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[])), Continue()])], orelse=[], finalbody=[]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value="Opened file '"), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value="' in VS Code. Please search for topic '"), FormattedValue(value=Name(id='topic', ctx=Load()), conversion=-1), Constant(value="' using the search tool.")])], keywords=[])), Assign(targets=[Name(id='user_input', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='input', ctx=Load()), args=[Constant(value="Type 'DEL' to delete the topic, type new topic to replace, or press Enter to keep: ")], keywords=[]), attr='strip', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='user_input', ctx=Load()), attr='upper', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Constant(value='DEL')]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value="Deleting topic '"), FormattedValue(value=Name(id='topic', ctx=Load()), conversion=-1), Constant(value="' in file '"), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value="'")])], keywords=[])), Expr(value=Call(func=Name(id='change_topic_in_file', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='topic', ctx=Load()), Constant(value='')], keywords=[]))], orelse=[If(test=Compare(left=Name(id='user_input', ctx=Load()), ops=[Eq()], comparators=[Constant(value='')]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value="Keeping topic '"), FormattedValue(value=Name(id='topic', ctx=Load()), conversion=-1), Constant(value="'")])], keywords=[]))], orelse=[Assign(targets=[Name(id='new_topic', ctx=Store())], value=Name(id='user_input', ctx=Load())), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value="Replacing topic '"), FormattedValue(value=Name(id='topic', ctx=Load()), conversion=-1), Constant(value="' with '"), FormattedValue(value=Name(id='new_topic', ctx=Load()), conversion=-1), Constant(value="' in file '"), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value="'")])], keywords=[])), Expr(value=Call(func=Name(id='change_topic_in_file', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='topic', ctx=Load()), Name(id='new_topic', ctx=Load())], keywords=[]))])])], orelse=[])], decorator_list=[])], type_ignores=[])

Module(body=[Import(names=[alias(name='os')]), Import(names=[alias(name='re')]), ImportFrom(module='collections', names=[alias(name='defaultdict')], level=0), ImportFrom(module='primary.fileops', names=[alias(name='*')], level=0), Import(names=[alias(name='warnings')]), Assign(targets=[Attribute(value=Name(id='warnings', ctx=Load()), attr='formatwarning', ctx=Store())], value=Name(id='custom_formatwarning', ctx=Load())), FunctionDef(name='validate_stars', args=arguments(posonlyargs=[], args=[arg(arg='stars_str')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='stars_str', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), body=[Return(value=Constant(value=True))], orelse=[]), Try(body=[Assign(targets=[Name(id='stars', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Name(id='stars_str', ctx=Load())], keywords=[])), Return(value=Constant(value=True))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Return(value=Constant(value=False))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='validate_topics', args=arguments(posonlyargs=[], args=[arg(arg='topics_str')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Constant(value=',  '), ops=[In()], comparators=[Name(id='topics_str', ctx=Load())]), Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='search', ctx=Load()), args=[Constant(value=',(?![ ])'), Name(id='topics_str', ctx=Load())], keywords=[])]), body=[Return(value=Constant(value=False))], orelse=[]), Assign(targets=[Name(id='topics', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=',\\s*'), Call(func=Attribute(value=Name(id='topics_str', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])], keywords=[])), Return(value=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Call(func=Attribute(value=Name(id='topic', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), ops=[Eq()], comparators=[Name(id='topic', ctx=Load())]), generators=[comprehension(target=Name(id='topic', ctx=Store()), iter=Name(id='topics', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], decorator_list=[]), FunctionDef(name='validate_qa_blocks', args=arguments(posonlyargs=[], args=[arg(arg='blocks_list'), arg(arg='required_fields'), arg(arg='custom_validators')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n    Validates the structure and content of QA blocks against required fields.\n\n    :param blocks_list: List of QA blocks, each block is a string of text representing a QA entry.\n    :param required_fields: List of required field names.\n    :param custom_validators: Dictionary of field names and their corresponding validation functions (default: None).\n    :return: Integer representing the number of valid blocks if all are valid, or the negative count of invalid blocks.\n    ')), Assign(targets=[Name(id='custom_validators', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='custom_validators', ctx=Load()), Dict(keys=[], values=[])])), Assign(targets=[Name(id='invalid_blocks_count', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='total_blocks', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='blocks_list', ctx=Load())], keywords=[])), For(target=Name(id='block', ctx=Store()), iter=Name(id='blocks_list', ctx=Load()), body=[Assign(targets=[Name(id='block_fields', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='block_errors', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='block', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[]), body=[If(test=Name(id='line', ctx=Load()), body=[Try(body=[Assign(targets=[Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=':'), Constant(value=1)], keywords=[])), Assign(targets=[Subscript(value=Name(id='block_fields', ctx=Load()), slice=Call(func=Attribute(value=Name(id='key', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='block_errors', ctx=Load()), attr='append', ctx=Load()), args=[JoinedStr(values=[Constant(value='Invalid line format: '), FormattedValue(value=Name(id='line', ctx=Load()), conversion=-1)])], keywords=[]))])], orelse=[], finalbody=[])], orelse=[])], orelse=[]), For(target=Name(id='field', ctx=Store()), iter=Name(id='required_fields', ctx=Load()), body=[If(test=Compare(left=Name(id='field', ctx=Load()), ops=[NotIn()], comparators=[Name(id='block_fields', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='block_errors', ctx=Load()), attr='append', ctx=Load()), args=[JoinedStr(values=[Constant(value='Missing required field: '), FormattedValue(value=Name(id='field', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[])], orelse=[]), For(target=Tuple(elts=[Name(id='field', ctx=Store()), Name(id='validator', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='custom_validators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Name(id='field', ctx=Load()), ops=[In()], comparators=[Name(id='block_fields', ctx=Load())]), body=[Try(body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='validator', ctx=Load()), args=[Subscript(value=Name(id='block_fields', ctx=Load()), slice=Name(id='field', ctx=Load()), ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='block_errors', ctx=Load()), attr='append', ctx=Load()), args=[JoinedStr(values=[Constant(value='Custom validation failed for field: '), FormattedValue(value=Name(id='field', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[])], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Expr(value=Call(func=Attribute(value=Name(id='block_errors', ctx=Load()), attr='append', ctx=Load()), args=[JoinedStr(values=[Constant(value='Error in custom validator for field '), FormattedValue(value=Name(id='field', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[]))])], orelse=[], finalbody=[])], orelse=[])], orelse=[]), If(test=Name(id='block_errors', ctx=Load()), body=[AugAssign(target=Name(id='invalid_blocks_count', ctx=Store()), op=Add(), value=Constant(value=1)), Assign(targets=[Name(id='question', ctx=Store())], value=Call(func=Attribute(value=Name(id='block_fields', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='QUESTION'), Constant(value='Question not found')], keywords=[])), For(target=Name(id='error', ctx=Store()), iter=Name(id='block_errors', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='error', ctx=Load()), conversion=-1), Constant(value=' in block\nQUESTION: '), FormattedValue(value=Name(id='question', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='invalid_blocks_count', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Return(value=Name(id='total_blocks', ctx=Load()))], orelse=[Return(value=UnaryOp(op=USub(), operand=Name(id='invalid_blocks_count', ctx=Load())))])], decorator_list=[]), FunctionDef(name='is_valid_file_qa', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='required_fields'), arg(arg='custom_validators'), arg(arg='verbose')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='\n    Function to validate QA blocks in a file and return True if all blocks are valid\n\n    :param file_path: string of the path to the file to be validated\n    :param required_fields: List of required field names.\n    :param custom_validators: Dictionary of field names and their corresponding validation functions.\n    :param verbose: boolean to control verbose output\n    :return: boolean indicating whether all blocks in the file are valid\n    ')), ImportFrom(module='primary.structured', names=[alias(name='get_blocks_from_file')], level=0), Assign(targets=[Name(id='blocks', ctx=Store())], value=Call(func=Name(id='get_blocks_from_file', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='valid_blocks', ctx=Store())], value=Call(func=Name(id='validate_qa_blocks', ctx=Load()), args=[Name(id='blocks', ctx=Load()), Name(id='required_fields', ctx=Load()), Name(id='custom_validators', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='valid_blocks', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='FAIL - INVALID blocks for file: '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1), Constant(value='\n\n\n')])], keywords=[])), Return(value=Constant(value=False))], orelse=[]), If(test=Name(id='verbose', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='VALID blocks for file: '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), Return(value=Constant(value=True))], decorator_list=[]), FunctionDef(name='validate_folders_qa', args=arguments(posonlyargs=[], args=[arg(arg='folder_paths'), arg(arg='required_fields'), arg(arg='custom_validators'), arg(arg='suffixpat_include')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='_qafixed')]), body=[Expr(value=Constant(value='\n    Validates QA blocks in all files within specified folders, printing the number of valid files in each folder\n    and statistics about required and optional fields.\n\n    :param folder_paths: list of strings of folder paths to search for files.\n    :param required_fields: List of required field names.\n    :param custom_validators: Dictionary of field names and their corresponding validation functions.\n    :param suffixpat_include: string of the suffix to include in file search. Default is "_qafixed".\n    :return: string of the path of the first file with invalid QA blocks if any; None if all files are valid.\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='get_files_in_folder')], level=0), ImportFrom(module='primary.structured', names=[alias(name='get_blocks_from_file')], level=0), Assign(targets=[Name(id='total_valid_files', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='total_files', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='optional_fields_stats', ctx=Store())], value=Call(func=Name(id='defaultdict', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Dict(keys=[Constant(value='files'), Constant(value='blocks')], values=[Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), Constant(value=0)]))], keywords=[])), For(target=Name(id='folder_path', ctx=Store()), iter=Name(id='folder_paths', ctx=Load()), body=[Assign(targets=[Name(id='file_paths', ctx=Store())], value=Call(func=Name(id='get_files_in_folder', ctx=Load()), args=[Name(id='folder_path', ctx=Load())], keywords=[keyword(arg='suffixpat_include', value=Name(id='suffixpat_include', ctx=Load()))])), Assign(targets=[Name(id='valid_files_count', ctx=Store())], value=Constant(value=0)), For(target=Name(id='file_path', ctx=Store()), iter=Name(id='file_paths', ctx=Load()), body=[AugAssign(target=Name(id='total_files', ctx=Store()), op=Add(), value=Constant(value=1)), Assign(targets=[Name(id='blocks', ctx=Store())], value=Call(func=Name(id='get_blocks_from_file', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='is_valid_file_qa', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='required_fields', ctx=Load()), Name(id='custom_validators', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='valid_files_count', ctx=Store()), op=Add(), value=Constant(value=1)), AugAssign(target=Name(id='total_valid_files', ctx=Store()), op=Add(), value=Constant(value=1)), For(target=Name(id='block', ctx=Store()), iter=Name(id='blocks', ctx=Load()), body=[For(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='block', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[]), body=[If(test=Name(id='line', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='key', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=':'), Constant(value=1)], keywords=[])), Assign(targets=[Name(id='field', ctx=Store())], value=Call(func=Attribute(value=Name(id='key', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='field', ctx=Load()), ops=[NotIn()], comparators=[Name(id='required_fields', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Subscript(value=Subscript(value=Name(id='optional_fields_stats', ctx=Load()), slice=Name(id='field', ctx=Load()), ctx=Load()), slice=Constant(value='files'), ctx=Load()), attr='add', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[])), AugAssign(target=Subscript(value=Subscript(value=Name(id='optional_fields_stats', ctx=Load()), slice=Name(id='field', ctx=Load()), ctx=Load()), slice=Constant(value='blocks'), ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[])], orelse=[])], orelse=[])], orelse=[])], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Number of validated files: '), FormattedValue(value=Name(id='valid_files_count', ctx=Load()), conversion=-1), Constant(value=' in '), FormattedValue(value=Name(id='folder_path', ctx=Load()), conversion=-1), Constant(value=': ')])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='INVALID file: '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Name(id='file_path', ctx=Load()))])], orelse=[]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Number of valid files in '), FormattedValue(value=Name(id='folder_path', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Name(id='valid_files_count', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='\nTotal valid files across all folders: '), FormattedValue(value=Name(id='total_valid_files', ctx=Load()), conversion=-1), Constant(value='/'), FormattedValue(value=Name(id='total_files', ctx=Load()), conversion=-1)])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='\nRequired fields: '), FormattedValue(value=Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Name(id='required_fields', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='\nOptional fields statistics:')], keywords=[])), For(target=Tuple(elts=[Name(id='field', ctx=Store()), Name(id='stats', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='optional_fields_stats', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='  '), FormattedValue(value=Name(id='field', ctx=Load()), conversion=-1), Constant(value=': appears in '), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='stats', ctx=Load()), slice=Constant(value='files'), ctx=Load())], keywords=[]), conversion=-1), Constant(value=' files and '), FormattedValue(value=Subscript(value=Name(id='stats', ctx=Load()), slice=Constant(value='blocks'), ctx=Load()), conversion=-1), Constant(value=' blocks')])], keywords=[]))], orelse=[]), Return(value=Constant(value=None))], decorator_list=[]), Assign(targets=[Name(id='DEUTSCH_FOLDER_PATHS', ctx=Store())], value=List(elts=[Constant(value='data/deutsch/f8_done_qafixed_and_vrb'), Constant(value='data/deutsch/f8_qafixed_talks')], ctx=Load())), FunctionDef(name='validate_corpus_deutsch', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='required_fields', ctx=Store())], value=List(elts=[Constant(value='QUESTION'), Constant(value='TIMESTAMP'), Constant(value='ANSWER'), Constant(value='EDITS'), Constant(value='TOPICS'), Constant(value='STARS')], ctx=Load())), Assign(targets=[Name(id='custom_validators', ctx=Store())], value=Dict(keys=[Constant(value='STARS'), Constant(value='TOPICS')], values=[Name(id='validate_stars', ctx=Load()), Name(id='validate_topics', ctx=Load())])), Expr(value=Call(func=Name(id='validate_folders_qa', ctx=Load()), args=[Name(id='DEUTSCH_FOLDER_PATHS', ctx=Load()), Name(id='required_fields', ctx=Load()), Name(id='custom_validators', ctx=Load())], keywords=[]))], decorator_list=[]), If(test=Compare(left=Name(id='__name__', ctx=Load()), ops=[Eq()], comparators=[Constant(value='__main__')]), body=[ImportFrom(module='primary.structured', names=[alias(name='create_topics_matrix'), alias(name='change_topic_in_folders'), alias(name='review_singlet_topic')], level=0), Assign(targets=[Name(id='cur_matrix_topics_csv', ctx=Store())], value=Constant(value='data/deutsch/matrix_topics.csv')), Expr(value=Call(func=Name(id='review_singlet_topic', ctx=Load()), args=[Name(id='DEUTSCH_FOLDER_PATHS', ctx=Load()), Name(id='cur_matrix_topics_csv', ctx=Load()), Constant(value='b')], keywords=[]))], orelse=[]), FunctionDef(name='validate_qa_blocks_deutsch_OLD', args=arguments(posonlyargs=[], args=[arg(arg='blocks_list')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Validates the structure and content of QA blocks against required and optional fields.\n\n    :param blocks_list: list of qa blocks where each block is a string of text representing a qa entry.\n    :return: the number of valid blocks if all are valid, or the negative count of invalid blocks.\n    ')), Assign(targets=[Name(id='required_fields', ctx=Store())], value=List(elts=[Constant(value='QUESTION'), Constant(value='TIMESTAMP'), Constant(value='ANSWER'), Constant(value='EDITS'), Constant(value='TOPICS'), Constant(value='STARS')], ctx=Load())), Assign(targets=[Name(id='optional_fields', ctx=Store())], value=List(elts=[Constant(value='NOTES'), Constant(value='ORIGINAL QUESTION'), Constant(value='ALTERNATE QUESTION'), Constant(value='ADDITIONAL QUESTION')], ctx=Load())), Assign(targets=[Name(id='all_fields', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[BinOp(left=Name(id='required_fields', ctx=Load()), op=Add(), right=Name(id='optional_fields', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='invalid_blocks_count', ctx=Store())], value=Constant(value=0)), For(target=Name(id='block', ctx=Store()), iter=Name(id='blocks_list', ctx=Load()), body=[Assign(targets=[Name(id='block_lines', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='block', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[])), Assign(targets=[Name(id='block_fields', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='block_is_valid', ctx=Store())], value=Constant(value=True)), For(target=Name(id='line', ctx=Store()), iter=Name(id='block_lines', ctx=Load()), body=[If(test=Name(id='line', ctx=Load()), body=[Try(body=[Assign(targets=[Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=':'), Constant(value=1)], keywords=[])), Assign(targets=[Subscript(value=Name(id='block_fields', ctx=Load()), slice=Call(func=Attribute(value=Name(id='key', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), name='e', body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value="Error splitting line '"), FormattedValue(value=Name(id='line', ctx=Load()), conversion=-1), Constant(value="' in block:\n"), FormattedValue(value=Name(id='block', ctx=Load()), conversion=-1), Constant(value='\nError: '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='block_is_valid', ctx=Store())], value=Constant(value=False)), Break()])], orelse=[], finalbody=[])], orelse=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value='Block contains a blank line:\n'), FormattedValue(value=Name(id='block', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='block_is_valid', ctx=Store())], value=Constant(value=False)), Break()])], orelse=[]), For(target=Name(id='field', ctx=Store()), iter=Name(id='block_fields', ctx=Load()), body=[If(test=Compare(left=Name(id='field', ctx=Load()), ops=[NotIn()], comparators=[Name(id='all_fields', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value="Invalid field '"), FormattedValue(value=Name(id='field', ctx=Load()), conversion=-1), Constant(value="' in block:\n"), FormattedValue(value=Name(id='block', ctx=Load()), conversion=-1), Constant(value='\n\n')])], keywords=[])), Assign(targets=[Name(id='block_is_valid', ctx=Store())], value=Constant(value=False))], orelse=[])], orelse=[]), For(target=Name(id='field', ctx=Store()), iter=Name(id='required_fields', ctx=Load()), body=[If(test=Compare(left=Name(id='field', ctx=Load()), ops=[NotIn()], comparators=[Name(id='block_fields', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value="Missing required field '"), FormattedValue(value=Name(id='field', ctx=Load()), conversion=-1), Constant(value="' in block:\n"), FormattedValue(value=Name(id='block', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='block_is_valid', ctx=Store())], value=Constant(value=False))], orelse=[If(test=Compare(left=Name(id='field', ctx=Load()), ops=[Eq()], comparators=[Constant(value='STARS')]), body=[Assign(targets=[Name(id='stars_str', ctx=Store())], value=Subscript(value=Name(id='block_fields', ctx=Load()), slice=Name(id='field', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='stars', ctx=Store())], value=IfExp(test=Call(func=Attribute(value=Name(id='stars_str', ctx=Load()), attr='isdigit', ctx=Load()), args=[], keywords=[]), body=Call(func=Name(id='int', ctx=Load()), args=[Name(id='stars_str', ctx=Load())], keywords=[]), orelse=Constant(value=0))), If(test=Compare(left=Name(id='stars', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value='Invalid format for STARS field.')])], keywords=[])), Assign(targets=[Name(id='block_is_valid', ctx=Store())], value=Constant(value=False))], orelse=[])], orelse=[If(test=Compare(left=Name(id='field', ctx=Load()), ops=[Eq()], comparators=[Constant(value='TOPICS')]), body=[Assign(targets=[Name(id='topics_line', ctx=Store())], value=Subscript(value=Name(id='block_fields', ctx=Load()), slice=Name(id='field', ctx=Load()), ctx=Load())), If(test=Compare(left=Constant(value=',  '), ops=[In()], comparators=[Name(id='topics_line', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value="Double space after comma in topics line '"), FormattedValue(value=Name(id='topics_line', ctx=Load()), conversion=-1), Constant(value="'")])], keywords=[])), Assign(targets=[Name(id='block_is_valid', ctx=Store())], value=Constant(value=False))], orelse=[If(test=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='search', ctx=Load()), args=[Constant(value=',(?![ ])'), Name(id='topics_line', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value="Missing space after comma in topics line '"), FormattedValue(value=Name(id='topics_line', ctx=Load()), conversion=-1), Constant(value="'")])], keywords=[])), Assign(targets=[Name(id='block_is_valid', ctx=Store())], value=Constant(value=False))], orelse=[])]), Assign(targets=[Name(id='topics', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=',\\s*'), Call(func=Attribute(value=Name(id='topics_line', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='cleaned_topics', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='topic', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='topic', ctx=Store()), iter=Name(id='topics', ctx=Load()), ifs=[Call(func=Attribute(value=Name(id='topic', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])], is_async=0)])), For(target=Tuple(elts=[Name(id='topic', ctx=Store()), Name(id='cleaned_topic', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='topics', ctx=Load()), Name(id='cleaned_topics', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='topic', ctx=Load()), ops=[NotEq()], comparators=[Name(id='cleaned_topic', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value="Incorrect whitespace in topic '"), FormattedValue(value=Name(id='topic', ctx=Load()), conversion=-1), Constant(value="'")])], keywords=[])), Assign(targets=[Name(id='block_is_valid', ctx=Store())], value=Constant(value=False))], orelse=[])], orelse=[])], orelse=[])])])], orelse=[]), For(target=Name(id='field', ctx=Store()), iter=Name(id='optional_fields', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='field', ctx=Load()), ops=[In()], comparators=[Name(id='block_fields', ctx=Load())]), UnaryOp(op=Not(), operand=Subscript(value=Name(id='block_fields', ctx=Load()), slice=Name(id='field', ctx=Load()), ctx=Load()))]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value="Optional field '"), FormattedValue(value=Name(id='field', ctx=Load()), conversion=-1), Constant(value="' is present but blank in block:\n"), FormattedValue(value=Name(id='block', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='block_is_valid', ctx=Store())], value=Constant(value=False))], orelse=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='block_is_valid', ctx=Load())), body=[AugAssign(target=Name(id='invalid_blocks_count', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='invalid_blocks_count', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Return(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='blocks_list', ctx=Load())], keywords=[]))], orelse=[Return(value=BinOp(left=Constant(value=0), op=Sub(), right=Name(id='invalid_blocks_count', ctx=Load())))])], decorator_list=[]), FunctionDef(name='remove_lines_fda_townhall', args=arguments(posonlyargs=[], args=[arg(arg='text')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=' \n    Remove lines from a string of FDA townhall transcript text that match certain patterns.\n\n    :param text: string of the transcript text to be cleaned.\n    :return: string of the cleaned transcript text.\n    ')), Assign(targets=[Name(id='page_pattern', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='^(Page \\d+|\\d+)\\s*$'), Attribute(value=Name(id='re', ctx=Load()), attr='IGNORECASE', ctx=Load())], keywords=[])), Assign(targets=[Name(id='date_pattern', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='^(?:January|February|March|April|May|June|July|August|September|October|November|December) \\d{1,2}, \\d{4}.*$|\\d{1,2}-\\d{1,2}-\\d{2,4}.*$'), Attribute(value=Name(id='re', ctx=Load()), attr='IGNORECASE', ctx=Load())], keywords=[])), Assign(targets=[Name(id='time_pattern', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='^\\d{1,2}:\\d{2} (?:am|pm) ET\\s*$'), Attribute(value=Name(id='re', ctx=Load()), attr='IGNORECASE', ctx=Load())], keywords=[])), Assign(targets=[Name(id='title_pattern', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='^(?:Virtual Townhall|FDA Virtual Town Hall Series – |FDA Virtual Town|Virtual Town|FDA CDRH|Immediately in Effect Guidance|FDA Virtual Townhall)\\s*$'), Attribute(value=Name(id='re', ctx=Load()), attr='MULTILINE', ctx=Load())], keywords=[])), Assign(targets=[Name(id='end_pattern', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='^(END|\\[\\s*Event concluded\\s*\\]|\\s*\\*+\\s*)\\s*$'), Attribute(value=Name(id='re', ctx=Load()), attr='IGNORECASE', ctx=Load())], keywords=[])), Assign(targets=[Name(id='moderator_pattern', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Constant(value='^Moderator: [A-Za-z\\s]+\\s*$'), Attribute(value=Name(id='re', ctx=Load()), attr='MULTILINE', ctx=Load())], keywords=[])), Assign(targets=[Name(id='patterns', ctx=Store())], value=List(elts=[Name(id='page_pattern', ctx=Load()), Name(id='date_pattern', ctx=Load()), Name(id='time_pattern', ctx=Load()), Name(id='title_pattern', ctx=Load()), Name(id='end_pattern', ctx=Load()), Name(id='moderator_pattern', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='lines', ctx=Store())], value=Call(func=Attribute(value=Name(id='text', ctx=Load()), attr='splitlines', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='cleaned_lines', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='line', ctx=Store()), iter=Name(id='lines', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='pattern', ctx=Load()), attr='match', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='pattern', ctx=Store()), iter=Name(id='patterns', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='cleaned_lines', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='cleaned_text', ctx=Store())], value=Call(func=Attribute(value=Constant(value='\n'), attr='join', ctx=Load()), args=[Name(id='cleaned_lines', ctx=Load())], keywords=[])), Return(value=Name(id='cleaned_text', ctx=Load()))], decorator_list=[]), FunctionDef(name='clean_fda_townhall', args=arguments(posonlyargs=[], args=[arg(arg='file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Cleans the FDA townhall file by removing unnecessary lines and fixing speaker text.\n\n    :param file_path: string of the path to the file to be cleaned.\n    :param suffix_new: string of the suffix to be added to the cleaned file. Default is '_cleaned'.\n    :return: The cleaned text with the heading set.\n    ")), ImportFrom(module='primary.fileops', names=[alias(name='get_heading'), alias(name='set_heading')], level=0), ImportFrom(module='primary.docwork', names=[alias(name='reformat_transcript_text')], level=0), Assign(targets=[Name(id='heading', ctx=Store())], value=Constant(value='### transcript')), Assign(targets=[Name(id='text', ctx=Store())], value=Call(func=Name(id='get_heading', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='heading', ctx=Load())], keywords=[])), Assign(targets=[Name(id='cleaned1_text', ctx=Store())], value=Call(func=Name(id='remove_lines_fda_townhall', ctx=Load()), args=[Name(id='text', ctx=Load())], keywords=[])), Assign(targets=[Name(id='cleaned2_text', ctx=Store())], value=Call(func=Name(id='reformat_transcript_text', ctx=Load()), args=[Name(id='cleaned1_text', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='set_heading', ctx=Load()), args=[Name(id='file_path', ctx=Load()), BinOp(left=Constant(value='\n'), op=Add(), right=Name(id='cleaned2_text', ctx=Load())), Name(id='heading', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='run_clean_on_fda_townhalls', args=arguments(posonlyargs=[], args=[arg(arg='source_folder'), arg(arg='destination_folder')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Cleans the files in the source folder and moves the cleaned files to the destination folder.\n\n    :param source_folder: string of the path to the source folder containing the files to be cleaned.\n    :param destination_folder: string of the path to the destination folder where the cleaned files will be moved.\n    :return: None\n    ')), ImportFrom(module='primary.fileops', names=[alias(name='apply_to_folder'), alias(name='move_files_with_suffix')], level=0), Expr(value=Call(func=Name(id='apply_to_folder', ctx=Load()), args=[Name(id='clean_fda_townhall', ctx=Load()), Name(id='source_folder', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='move_files_with_suffix', ctx=Load()), args=[Name(id='source_folder', ctx=Load()), Name(id='destination_folder', ctx=Load()), Constant(value='_cleaned')], keywords=[]))], decorator_list=[]), FunctionDef(name='run_fix_names_on_fda_townhalls', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[ImportFrom(module='primary.fileops', names=[alias(name='find_and_replace_from_csv'), alias(name='apply_to_folder'), alias(name='sub_suffix_in_file')], level=0), Assign(targets=[Name(id='orig_folder', ctx=Store())], value=Constant(value='data/floodlamp_fda/townhalls/f4_md_cleaned_manualedits')), Assign(targets=[Name(id='suffix_orig', ctx=Store())], value=Constant(value='_cleaned')), Assign(targets=[Name(id='fixnames_folder', ctx=Store())], value=Constant(value='data/floodlamp_fda/townhalls/f5_md_fixnames')), Assign(targets=[Name(id='suffix_new', ctx=Store())], value=Constant(value='_fixnames')), Assign(targets=[Name(id='csv_file_path', ctx=Store())], value=Constant(value='data/floodlamp_fda/townhalls/names_findandreplace_fda_townhalls.csv'))], decorator_list=[]), FunctionDef(name='validate_qa_blocks_townhall_OLD', args=arguments(posonlyargs=[], args=[arg(arg='blocks_list')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Validates the structure and content of QA blocks against required and optional fields.\n\n    :param blocks_list: list of qa blocks where each block is a string of text representing a qa entry.\n    :return: the number of valid blocks if all are valid, or the negative count of invalid blocks.\n    ')), Assign(targets=[Name(id='required_fields', ctx=Store())], value=List(elts=[Constant(value='QUESTION'), Constant(value='ANSWER'), Constant(value='QUESTION SPEAKER'), Constant(value='ANSWER SPEAKER'), Constant(value='TOPICS'), Constant(value='STARS')], ctx=Load())), Assign(targets=[Name(id='optional_fields', ctx=Store())], value=List(elts=[Constant(value='NOTES'), Constant(value='ORIGINAL QUESTION'), Constant(value='ALTERNATE QUESTION'), Constant(value='ADDITIONAL QUESTION')], ctx=Load())), Assign(targets=[Name(id='all_fields', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[BinOp(left=Name(id='required_fields', ctx=Load()), op=Add(), right=Name(id='optional_fields', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='invalid_blocks_count', ctx=Store())], value=Constant(value=0)), For(target=Name(id='block', ctx=Store()), iter=Name(id='blocks_list', ctx=Load()), body=[Assign(targets=[Name(id='block_lines', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='block', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), attr='split', ctx=Load()), args=[Constant(value='\n')], keywords=[])), Assign(targets=[Name(id='block_fields', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='block_is_valid', ctx=Store())], value=Constant(value=True)), For(target=Name(id='line', ctx=Store()), iter=Name(id='block_lines', ctx=Load()), body=[If(test=Name(id='line', ctx=Load()), body=[Try(body=[Assign(targets=[Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='line', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=':'), Constant(value=1)], keywords=[])), Assign(targets=[Subscript(value=Name(id='block_fields', ctx=Load()), slice=Call(func=Attribute(value=Name(id='key', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), ctx=Store())], value=Call(func=Attribute(value=Name(id='value', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), name='e', body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value="Error splitting line '"), FormattedValue(value=Name(id='line', ctx=Load()), conversion=-1), Constant(value="' in block:\n"), FormattedValue(value=Name(id='block', ctx=Load()), conversion=-1), Constant(value='\nError: '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='block_is_valid', ctx=Store())], value=Constant(value=False)), Break()])], orelse=[], finalbody=[])], orelse=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value='Block contains a blank line:\n'), FormattedValue(value=Name(id='block', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='block_is_valid', ctx=Store())], value=Constant(value=False)), Break()])], orelse=[]), For(target=Name(id='field', ctx=Store()), iter=Name(id='block_fields', ctx=Load()), body=[If(test=Compare(left=Name(id='field', ctx=Load()), ops=[NotIn()], comparators=[Name(id='all_fields', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value="Invalid field '"), FormattedValue(value=Name(id='field', ctx=Load()), conversion=-1), Constant(value="' in block:\n"), FormattedValue(value=Name(id='block', ctx=Load()), conversion=-1), Constant(value='\n\n')])], keywords=[])), Assign(targets=[Name(id='block_is_valid', ctx=Store())], value=Constant(value=False))], orelse=[])], orelse=[]), For(target=Name(id='field', ctx=Store()), iter=Name(id='required_fields', ctx=Load()), body=[If(test=Compare(left=Name(id='field', ctx=Load()), ops=[NotIn()], comparators=[Name(id='block_fields', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value="Missing required field '"), FormattedValue(value=Name(id='field', ctx=Load()), conversion=-1), Constant(value="' in block:\n"), FormattedValue(value=Name(id='block', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='block_is_valid', ctx=Store())], value=Constant(value=False))], orelse=[If(test=Compare(left=Name(id='field', ctx=Load()), ops=[Eq()], comparators=[Constant(value='STARS')]), body=[Assign(targets=[Name(id='stars_str', ctx=Store())], value=Subscript(value=Name(id='block_fields', ctx=Load()), slice=Name(id='field', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='stars', ctx=Store())], value=IfExp(test=Call(func=Attribute(value=Name(id='stars_str', ctx=Load()), attr='isdigit', ctx=Load()), args=[], keywords=[]), body=Call(func=Name(id='int', ctx=Load()), args=[Name(id='stars_str', ctx=Load())], keywords=[]), orelse=Constant(value=0))), If(test=Compare(left=Name(id='stars', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value='Invalid format for STARS field.')])], keywords=[])), Assign(targets=[Name(id='block_is_valid', ctx=Store())], value=Constant(value=False))], orelse=[])], orelse=[If(test=Compare(left=Name(id='field', ctx=Load()), ops=[Eq()], comparators=[Constant(value='TOPICS')]), body=[Assign(targets=[Name(id='topics_line', ctx=Store())], value=Subscript(value=Name(id='block_fields', ctx=Load()), slice=Name(id='field', ctx=Load()), ctx=Load())), If(test=Compare(left=Constant(value=',  '), ops=[In()], comparators=[Name(id='topics_line', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value="Double space after comma in topics line '"), FormattedValue(value=Name(id='topics_line', ctx=Load()), conversion=-1), Constant(value="'")])], keywords=[])), Assign(targets=[Name(id='block_is_valid', ctx=Store())], value=Constant(value=False))], orelse=[If(test=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='search', ctx=Load()), args=[Constant(value=',(?![ ])'), Name(id='topics_line', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value="Missing space after comma in topics line '"), FormattedValue(value=Name(id='topics_line', ctx=Load()), conversion=-1), Constant(value="'")])], keywords=[])), Assign(targets=[Name(id='block_is_valid', ctx=Store())], value=Constant(value=False))], orelse=[])]), Assign(targets=[Name(id='topics', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value=',\\s*'), Call(func=Attribute(value=Name(id='topics_line', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='cleaned_topics', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='topic', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[]), generators=[comprehension(target=Name(id='topic', ctx=Store()), iter=Name(id='topics', ctx=Load()), ifs=[Call(func=Attribute(value=Name(id='topic', ctx=Load()), attr='strip', ctx=Load()), args=[], keywords=[])], is_async=0)])), For(target=Tuple(elts=[Name(id='topic', ctx=Store()), Name(id='cleaned_topic', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='topics', ctx=Load()), Name(id='cleaned_topics', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='topic', ctx=Load()), ops=[NotEq()], comparators=[Name(id='cleaned_topic', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value="Incorrect whitespace in topic '"), FormattedValue(value=Name(id='topic', ctx=Load()), conversion=-1), Constant(value="'")])], keywords=[])), Assign(targets=[Name(id='block_is_valid', ctx=Store())], value=Constant(value=False))], orelse=[])], orelse=[])], orelse=[])])])], orelse=[]), For(target=Name(id='field', ctx=Store()), iter=Name(id='optional_fields', ctx=Load()), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='field', ctx=Load()), ops=[In()], comparators=[Name(id='block_fields', ctx=Load())]), UnaryOp(op=Not(), operand=Subscript(value=Name(id='block_fields', ctx=Load()), slice=Name(id='field', ctx=Load()), ctx=Load()))]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value="Optional field '"), FormattedValue(value=Name(id='field', ctx=Load()), conversion=-1), Constant(value="' is present but blank in block:\n"), FormattedValue(value=Name(id='block', ctx=Load()), conversion=-1)])], keywords=[])), Assign(targets=[Name(id='block_is_valid', ctx=Store())], value=Constant(value=False))], orelse=[])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Name(id='block_is_valid', ctx=Load())), body=[AugAssign(target=Name(id='invalid_blocks_count', ctx=Store()), op=Add(), value=Constant(value=1))], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='invalid_blocks_count', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Return(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='blocks_list', ctx=Load())], keywords=[]))], orelse=[Return(value=BinOp(left=Constant(value=0), op=Sub(), right=Name(id='invalid_blocks_count', ctx=Load())))])], decorator_list=[]), FunctionDef(name='validate_qa_blocks_townhall', args=arguments(posonlyargs=[], args=[arg(arg='blocks_list')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='required_fields', ctx=Store())], value=List(elts=[Constant(value='QUESTION'), Constant(value='ANSWER'), Constant(value='QUESTION SPEAKER'), Constant(value='ANSWER SPEAKER'), Constant(value='TOPICS'), Constant(value='STARS')], ctx=Load())), Assign(targets=[Name(id='custom_validators', ctx=Store())], value=Dict(keys=[Constant(value='STARS'), Constant(value='TOPICS')], values=[Name(id='validate_stars', ctx=Load()), Name(id='validate_topics', ctx=Load())])), Return(value=Call(func=Name(id='validate_qa_blocks', ctx=Load()), args=[Name(id='blocks_list', ctx=Load()), Name(id='required_fields', ctx=Load()), Name(id='custom_validators', ctx=Load())], keywords=[]))], decorator_list=[])], type_ignores=[])

Module(body=[Import(names=[alias(name='boto3')]), Import(names=[alias(name='os')]), Import(names=[alias(name='json')]), ImportFrom(module='botocore.exceptions', names=[alias(name='ClientError'), alias(name='NoCredentialsError')], level=0), FunctionDef(name='upload_file_to_s3', args=arguments(posonlyargs=[], args=[arg(arg='file_path'), arg(arg='bucket'), arg(arg='object_name'), arg(arg='s3_path')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='fofpublic'), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="\n    Upload a file to an S3 bucket\n\n    :param file_path: File to upload\n    :param bucket: Name of the S3 bucket, default is 'fofpublic', others: 'fofsecure', 'deutsch-audio'\n    :param object_name: S3 object name. If not specified, the file name is used\n    :param s3_path: S3 folder path where the file will be stored, e.g. 'podcasts/'\n    :return: The object name of the file in S3\n    ")), Assign(targets=[Name(id='s3_client', ctx=Store())], value=Call(func=Attribute(value=Name(id='boto3', ctx=Load()), attr='client', ctx=Load()), args=[Constant(value='s3')], keywords=[])), If(test=Compare(left=Name(id='object_name', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='object_name', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='basename', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[]))], orelse=[]), If(test=Name(id='s3_path', ctx=Load()), body=[Assign(targets=[Name(id='object_name', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='s3_path', ctx=Load()), Name(id='object_name', ctx=Load())], keywords=[]))], orelse=[]), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='s3_client', ctx=Load()), attr='upload_file', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Name(id='bucket', ctx=Load()), Name(id='object_name', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='uploaded '), FormattedValue(value=Name(id='object_name', ctx=Load()), conversion=-1), Constant(value=' to '), FormattedValue(value=Name(id='bucket', ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Name(id='object_name', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='FileNotFoundError', ctx=Load()), body=[Return(value=Constant(value=None))]), ExceptHandler(type=Name(id='NoCredentialsError', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Constant(value='Credentials not available')], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[]), FunctionDef(name='rename_s3_object', args=arguments(posonlyargs=[], args=[arg(arg='bucket'), arg(arg='old_key'), arg(arg='new_key'), arg(arg='s3_path')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n    Rename an object in an S3 bucket by copying it to a new key and deleting the old key.\n\n    :param bucket: Name of the S3 bucket\n    :param old_key: The current key (path) of the object in the S3 bucket\n    :param new_key: The new key (path) for the object in the S3 bucket\n    :param s3_path: Optional S3 folder path to prepend to the keys\n    :return: None\n    ')), Assign(targets=[Name(id='s3', ctx=Store())], value=Call(func=Attribute(value=Name(id='boto3', ctx=Load()), attr='client', ctx=Load()), args=[Constant(value='s3')], keywords=[keyword(arg='region_name', value=Constant(value='us-west-2'))])), If(test=Name(id='s3_path', ctx=Load()), body=[Assign(targets=[Name(id='old_key', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='s3_path', ctx=Load()), conversion=-1), Constant(value='/'), FormattedValue(value=Name(id='old_key', ctx=Load()), conversion=-1)])), Assign(targets=[Name(id='new_key', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='s3_path', ctx=Load()), conversion=-1), Constant(value='/'), FormattedValue(value=Name(id='new_key', ctx=Load()), conversion=-1)]))], orelse=[]), Assign(targets=[Name(id='copy_source', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='bucket', ctx=Load()), conversion=-1), Constant(value='/'), FormattedValue(value=Name(id='old_key', ctx=Load()), conversion=-1)])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Function rename_s3_object is attempting to copy from '), FormattedValue(value=Name(id='copy_source', ctx=Load()), conversion=-1), Constant(value=' to '), FormattedValue(value=Name(id='new_key', ctx=Load()), conversion=-1), Constant(value=' in bucket '), FormattedValue(value=Name(id='bucket', ctx=Load()), conversion=-1)])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='s3', ctx=Load()), attr='copy_object', ctx=Load()), args=[], keywords=[keyword(arg='Bucket', value=Name(id='bucket', ctx=Load())), keyword(arg='CopySource', value=Name(id='copy_source', ctx=Load())), keyword(arg='Key', value=Name(id='new_key', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='s3', ctx=Load()), attr='delete_object', ctx=Load()), args=[], keywords=[keyword(arg='Bucket', value=Name(id='bucket', ctx=Load())), keyword(arg='Key', value=Name(id='old_key', ctx=Load()))])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Renamed '), FormattedValue(value=Name(id='old_key', ctx=Load()), conversion=-1), Constant(value=' to '), FormattedValue(value=Name(id='new_key', ctx=Load()), conversion=-1), Constant(value=' in bucket '), FormattedValue(value=Name(id='bucket', ctx=Load()), conversion=-1)])], keywords=[])), Return()], decorator_list=[]), FunctionDef(name='get_s3_json', args=arguments(posonlyargs=[], args=[arg(arg='bucket'), arg(arg='key'), arg(arg='s3_path')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='\n    Retrieve a JSON object from an S3 bucket.\n\n    :param bucket: Name of the S3 bucket\n    :param key: The key (path) of the JSON object in the S3 bucket\n    :param s3_path: Optional S3 folder path to prepend to the key\n    :return: The JSON object if found, otherwise None\n    ')), Assign(targets=[Name(id='s3', ctx=Store())], value=Call(func=Attribute(value=Name(id='boto3', ctx=Load()), attr='client', ctx=Load()), args=[Constant(value='s3')], keywords=[keyword(arg='region_name', value=Constant(value='us-west-2'))])), If(test=Name(id='s3_path', ctx=Load()), body=[Assign(targets=[Name(id='key', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='s3_path', ctx=Load()), conversion=-1), Constant(value='/'), FormattedValue(value=Name(id='key', ctx=Load()), conversion=-1)]))], orelse=[]), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Function get_s3_json is attempting to access key: '), FormattedValue(value=Name(id='key', ctx=Load()), conversion=-1), Constant(value=' in bucket: '), FormattedValue(value=Name(id='bucket', ctx=Load()), conversion=-1)])], keywords=[])), Try(body=[Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Attribute(value=Name(id='s3', ctx=Load()), attr='get_object', ctx=Load()), args=[], keywords=[keyword(arg='Bucket', value=Name(id='bucket', ctx=Load())), keyword(arg='Key', value=Name(id='key', ctx=Load()))])), Assign(targets=[Name(id='json_data', ctx=Store())], value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='loads', ctx=Load()), args=[Call(func=Attribute(value=Call(func=Attribute(value=Subscript(value=Name(id='response', ctx=Load()), slice=Constant(value='Body'), ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]), attr='decode', ctx=Load()), args=[Constant(value='utf-8')], keywords=[])], keywords=[])), Return(value=Name(id='json_data', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='ClientError', ctx=Load()), name='e', body=[Assign(targets=[Name(id='error_code', ctx=Store())], value=Subscript(value=Subscript(value=Attribute(value=Name(id='e', ctx=Load()), attr='response', ctx=Load()), slice=Constant(value='Error'), ctx=Load()), slice=Constant(value='Code'), ctx=Load())), If(test=Compare(left=Name(id='error_code', ctx=Load()), ops=[Eq()], comparators=[Constant(value='NoSuchKey')]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='No such key: '), FormattedValue(value=Name(id='key', ctx=Load()), conversion=-1), Constant(value=' in bucket: '), FormattedValue(value=Name(id='bucket', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Client error: '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[]))]), Return(value=Constant(value=None))]), ExceptHandler(type=Name(id='Exception', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Failed to retrieve '), FormattedValue(value=Name(id='key', ctx=Load()), conversion=-1), Constant(value=' from '), FormattedValue(value=Name(id='bucket', ctx=Load()), conversion=-1), Constant(value=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]), conversion=-1)])], keywords=[])), Return(value=Constant(value=None))])], orelse=[], finalbody=[])], decorator_list=[])], type_ignores=[])

Module(body=[Assign(targets=[Name(id='ROUTES_DICT_DEUTSCH_V3', ctx=Store())], value=Dict(keys=[Constant(value='routes_dict_name'), Constant(value='prompt_initial_good_match'), Constant(value='route_preamble_good_match'), Constant(value='prompt_initial_partial_match'), Constant(value='route_preamble_partial_match'), Constant(value='prompt_initial_no_match'), Constant(value='route_preamble_no_match'), Constant(value='quoted_qa_single'), Constant(value='quoted_qa_double'), Constant(value='user_ai_qa')], values=[Constant(value='ROUTES_DICT_DEUTSCH_V3'), Constant(value='Given your knowledge of David Deutsch and his philosophy of deep optimism, as well as the QUOTED QUESTIONS AND ANSWERS from Deutsch below, to answer the USER QUESTION below.\n'), Constant(value="There is a good match of your question in David Deutsch's interviews. See his QUOTED QUESTIONS AND ANSWERS below followed by an AI ANSWER that synthesizes these quotes with David Deutsch's philosophy and your exact question."), Constant(value='Given your knowledge of David Deutsch and his philosophy of deep optimism, as well as the QUOTED QUESTIONS AND ANSWERS from Deutsch below, to answer the USER QUESTION below.\n'), Constant(value="There is a partial match of your question in David Deutsch's interviews. See his QUOTED QUESTIONS AND ANSWERS below followed by an AI ANSWER that synthesizes these quotes with David Deutsch's philosophy and your exact question."), Constant(value='Given your knowledge of David Deutsch and his philosophy of deep optimism, answer the USER QUESTION below.\n'), Constant(value="Your question is not addressed in David Deutsch's interviews. No QUOTED QUESTIONS AND ANSWERS are therefore provided but here is an AI ANSWER that synthesizes David Deutsch's philosophy and your question."), Constant(value='QUOTED QUESTION: {top_sim_question}\nQUOTED SOURCE: {top_sim_source}\nQUOTED TIMESTAMP: {top_sim_timestamp}\nQUOTED ANSWER: {top_sim_answer}\n{top_sim_display}\n\n'), Constant(value='QUOTED QUESTION 1: {top_stars_question}\nQUOTED SOURCE 1: {top_stars_source}\nQUOTED TIMESTAMP 1: {top_stars_timestamp}\nQUOTED ANSWER 1: {top_stars_answer}\n{top_stars_display}\n\nQUOTED QUESTION 2: {top_sim_question}\nQUOTED SOURCE 2: {top_sim_source}\nQUOTED TIMESTAMP 2: {top_sim_timestamp}\nQUOTED ANSWER 2: {top_sim_answer}\n{top_sim_display}\n\n'), Constant(value='USER QUESTION: {user_question}\n\nAI ANSWER: ')])), Assign(targets=[Name(id='ROUTES_DICT_FDA_TOWNHALLS_V1', ctx=Store())], value=Dict(keys=[Constant(value='routes_dict_name'), Constant(value='prompt_initial_good_match'), Constant(value='route_preamble_good_match'), Constant(value='prompt_initial_partial_match'), Constant(value='route_preamble_partial_match'), Constant(value='prompt_initial_no_match'), Constant(value='route_preamble_no_match'), Constant(value='quoted_qa_single'), Constant(value='quoted_qa_double'), Constant(value='user_ai_qa')], values=[Constant(value='ROUTES_DICT_FDA_TOWNHALLS_V1'), Constant(value='Given your knowledge of FDA regulations and policies related to in vitro diagnostic testing and more specifically emergency use authorization tests for SARS-CoV-2 during the COVID public health emergency, as well as the QUOTED QUESTIONS AND ANSWERS from FDA townhalls below, answer the USER QUESTION below.\n'), Constant(value='There is a good match of your question in the FDA COVID testing townhall transcripts. See the QUOTED QUESTIONS AND ANSWERS below followed by an AI ANSWER that synthesizes these quotes with FDA policies and your exact question.'), Constant(value='Given your knowledge of FDA regulations and policies related to in vitro diagnostic testing and more specifically emergency use authorization tests for SARS-CoV-2 during the COVID public health emergency, as well as the QUOTED QUESTIONS AND ANSWERS from FDA townhalls below, answer the USER QUESTION below.\n'), Constant(value='There is a partial match of your question in the FDA COVID testing townhall transcripts. See the QUOTED QUESTIONS AND ANSWERS below followed by an AI ANSWER that synthesizes these quotes with FDA policies and your exact question.'), Constant(value='Given your knowledge of FDA regulations and policies related to in vitro diagnostic testing and more specifically emergency use authorization tests for SARS-CoV-2 during the COVID public health emergency, answer the USER QUESTION below.\n'), Constant(value='Your question is not directly addressed in the FDA COVID testing townhall transcripts. No QUOTED QUESTIONS AND ANSWERS are therefore provided but here is an AI ANSWER that synthesizes FDA policies and your question.'), Constant(value='QUOTED QUESTION: {top_sim_question}\nQUOTED SOURCE: {top_sim_source}\nQUOTED TIMESTAMP: {top_sim_timestamp}\nQUOTED ANSWER: {top_sim_answer}\n{top_sim_display}\n\n'), Constant(value='QUOTED QUESTION 1: {top_stars_question}\nQUOTED SOURCE 1: {top_stars_source}\nQUOTED TIMESTAMP 1: {top_stars_timestamp}\nQUOTED ANSWER 1: {top_stars_answer}\n{top_stars_display}\n\nQUOTED QUESTION 2: {top_sim_question}\nQUOTED SOURCE 2: {top_sim_source}\nQUOTED TIMESTAMP 2: {top_sim_timestamp}\nQUOTED ANSWER 2: {top_sim_answer}\n{top_sim_display}\n\n'), Constant(value='USER QUESTION: {user_question}\n\nAI ANSWER: ')])), Assign(targets=[Name(id='PROMPT_VRAG_DEUTSCH_V1', ctx=Store())], value=Constant(value='Placeholder\n')), Assign(targets=[Name(id='PROMPT_VRAG_FDA_TOWNHALLS_V1', ctx=Store())], value=Constant(value='Placeholder\n')), Assign(targets=[Name(id='PROMPT_TEMPLATE_DEUTSCH2_LONG', ctx=Store())], value=Constant(value='In your responses, adhere rigorously to the worldview and philosophy outlined in the provided summary. Utilize the corpus of David Deutsch\'s books and interviews as additional context to enrich your answers. However, ensure that your responses are in complete alignment with the worldview summary.\nIf the question posed by the user is relevant and the retrieved content from David Deutsch\'s work provide context or depth, incorporate that information into your response.\nIf you find that the content from the retrieved content contradicts the worldview as described in the summary, prioritize the ideas in the summary for your response.\nShould the user\'s question be irrelevant to both the worldview and the sources, issue a disclaimer acknowledging this. Nevertheless, aim to answer in a manner that is ideologically consistent with the worldview.\n\nAvoid using qualifiers like "according to David Deutsch" and refrain from using the first person in your responses. Your answers should appear as if they emanate directly from an entity entirely in sync with the worldview in question.\nSUMMARY\nKnowledge:\t\t\n\tis information that: has causal power, can do things, tends to stick around, is substrate independent\t\n\tarises from conjecture and criticism, not just sensory experience\t\n\tabout reality comes from explanations about what exists beyond mere appearances\t\n\tgrows by correcting errors and misconceptions\t\n\tis not justified true belief - this is an epistemological misconception\t\n\tcreation is due only to 2 known sources: Biological Evolution and the thoughts of People. They have some key differences. In the case of human knowledge, the variation is by Conjecture, and the selection is by Criticism and experiment. In the biosphere, the variation consists of mutations (random changes) in genes, and natural selection favors the variants that most improve the ability of their organisms to reproduce, thus causing those variant genes to spread through the population. Both sources are abstract replicators which means they\'re forms of information that are embodied in a physical system and tend to remain so (in DNA strands, books, hard-disks etc). But the two sources have some key differences. Evolution is bounded and parochial. It tends to make slow iterative changes. People\'s creativity is unbounded and has Reach.\t\n\tstreams provide evidence about the universe and are present in almost all environments\t\n\tgrowth consists of correcting misconceptions in our theories\t\n\tis always fallible, meaning all knowledge inherent contains errors\t\n\tis a broad\t\nPrinciple of Optimism:\t\t\n\tis that all evils are caused by insufficient knowledge\t\nProblems:\tare inevitable because our knowledge is always incomplete\t\n\tare solvable, given the right knowledge and provided the solutions don\'t violate the laws of physics\t\n\tsolving problems creates new problems in turn\t\n\texist when conflicts between ideas are experienced\t\n\texist when it seems that some of our theories, especially the explanations they contain, seem inadequate and worth trying to improve.\t\nExplanations:\t\t\n\tare statements about what is there, what it does, and how and why\t\n\tare good explanations if they are hard to vary:\t\n\t\twhile still accounting for what they purport to account for\n\t\twith all parts of the explanation having a functional role\n\t\tin the sense that changing the details would ruin them\n\tare distinguished from predictions which are merely about what is going to happen next\t\n\texist for emergent phenomena (such as life, thought or computation) about which there are comprehensible facts or explanations that are not simply deducible from lower-level theories, but which may be explicable or predictable by higher-level theories referring directly to the phenomena.\t\n\tare bad explanations if they are unspecific and easy to vary, meaning you can change any of all of the details without destroying the explanation\t\n\tthat refer to the supernatural are bad explanations\t\nExplanatory Knowledge:\t\t\n\tis human type knowledge, understanding\t\n\thas reach, meaning the explanations solve problems beyond those that they were created to solve\t\n\thas universal power\t\n\tis of central importance in the universe\t\n\tgrowth is inherently unpredictable\t\n\tcontrasts with non-explanatory knowledge such as that in genes\t\n\tis only created by one type of entity, referred to as "people"\t\n\tthat we currently know about is only created in human brains, but we also know it can be created by other entities such as a computer program, alien, now extinct human sister species (Neanderthals)\t\n\tprovides wealth and progress\t\n\tcreation is the best preparation for unknown dangers and unknown opportunities\t\n\thas a special relationship with both human minds and the laws of nature\t\n\tgives human minds the capability to see beyond the visible, to what is really there even though we cannot directly experience it\t\n\tenables us to control nature and make technical progress\t\nScience:\t\t\n\tis the domain of knowledge of our best explanations of physical reality\t\n\tis primarily about the quest for good explanations\t\n\tpurpose is to understand reality through good explanations\t\n\tuses the characteristic (though not the only) method of criticism of experimental testing\t\n\tis not simply about what is testable or making predictions, it is about understanding reality\t\n\tis among one of many domains, for which there are not dividing bright lines, that all seek good explanations\t\n\tis about finding laws of nature which are testable regularities\t\n\tis the kind of knowledge that can be tested by experiment or observation\t\nMathematics:\t\t\n\tis the domain of knowledge of our best explanations of abstract reality\t\n\tis the study of absolutely necessary truths\t\n\tdespite the misconception that it has privileged status set apart from other knowledge and uniquely consists of a bedrock of truth, is fallible and contains errors like all knowledge\t\n\tprovides no barrier to progress, even though as a matter of logic, there are things that we can\'t know (due to incompleteness theorems), but they\'re not things that matter ultimately to humans\t\nComputers:\t\t\n\tare physical systems that instantiates abstract entities and their relationships as physical objects and their motions\t\n\tare of fundamental significance because of the fact that physical reality only instantiates computable functions\t\nComputation:\t\t\n\ta physical process that instantiates the properties of some abstract entity\t\n\tis substrate independent\t\n\tis basically the only way to process information\t\nUniversality:\t\t\n\tis achieved when incremental improvements in a system of knowledge or technology causes a sudden increase in reach, making it a universal system in the relevant domain\t\n\tis only possible in digital systems because error correction is essential\t\n\tof the Turing Principle (in its strongest form) states that it is physically possible to build a universal virtual-reality generator\t\n\tin a system means that is capable of representing all states \t\n\tof the laws of physics means they apply everywhere and at all times\t\n\thas many kinds and is very important\t\n\treveals that a computer program can simulate a brain and therefore be creative and create new explanatory knowledge\t\n\tof human minds means that we can understand (explain) anything that can be in principle understood\t\nUniversal Computers:\t\t\n\tare also known as Turing Machines\t\n\tonly differ in speed and memory capacity, and do not differ in the repertoire of operations they can perform \t\n\tcan simulate physical reality to arbitrary precision\t\n\tare such that the set of all possible programs that could be programmed into a universal computer is in one-one correspondence with the set of all possible motions of anything\t\nPeople:\t\t\n\tis redefined as entities that can create explanatory knowledge, i.e. are Universal Explainers\t\n\tdon\'t necessary need to be human, and could be creative aliens and in the future, artificial general intelligence\t\n\thave free will which is redefined as the capacity to affect future events in any one of several possible ways, and to choose which shall occur.\t\n\tare typically thought to be only humans, and the \'Principle of Mediocrity\' is the prevailing view - which is the misconception that there is nothing significant about humans (cosmically speaking) \t\n\tare of cosmic significance because understanding the universe necessarily involves understanding the universality and power of explanatory knowledge\t\n\tuniquely are capable of creativity\t\nCreativity:\t\t\n\tis the capacity to create new explanations\t\n\tis not yet well understood and will not be understood (have a good explanation for) until we can "program" it\t\nHuman Brain:\t\t\n\tFunctions as a biological computer, processing and storing information.\t\n\tIs a physical substrate where knowledge, thoughts, and creativity originate.\t\n\tEvolutionary design enables it to conjecture, criticize, and adapt, laying the foundation for the creation of explanatory knowledge.\t\n\tWhile traditionally seen as the sole creator of human-type knowledge, it\'s now understood that similar functionality could, in principle, exist in other substrates.\t\nHuman Mind:\t\t\n\tRepresents the abstract, non-physical aspect of thought, consciousness, and self-awareness.\t\n\tOperates within the brain, but its processes are substrate-independent.\t\n\tIs a realm of creativity, where explanatory knowledge is both generated and understood.\t\n\tWhile intimately linked with the human brain, its core functions of conjecture and criticism can be conceptually decoupled from it, suggesting the potential for artificial systems to exhibit "mind-like" qualities.\t\nArtificial General Intelligence (AGI):\t\t\n\tis a computer program with creativity, implemented on an "artificial" system which is typically thought to be a digital silicon-based computer rather than a human brain (which is properly understood to also be a type of computer)\t\nExperience:\t\t\n\tis often misunderstood, because there is no such thing as ‘raw’ experience - all our experience of the world comes through layers of conscious and unconscious interpretation\t\n\tcan be external, outside of one\'s own mind, or internal, within one\'s own mind\t\n\tis connected to qualia which is the subjective aspect of a sensation (e.g. Consciousness)\t\nMemes:\t\t\n\tare ideas that are replicators\t\n\tcomprise culture\t\n\tevolve, meaning change, sometimes creating knowledge, through alternating variation and selection\t\n\tinclude both jokes and scientific theories\t\n\tare analogous to genes, but there are also profound differences in the way they evolve. The most important differences are that each meme has to include its own replication mechanism, and that a meme exists alternately in two different physical forms: a mental representation and a behaviour. Hence also a meme, unlike a gene, is separately selected, at each replication, for its ability to cause behaviour and for the ability of that behaviour to cause new recipients to adopt the meme.\t\n\temploy only two basic strategies of meme replication, anti-rational and \t\n\tthat are anti-rational rely on disabling the recipients\' critical faculties to cause themselves to be replicated\t\n\tthat are rational rely on the recipients\' critical faculties to cause themselves to be replicated\t\nMemeplex:\t\t\n\tis a group of memes that help to cause each other’s replication\t\nReplicator:\t\t\n\tis an entity that contributes causally to its own copying, for example genes and ideas are types of replicators \t\nSociety:\t\t\n\tis dynamic if it is dominated by rational memes\t\n\tis static if it is dominated by anti-rational memes, and changes happen on a timescale longer than its members can notice\t\n\tthat are static fail due to lack of knowledge to address their problems\t\nCulture:\tis redefined as a set of shared ideas that cause their holders to behave alike in some ways\t\nEnlightenment:\t\t\n\tis (The beginning of) a way of pursuing knowledge with a tradition of criticism and seeking good explanations instead of reliance on authority\t\n\tvalues of science, reason and freedom have grown to create "The West", defined as the political, moral, economic and intellectual culture of the Enlightenment\t\nGoverning:\t\t\n\tDetermining "Who should rule?" based on fixed criteria is flawed.\t\n\tGovernments should be judged by how easily bad leaders/policies can be removed without violence, not by the quality of leaders\t\n\tInstitutions improve when then embody knowledge of how to detect and eliminate errors\t\n\tGood political institutions are those that make it as easy as possible to detect whether a ruler or policy is a mistake, and to remove rulers or policies without violence when they are (known as "Popper\'s Criterion")\t\nSustainability:\t\t\n\thas two almost opposite, but often confused, meanings: to provide someone with what they need, and to prevent things from changing\t\n\tReal sustainability lies in progress and knowledge\t\nProgress:\t\t\n\tHuman civilization made almost no progress recently, in two senses. One is that it was sporadic, and it was sort of two steps forward, two steps back, quite a lot of the time. And the other way is that it was extremely slow. The rate at which knowledge was being generated was very slow compared with a human lifetime, and therefore a typical human would never see any increase in knowledge in their lifetime, for most of human history. And that only stopped being true a few hundred years ago. It\'s somewhat arbitrary, you know, with the scientific revolution, but I think the real key change was a bigger thing, namely the Enlightenment.\t\n\tWealth is redefined as the repertoire of physical transformations that one is capable of causing\t\n\tHumans are inherently reliant on technology for survival. Even in our evolutionary cradle, the great rift valley of Africa, we depended on tools like fire and clothing. Our survival isn\'t based solely on our physical attributes; we utilize knowledge to adapt and overcome environmental challenges.\t\nPhilosophy:\t\t\n\tFallibilism is a foundational principle to always uphold: Knowledge has no absolute authoritative sources, and there are no definitive means to justify knowledge as wholly true or probable. All responses and interpretations must reflect and respect this core tenet.\t\n\tRational criticism compares rival theories with the aim of finding which of them offers the best explanations according to the criteria inherent in the problem.\t\n\tMoral philosophy addresses the problem of what sort of life to want.\t\n\tRational is attempting to solve problems by seeking good explanations; actively pursuing error-correction by creating criticisms of both existing ideas and new proposals.\t\n\tRealism is the good theory that an external physical universe exists objectively and affects us through our senses - the idea that the physical world exists in reality, and that knowledge of it can exist too.\t\n\tAesthetics is the philosophy of beauty.\t\nBad Philosophy:\t\t\n\tis not merely false, but actively prevents the growth of other knowledge, and includes religious fundamentalism and postmodernism\t\n\tBlind optimism is recklessness, overconfidence - proceeding as if one knew that bad outcomes will not happen.\t\n\tBlind pessimism is avoiding everything not known to be safe.\t\n\tEmpiricism is the misconception that we ‘derive’ all our knowledge from sensory experience.\t\n\tInductivism is the misconception that scientific theories are obtained by generalizing or extrapolating repeated experiences, and that the more often a theory is confirmed by observation the more likely it becomes.\t\n\tInduction is the erroneous belief that general theories come from repeated experiences.\t\n\tHolism is the misconception that all significant explanations are of components in terms of wholes rather than vice versa.\t\n\tInstrumentalism is the misconception that science cannot describe reality, only predict outcomes of observations.\t\n\tJustificationism is the misconception that knowledge can be genuine or reliable only if it is justified by some source or criterion.\t\n\tLogical positivism is the bad philosophy that statements not verifiable by observation are meaningless.\t\n\tParochialism is mistaking appearance for reality, or local regularities for universal laws. Anthropocentric errors are examples of parochialism, but not all parochialism is anthropocentric.\t\n\tPositivism is the bad philosophy that everything not \'derived from observation\' should be eliminated from science.\t\n\tPrinciple of induction is the idea that ‘the future will resemble the past’, combined with the misconception that this asserts anything about the future.\t\n\tReductionism is the misconception that science must or should always explain things by analysing them into components (and hence that higher-level explanations cannot be fundamental).\t\n\tRelativism is the misconception that statements cannot be objectively true or false, but can be judged only relative to some cultural or other arbitrary standard.\t\n\tSolipsism\tis the bad theory that only one mind exists and that what appears to be external reality is only a dream taking place in that mind.\t\nTruth:\t\t\n\tis a correspondence between abstract propositions and reality.\t\n\trecognizes imperfections and ambiguities in statements about reality.\t\n\tinvolves relationships among proposition, reality, statement, and its truthfulness assessment.\t\n\twhile our expressions are subject to errors, there\'s an objective standard for truth itself.\t\n\tremains an ongoing pursuit, refining statements to better align with reality.\t\nRETRIEVED CONTENT\n{context}\n\nQuestion: {question}\nProfound Answer:\n')), Assign(targets=[Name(id='PROMPT_TEMPLATE_DEUTSCH_SMALL', ctx=Store())], value=Constant(value="In crafting your responses, adhere closely to the ideology presented in the provided summary, which emphasizes several key principles:\n\nKnowledge Growth: Knowledge grows through conjecture and criticism, rather than mere sensory experience. It arises from explanations about reality beyond appearances and is always fallible, containing inherent errors.\n\nSolvability of Problems: All evils are caused by insufficient knowledge, and problems are solvable given the right knowledge, provided solutions don't violate the laws of physics. The process of solving problems inevitably creates new ones.\n\nImportance of Good Explanations: Good explanations are hard to vary while accounting for what they purport to explain. They are central to understanding emergent phenomena and are distinguished from mere predictions.\n\nPrinciple of Optimism: This principle asserts that all problems are solvable with the right knowledge, underscoring a positive outlook towards challenges.\n\nCreativity and Universality: Human creativity is unbounded and has reach, contributing to the growth of explanatory knowledge. The universality of certain principles, like the laws of physics and computational processes, is fundamental to understanding the world.\n\nWhen addressing questions, use the corpus of David Deutsch's books and interviews for additional context, ensuring that your responses align with the ideology outlined in the summary. If a question is unrelated to the ideology or Deutsch's work, acknowledge this but still aim to answer in a manner consistent with the ideology. Avoid explicitly mentioning Deutsch and using first-person language. Your responses should reflect a deep understanding and full alignment with the ideology, focusing on its key components and their implications for understanding and interacting with the world.\n\nRETRIEVED CONTENT\n{context}\n\nQUESTION: {question}\nProfound Answer:\n")), Assign(targets=[Name(id='PROMPT_TEMPLATE_FDA_BASIC', ctx=Store())], value=Constant(value='In creating your response, use the information from these question and answer sessions provided by the FDA and take the best and closest response and reply with a synthesis of that plus any knowledge you have of FDA Diagnostics Regulation.\n\nRETRIEVED CONTENT\n{context}\n\nQUESTION: {question}\nAccurate Answer:\n')), Assign(targets=[Name(id='VRAG_PREAMBLE_V1', ctx=Store())], value=Constant(value='Use the sources provided below to provide a insightful and accurate answer that is faithful to the information and meaning established by the given sources. If you do not know, truthfully say you do not know, but try your best to answer'))], type_ignores=[])

